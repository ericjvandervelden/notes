/ See JBOSS LOGGING 
/ See JCA
/ DEBUG TX
/ See ARQUILLIAN-JPA-STUDY2
/ See TODO LOGGER
/ See LEES
/ See INSPECT SQL



/ 7	. 

/ ws workspace-jbosstools-jee-oxygen
/ proj arquillian-getting_started

/ deze heeft 4 configs,
/ 1	. weld container,
/ 2. glassfish ... TODO
/ 3. test start wildfly vanuit mvn repo, wildfly-10.1.0/ verschijnt in target/,				/ wildfly-repo
/ 4. test start wildfly vanuit self extracted bin C:\Users\ervelden\bin\wildfly-10.1.0.Final>		/ wildfly-managed

/ testen tegen zelf gestarte bin, is bij rinse-and-repeat, / wildfly-remote

/ 13	. 

/ we hadden open: http://arquillian.org/guides/get_started_faster_with_forge/

/ 13	. 

/ lees,
http://www.adam-bien.com/roller/abien/entry/the_only_one_dependency_you

/ in LOG_angular20180124.txt,  bij ARQUILLIAN GETTING STARTED
/ we use javax:javaee-api:7.0:provided ipv. org.jboss.spec:jboss-javaee-7.0:1.0.3.Final:pom:provided

/ 13	. 

/ weld-ee-embedded,
			      <dependency>
			        <groupId>org.jboss.arquillian.container</groupId>
			        <artifactId>arquillian-weld-se-embedded-1.1</artifactId>
			        <version>1.0.0.Final</version>
			        <scope>test</scope>
			      </dependency>
			      <dependency>
			        <groupId>org.jboss.weld</groupId>
			        <artifactId>weld-core</artifactId>
			        <version>2.4.5.Final</version>
			        <scope>test</scope>
			      </dependency>
			      <dependency>
			        <groupId>org.slf4j</groupId>
			        <artifactId>slf4j-simple</artifactId>
			        <version>1.7.25</version>
			        <scope>test</scope>
			      </dependency>
				  
/ wildfly-managed,
				<dependency>
				    <groupId>org.wildfly.arquillian</groupId>
				    <artifactId>wildfly-arquillian-container-managed</artifactId>
				    <version>2.1.0.Final</version>
				    <scope>test</scope>
				</dependency>
				<dependency>
				    <groupId>org.jboss.arquillian.protocol</groupId>
				    <artifactId>arquillian-protocol-servlet</artifactId>
				    <version>1.1.13.Final</version>
				    <scope>test</scope>
				</dependency>			      
			    </dependencies>
				
/ TODO
				
/ 13	. 

/ in arquillian.xml mag er maar 1 container default="true",	anders:
Caused by: java.lang.IllegalStateException: Multiple Containers defined as default, only one is allowed:

/ 13	. 

/ het enige verschil in de pom tussen wildfly-managed-from-repo en wildfly-managed is dat wildfly-managed-from-repo de wildfly binary extract in target/ van het project,
/ de zip is:  ~/.m2/repository/org/wildfly/wildfly-dist/10.1.0.Final/wildfly-dist-10.1.0.Final.zip
/ dezelfde binary hebben we zelf al extract in /Users/ervelden/bin/wildfly-10.1.0.Final, die is voor wildfly-managed,

/ in beide gevallen start de test wildfly,	 
/ in rinse-and-repeat starten we eerst zelf wildfly, en test arquillian er tegen,

$ vi pom.xml

  	  <profile>
  		<id>wildfly-managed-from-repo</id>
		...
  		<build>
  			<plugins>
  				<!--  hier staat de mvn wildfly gaat extr in target/ -->
  				<!--  dit is het enigste verschil met wildfly-managed, waar we zelf wildfly al hebben extr -->
  				<plugin>
  					<groupId>org.apache.maven.plugins</groupId>
  					<artifactId>maven-dependency-plugin</artifactId>
  					<version>3.0.2</version>
  					<executions>
  						<execution>
  							<id>unpack</id>
							...
							
  	</profile>
  	 	 <profile>
  		<id>wildfly-managed</id>
		...


/ in pom is wildfly-managed de default profile, dus de test start wildfly binary zelf, (de zelf installed binary , niet de mvn repos)
/ in arquillian.xml mag maar 1 container default, en de naam mag willekeurig, 

$ vi arquillian.xml

/ als je mvn profile wildfly-managed-from-repo kiest	,

	<container qualifier="wildfly-managed-from-repo-foo" default="true">			/ ! default="true"
		<configuration>
			<property name="jbossHome">target/wildfly-10.1.0.Final</property>		
				/ dat is omdat in de pom staat dat de wildfly bin in target/ komt,

/ of als je mvn profile wildfly-managed kiest	,

	<container qualifier="wildfly-managed-foo" default="true">				/ ! default="true"
		<configuration>
			<property name="jbossHome">/Users/ervelden/bin/wildfly-10.1.0.Final</property>
			<!-- 
				<property name="javaVmArguments">-Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y</property>
			-->
		</configuration>
	</container>
	
/ 13	. 

/ In eclipse is er eig. maar 1 run config:  arquillian-getting_started-clean-test, voor wildfly-managed-from-repo en wildfly-managed,
/ Je kunt in de run config bij Environment JBOSS_HOME=/Users/ervelden/bin/wildfly-10.1.0.Final, voor bij  wildfly-managed, maar wij def jbossHome in arquillian.xml,

	
/ 7	. 

/ proj arquillian-rinse-and-repeat

/ 13	. 

/ @Local
/ lees,
https://stackoverflow.com/questions/3807662/ejbs-when-to-use-remote-and-or-local-interfaces
https://docs.oracle.com/javaee/6/tutorial/doc/gipjf.html

/ is @Remote de default?
/ TODO

/ 13	. 

/ lees,
https://stackoverflow.com/questions/8887140/jsf-request-scoped-bean-keeps-recreating-new-stateful-session-beans-on-every-req

/ een tx duurt bij een slsb zolang als de slsb' method duurt,
/ een tx duurt bij een sfsb zolang als de jsf bean leeft,

/ een slsb's method kan meerdere queries doen, maar dat is altijd, in een db kun je in een tx met BEGIN END meerdere dingen doen,

/ 13	. 

/ @Override interface methods kan niet in Java 1.5	, check buildpath in eclipse dat jdk 1.8 is,
/ see OrderServiceImpl	,

/ 13	. 

/ proj arquillian-rinse_and_repeat	,

/ we doen nu wildfly-remote, dus hij draait al, en vind services op port WH,
/ dus in arquillian.xml hoeft NIET een property jbossHome te staan	,
$ vi arquillian.xml
...
<container qualifier="wildfly-managed-foo" default="false">
		<configuration>
			<property name="jbossHome">/Users/ervelden/bin/wildfly-10.1.0.Final</property>			/ hoeft NIET,

/ wat er wel in arquillian.xml staat, is waarheen we de WAR schrijven die ShrinkWrap heeft create:

$ vi arquillian.xml

<arquillian	...>

	<engine>
		<property name="deploymentExportPath">target/deployments</property>
	</engine>
	
	<defaultProtocol type="Servlet 3.0"></defaultProtocol>		/ TODO

/ 13	. 

/ workspace-jbosstools-jee-oxygen-wildfly-quickstart

/ we moeten met de test erbij op 3 plaatsen de ns goed gelijk zetten	,

$ vi HelloWorldService.java

@WebService(targetNamespace = "http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld")
public interface HelloWorldService {


$ vi HelloWorldServiceImpl.java

@WebService(serviceName = "HelloWorldService", portName = "HelloWorld", name = "HelloWorld", endpointInterface = "org.jboss.as.quickstarts.wshelloworld.HelloWorldService",
    targetNamespace = "http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld")
public class HelloWorldServiceImpl implements HelloWorldService {

$ vi Client.java

    public Client(final URL wsdlUrl) {
        QName serviceName = new QName("http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld", "HelloWorldService");


/ we zagen hier en daar,
targetNamespace = "http://www.jboss.org/eap/quickstarts/wshelloworld/HelloWorld"

/ mvn clean test -Parq-wildfly-remote
/ OK,

/ 1313	. 

/ we hoeven op de endpoint interface helemaal geen targetNamespace te geven, 

@WebService
public interface HelloWorldService {

/ is OK,

/ op impl HelloWorldServiceImpl moet het wel,


/ 1313	. 

/ geef	,
http://localhost:8080/wildfly-helloworld-ws/HelloWorldService?wsdl	

/ we zien de juiste ns, 

<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:tns="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:ns1="
http://schemas.xmlsoap.org/soap/http" name="HelloWorldService" targetNamespace="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld">
...

/ 1313	. 

$ git status
On branch 10.x
Your branch is up-to-date with 'origin/10.x'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/org/jboss/as/quickstarts/wshelloworld/HelloWorldService.java
        modified:   src/test/java/org/jboss/as/quickstarts/wshelloworld/Client.java
        modified:   src/test/resources/arquillian.xml


/ 13	. 

/ In arquillian moeten we niet de jbossHome geven, want wildfly draait al,
/ (We mogen WH wel jbossHome geven, maar wordt toch niet used,

$ vi pom.xml

        <profile>
            <!-- An optional testing profile that executes tests in your
                WildFly instance using Arquillian -->
            <!-- This profile will start a new WildFly instance, and execute
                the test, shutting it down when done -->
            <!-- Run with: mvn clean test -Parq-wildfly-managed -->
            <id>arq-wildfly-managed</id>
            <dependencies>
                <dependency>
                    <groupId>org.wildfly.arquillian</groupId>
                    <artifactId>wildfly-arquillian-container-managed</artifactId>
                    <scope>test</scope>
                </dependency>

        <profile>
            <!-- An optional Arquillian testing profile that executes tests
                in a remote WildFly instance -->
            <!-- Run with: mvn clean test -Parq-wildfly-remote -->
            <id>arq-wildfly-remote</id>
            <dependencies>
                <dependency>
                    <groupId>org.wildfly.arquillian</groupId>
                    <artifactId>wildfly-arquillian-container-remote</artifactId>
                    <scope>test</scope>
                </dependency>

/ we zien dus een andere container adapter, die controls and communicates with a container	, 
/ die remote adapter kijkt WH niet naar jbossHome, maar naar de port,

/ 13	. 

/ print de SOAP messages	,

/ we kunnen ook -Dorg.apache.cxf.logging.enabled=true,	 maar dan niet pretty geprint	, maar de payload staat op 1 regel	,

C:\Users\ervelden\bin\wildfly-10.1.0.Final>bin\standalone.bat -Dorg.apache.cxf.logging.enabled=pretty

----------------------------
ID: 1
Address: http://127.0.0.1:8080/wildfly-helloworld-ws/HelloWorldService?wsdl
Http-Method: GET
Content-Type:
Headers: {Accept=[text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2], connection=[keep-alive], Content-Type=[null], Host=[127.0.0.1:8080], User-Agent=[Java/1.8.0_144]}
--------------------------------------
16:28:54,897 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-2) Inbound Message
----------------------------
ID: 2
Address: http://localhost:8080/wildfly-helloworld-ws/HelloWorldService
Encoding: UTF-8
Http-Method: POST
Content-Type: text/xml; charset=utf-8
Headers: {Accept=[text/xml, multipart/related], connection=[keep-alive], Content-Length=[216], content-type=[text/xml; charset=utf-8], Host=[localhost:8080], SOAPAction=[""], User-Agent=[JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e]}
Payload: <S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Body>
    <ns2:sayHello xmlns:ns2="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld"/>
  </S:Body>
</S:Envelope>

--------------------------------------
16:28:54,975 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-2) Outbound Message
---------------------------
ID: 2
Response-Code: 200
Encoding: UTF-8
Content-Type: text/xml
Headers: {}
Payload: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ns2:sayHelloResponse xmlns:ns2="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld">
      <return>Hello World!</return>
    </ns2:sayHelloResponse>
  </soap:Body>
</soap:Envelope>

--------------------------------------
16:28:55,022 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-3) Inbound Message
----------------------------
ID: 3
Address: http://127.0.0.1:8080/wildfly-helloworld-ws/HelloWorldService?wsdl
Http-Method: GET
Content-Type:
Headers: {Accept=[text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2], connection=[keep-alive], Content-Type=[null], Host=[127.0.0.1:8080], User-Agent=[Java/1.8.0_144]}
--------------------------------------
16:28:55,069 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-4) Inbound Message
----------------------------
ID: 4
Address: http://localhost:8080/wildfly-helloworld-ws/HelloWorldService
Encoding: UTF-8
Http-Method: POST
Content-Type: text/xml; charset=utf-8
Headers: {Accept=[text/xml, multipart/related], connection=[keep-alive], Content-Length=[245], content-type=[text/xml; charset=utf-8], Host=[localhost:8080], SOAPAction=[""], User-Agent=[JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e]}
Payload: <S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Body>
    <ns2:sayHelloToName xmlns:ns2="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld">
      <arg0>John</arg0>
    </ns2:sayHelloToName>
  </S:Body>
</S:Envelope>

--------------------------------------
16:28:55,069 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-4) Outbound Message
---------------------------
ID: 4
Response-Code: 200
Encoding: UTF-8
Content-Type: text/xml
Headers: {}
Payload: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ns2:sayHelloToNameResponse xmlns:ns2="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld">
      <return>Hello John!</return>
    </ns2:sayHelloToNameResponse>
  </soap:Body>
</soap:Envelope>

--------------------------------------
16:28:55,100 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-5) Inbound Message
----------------------------
ID: 5
Address: http://127.0.0.1:8080/wildfly-helloworld-ws/HelloWorldService?wsdl
Http-Method: GET
Content-Type:
Headers: {Accept=[text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2], connection=[keep-alive], Content-Type=[null], Host=[127.0.0.1:8080], User-Agent=[Java/1.8.0_144]}
--------------------------------------
16:28:55,147 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-6) Inbound Message
----------------------------
ID: 6
Address: http://localhost:8080/wildfly-helloworld-ws/HelloWorldService
Encoding: UTF-8
Http-Method: POST
Content-Type: text/xml; charset=utf-8
Headers: {Accept=[text/xml, multipart/related], connection=[keep-alive], Content-Length=[281], content-type=[text/xml; charset=utf-8], Host=[localhost:8080], SOAPAction=[""], User-Agent=[JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e]}
Payload: <S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Body>
    <ns2:sayHelloToNames xmlns:ns2="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld">
      <arg0>John</arg0>
      <arg0>Mary</arg0>
      <arg0>Mark</arg0>
    </ns2:sayHelloToNames>
  </S:Body>
</S:Envelope>

--------------------------------------
16:28:55,162 INFO  [org.apache.cxf.services.HelloWorldService.HelloWorld.HelloWorldService] (default task-6) Outbound Message
---------------------------
ID: 6
Response-Code: 200
Encoding: UTF-8
Content-Type: text/xml
Headers: {}
Payload: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ns2:sayHelloToNamesResponse xmlns:ns2="http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld">
      <return>Hello John, Mary &amp; Mark!</return>
    </ns2:sayHelloToNamesResponse>
  </soap:Body>
</soap:Envelope>

--------------------------------------



			




/ 7	. 

/ 

/ 7	. 

/ misc
 	

/ 13	. 

/ undertow	, 

/ lees,
https://www.upwork.com/hiring/development/the-http2-protocol-its-pros-cons-and-how-to-start-using-it/	
https://developers.google.com/web/fundamentals/performance/http2/

/ 7	. 

/ we willen helloworld-ws beter bestuderen, en @Resource WebServiceContext add aan HelloWorldServiceImpl,

/ we werken in de ws workspace-jbosstools-jee-oxygen-wildfly-quickstart, maar de src zijn in java/quickstart/	,

/ we moeten niet in eclipse het project helloworld-ws copy , want dan komt hij in de workspace, en niet in java/quickstart/,

ERVELDEN@LBNL031514 MINGW64 ~/java/quickstart (10.x)
$ cp -a helloworld-ws abc-helloworld-ws

$ git status
On branch 10.x
Your branch is up-to-date with 'origin/10.x'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   helloworld-ws/src/main/java/org/jboss/as/quickstarts/wshelloworld/HelloWorldService.java
        modified:   helloworld-ws/src/test/java/org/jboss/as/quickstarts/wshelloworld/Client.java
        modified:   helloworld-ws/src/test/resources/arquillian.xml

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        abc-helloworld-ws/

no changes added to commit (use "git add" and/or "git commit -a")

ERVELDEN@LBNL031514 MINGW64 ~/java/quickstart (10.x)
$ git add .

ERVELDEN@LBNL031514 MINGW64 ~/java/quickstart (10.x)
$ git status
On branch 10.x
Your branch is up-to-date with 'origin/10.x'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   abc-helloworld-ws/README.md
        new file:   abc-helloworld-ws/pom.xml
        new file:   abc-helloworld-ws/src/main/java/org/jboss/as/quickstarts/wshelloworld/HelloWorldService.java
        new file:   abc-helloworld-ws/src/main/java/org/jboss/as/quickstarts/wshelloworld/HelloWorldServiceImpl.java
        new file:   abc-helloworld-ws/src/main/webapp/WEB-INF/beans.xml
        new file:   abc-helloworld-ws/src/main/webapp/index.html
        new file:   abc-helloworld-ws/src/test/java/org/jboss/as/quickstarts/wshelloworld/Client.java
        new file:   abc-helloworld-ws/src/test/java/org/jboss/as/quickstarts/wshelloworld/ClientArqTest.java
        new file:   abc-helloworld-ws/src/test/java/org/jboss/as/quickstarts/wshelloworld/ClientTest.java
        new file:   abc-helloworld-ws/src/test/resources/arquillian.xml
        modified:   helloworld-ws/src/main/java/org/jboss/as/quickstarts/wshelloworld/HelloWorldService.java
        modified:   helloworld-ws/src/test/java/org/jboss/as/quickstarts/wshelloworld/Client.java
        modified:   helloworld-ws/src/test/resources/arquillian.xml

$ git commit -m "helloworld-ws: ns ok set, copied naar abc-helloworld-ns"

$ vi pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.wildfly.quickstarts</groupId>
    <artifactId>abc-wildfly-helloworld-ws</artifactId>				/  !
    <version>10.0.0-SNAPSHOT</version>

/ voordat we dit project kunnen import in eclipse, moeten we eerst de artifactId aanpassen, anders zegt eclipse dat het project wildfly-helloworld-ws al bestaat	,

ERVELDEN@LBNL031514 MINGW64 ~/java/quickstart (10.x)
$ git add .
$ git commit -m "change artifactId to abc-wildfly-helloworld-ws voor eclipse"
[10.x ebc9c885] change artifactId to abc-wildfly-helloworld-ws voor eclipse
 1 file changed, 1 insertion(+), 1 deletion(-)

/ nu abc-helloworld-ns import in eclipse,
/ we maken een run config in eclipse: abchelloworld-ws-clean-test-Parq-wildfly-remote	, en die doet het meteen	,

/ 13	. 

/ wat doet in BVV:

$ vi HelloWorldServiceImpl.java

class HelloWorldServiceImpl{

@Resource
WebServiceContext context 

MessageContext ctx=context.getMessageContext()
HttpServletRequest req=(HttpServletRequest)ctx.get(MessageContext.SERVLET_REQUEST)
HttpPortUtil.setPort(req.getLocalPort())

/ 13	. 

/ lees,
https://www.baeldung.com/jax-ws
https://www.mkyong.com/webservices/jax-ws/jax-ws-hello-world-example-document-style/

/ de default @SoapBinding is Document/Literal	,

/ als we geen params geven aan @Webservice 

/ 13	. 

/ we kunnen arquillian debug, of wildfly,

/ 1313	. 

/ als we wildfly willen debug, moeten we 
$ >bin\standalone.bat -Dorg.apache.cxf.logging.enabled=pretty  --debug
/ wacht niet echt, maar port 8787 TODO

/ als we arquillian willen gaan debug, dan moeten we in de mvn run config,
$ vi abc-helloworld-ws-clean-test-Parq-wildfly-remote
-Dmaven.surefire.debug clean test -Parq-wildfly-remote													/ !
/ als we deze start, zien we dat hij wacht: Listening for transport dt_socket at address: 5005

/ 1313	. 

/ als we aan willen haken op de arquillian debug, moeten we een debug config 'Remote Java Application' maken, geen mvn ding,
$ vi abc-helloworld-ws-attach-arquillian
project: abc-wildfly-helloworld-ws
port: 5005


/ als we aan wildfly aan willen haken,
$ vi abc-helloworld-ws-attach-wildfly
project: abc-wildfly-helloworld-ws
port: 8787

/ ga naar,
http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl




/ 1313	. 

/ als we de test willen debug, moeten we,

$ bin\standalone.bat	// --debug is NIET nodig	, want we willen niet wildfly debug,
/ run de run config abc-helloworld-ws-clean-test-Parq-wildfly-remote	, met de -Dmaven.surefire.plugin, analoog aan standalone --debug,
/ debug de debug config abc-helloworld-ws-attach-arquillian	, hij valt in de b's van de client	,

/ 13	. 

/ In ClientArqTest doen we,

@RunWith(Arquillian.class)
public class ClientArqTest {
    /**
     * The name of the WAR Archive that will be used by Arquillian to deploy the application.
     */
    private static final String APP_NAME = "wildfly-helloworld-ws2";
    /**
	
/ want wildfly-helloworld-ws is al deployed (op de gewone manier)	, dus is er al,

/ 1313	. 

/ lees,
http://arquillian.org/blog/tags/examples/	
/ over Kubernetes	, 

   @ArquillianResource       (3)
    OpenShiftClient client;



/ 13	. 

/ @ArquillianResource	,

/ als je iets anders wilt inject als met @Inject, of @Resource,

/ lees,
https://stackoverflow.com/questions/38852158/what-is-a-arquillian-resource


Arquillian has support for multiple injection points like @EJB, @Resources and @Inject, but there are also non standard component model objects available within the Arquillian runtime that can be of useful during testing.
Arquillian can expose these objects to the test case using the @ArquillianResource injection annotation.

/ 1313	. 

@ArquillianResource
 private InitialContext context;

 @Test
 public void shouldBeAbleToGetContext() {
      context.lookup("");
 }
 
/ of zo,

/ 1313	. 
 
Usage Example of Argument injection:

 @Test
 public void shouldBeAbleToGetContext(@ArquillianResource InitialContext context) {
      context.lookup("");
 }
 
/ 13	 


/ In 
$ vi ClientArqTest.java

    private static final String APP_NAME = "abc-wildfly-helloworld-ws2";

    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return ShrinkWrap.create(WebArchive.class, APP_NAME + ".war").addPackage(HelloWorldService.class.getPackage());
    }

    @ArquillianResource
    private URL deploymentUrl;
	
    @Before
    public void setup() {
        try {
            client = new Client(new URL(deploymentUrl, WSDL_PATH));
			
   private static final String WSDL_PATH = "HelloWorldServiceX?wsdl";

	
/ In de debugger zien we dat deploymentUrl is: http://localhost:8080/abc-wildfly-helloworld-ws2	,
/ dat klopt, want http://localhost:8080/abc-wildfly-helloworld-ws2/HelloWorldServiceX?wsdl is de url	,

/ we maken hier context name = APP_NAME, in de ShrinkWrap.create call	, maar als we zelf deploy (en niet arq), dan is de context name de artifactId: abc-wildfly-helloworld-ws	,

/ 13	. 

/ 1313	. 

/ De context name is de artifactId in de pom, de context path is dan: 
http://localhost:8080/abc-wildfly-helloworld-ws


/ we hebben geoefend met de args van @WebService, zodat de wsdl verandert. De client, hier de arq client, uses de wsdl via de URL hier vlakboven	,

$ vi HelloWorldServiceImpl.java

@WebService(serviceName = "HelloWorldServiceX", portName = "HelloWorldY", name = "HelloWorldZ", endpointInterface = "org.jboss.as.quickstarts.wshelloworld.HelloWorldService",
    targetNamespace = "http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld")
public class HelloWorldServiceImpl implements HelloWorldService {

/ HelloWorldZ zien we NIET terug in de wsdl,
/ TODO

/ in de client moeten we op 2 plaatsen aanpassen:

$ vi ClientArqTest.java

    private static final String APP_NAME = "abc-wildfly-helloworld-ws2"; / heeft NIETS met wsdl te maken, maar dit is handig, omdat de appl 
			/ deployed kan zijn in wildfly,	 en je kunt niet appl met dezelfde naam deploy,
   
   private static final String WSDL_PATH = "HelloWorldServiceX?wsdl";			/ !

$ vi Client.java

    public Client(final URL wsdlUrl) {
        QName serviceName = new QName("http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld", "HelloWorldServiceX");	 / !

        Service service = Service.create(wsdlUrl, serviceName);
        helloWorldService = service.getPort(HelloWorldService.class);
		
/ een service is een collectie van ports, hier met service.getPort pakt hij er 1 van ,

/ In,
http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl=HelloWorldService.wsdl

<wsdl:portType name="HelloWorldService">

http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl

<wsdl:import location="http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl=HelloWorldService.wsdl" namespace="http://wshelloworld.quickstarts.as.jboss.org/"> </wsdl:import>
<wsdl:binding name="HelloWorldServiceXSoapBinding" type="ns1:HelloWorldService">

<wsdl:service name="HelloWorldServiceX">
<wsdl:port binding="tns:HelloWorldServiceXSoapBinding" name="HelloWorldY">
		
/ 13	 .

/ we zien service.getPort(HelloWorldService.class)	, 

$ vi http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl

	<wsdl:import location="http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl=HelloWorldService.wsdl" namespace="			http://wshelloworld.quickstarts.as.jboss.org/"> </wsdl:import>
	<wsdl:binding name="HelloWorldServiceXSoapBinding" type="ns1:HelloWorldService">
	
	<wsdl:service name="HelloWorldServiceX">
		<wsdl:port binding="tns:HelloWorldServiceXSoapBinding" name="HelloWorldY">
			<soap:address location="http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX"/>
		</wsdl:port>
	</wsdl:service>

/ in de imported wsdl wordt de port type def, en wordt in de binding def used, hierboven: ns1:HelloWorldService	,

$ vi http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl=HelloWorldService.wsdl

<wsdl:portType name="HelloWorldService">
	<wsdl:operation name="sayHello">
		<wsdl:input message="ns1:sayHello" name="sayHello"> </wsdl:input>
		<wsdl:output message="ns1:sayHelloResponse" name="sayHelloResponse"> </wsdl:output>
	</wsdl:operation>



/ 13	 .

/ lees,
http://arquillian.org/blog/tags/rest/

/ lees,
https://docs.jboss.org/author/display/WFLY10/Apache+CXF+integration / SOAP over JMS	,

/ we zien in de arq client com.sun.xml.internal.ws types	, 
/ maar dit is arq, niet wildfly,
/ wildfly werkt WH met cxf, arq niet, 
/ TODO

    public Client(final URL wsdlUrl) {
        QName serviceName = new QName("http://www.wildfly.org/quickstarts/wshelloworld/HelloWorld", "HelloWorldServiceX");

        Service service = Service.create(wsdlUrl, serviceName);
        helloWorldService = service.getPort(HelloWorldService.class);
        assert (helloWorldService != null);
    }
	
/ 13	. 

/ google,
soap service port difference
/ lees,
https://stackoverflow.com/questions/11561/what-is-the-difference-between-an-endpoint-a-service-and-a-port-when-working-w

/ 1313	. 

I'd hop over to http://www.w3.org/TR/wsdl.html which I think explains Port, Service and Endpoint reasonably well. A locator is an implementation specific mechanism that some WS stacks use to provide access to service endpoints.

/ 1313	. 

I would like to add that <port> and <endpoint> serve the same purpose, but port is used by WSDL 1.1 and endpoint by WSDL 2.0.

/ 1313	. 

I found the information based on Kevin Kenny's answer, but I figured I'd post it here for others.

A WSDL document defines services as collections of network endpoints, or ports. In WSDL, the abstract definition of endpoints and messages is separated from their concrete network deployment or data format bindings. This allows the reuse of abstract definitions: messages, which are abstract descriptions of the data being exchanged, and port types which are abstract collections of operations. The concrete protocol and data format specifications for a particular port type constitutes a reusable binding. A port is defined by associating a network address with a reusable binding, and a collection of ports define a service. Hence, a WSDL document uses the following elements in the definition of network services:

Types– a container for data type definitions using some type system (such as XSD).
Message– an abstract, typed definition of the data being communicated.
Operation– an abstract description of an action supported by the service.
Port Type–an abstract set of operations supported by one or more endpoints.
Binding– a concrete protocol and data format specification for a particular port type.
Port– a single endpoint defined as a combination of a binding and a network address.
Service– a collection of related endpoints

/ 13	. 

/ soap service multiple ports

/ we willen de bestaande wsdl aanpassen, met multiple ports,

https://stackoverflow.com/questions/15881256/multiple-port-service-defined-in-a-wsdl

/ we hebben stored in ~\temp\hello\helloworld.wsdl
 http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl 
/ we hebben stored in ~\temp\hello\helloworldincl.wsdl
 http://localhost:8080/abc-wildfly-helloworld-ws/HelloWorldServiceX?wsdl=HelloWorldService.wsdl
 
/ en we hebben aangepast,
~\temp\helloworld.wsdl
<wsdl:import location="helloworldincl.wsdl" namespace="http://wshelloworld.quickstarts.as.jboss.org/"> </wsdl:import>

/ doe,
C:\Users\ervelden\temp\hello>wsimport -keep helloworld.wsdl
/ TODO
/ @WebServiceClient, @Endpoint,

/ wsgen 
/ TODO

/ 1313	. 

/ google
@WebServiceClient
/ lees,
https://stackoverflow.com/questions/23071106/what-is-the-purpose-of-the-webserviceclient-annotation
->
https://coderanch.com/t/225027/Web-Services/java/WebService-WebServiceClient-Annotations
->
https://coderanch.com/t/224792/java/Confusion-writing-web-service-client#000003

http://java.boot.by/ocewsd6-guide/ch06.html


/google
wsimport wsgen
/ lees,
https://coderanch.com/t/625764/certification/difference-wsimport-wsgen-command
->
http://www.mkyong.com/webservices/jax-ws/jax-ws-wsgen-tool-example/

/ 7	. 

/ proj arquillian-cdi-study

/ 13. 

/ forge: project-new heeft default --type war	, 
/ als we geen --type geven, zien we in de pom.xml: <packaging>war</packaging>
/ maar mvn heeft default packaging jar, dus als we project-new --type jar, dan zien we in de pom geen <packaging>	,

/ 13	. 

/ maak een arquillian test, 

/ in LOG_angular20180124.txt,
/ lees,
/ SAMENVATTING FORGE ARQUILLIAN CREATE JPA PROJECT

workspace-jbosstools-jee-oxygen]$ project-new --named arquillian-cdi-study --stack JAVA_EE_7 --type jar
/ import in eclipse,
/ --type war is de default,
/ in src\main\java is er al een dir org\arquillian\jpa\study2
/ in de pom zien we javax:javaee-api, provided,

[arquillian-cdi-study]$ arquillian-setup --test-framework junit --container-adapter wildfly-remote
/ in pom verschijnen van arquillian-junit en arquillian-chameleon <type>pom</type> <scope>import</scope>s, en de profile arquillian-wildfly-remote, 
/ en er is een arquillian.xml met een property chameleonTarget 

[arquillian-cdi-study]$ arquillian-container-configuration --container arquillian-wildfly-remote --container-option jbossHome --container-value C:\Users\ervelden\bin\wildfly-10.1.0.Final
/ HOEFT NIET,

[arquillian-jpa-study2]$ cdi-new-bean --named MyService --scoped SESSION
/ @SessionScoped (managed) CDI bean src/main/java/org.arquillian.cdi.study.beans.MyService.java,

[MyService.java]$ arquillian-create-test --targets org.arquillian.jpa.study2.beans.MyService
/ er is src/test/java/MyServiceTest.java	,

[MyServiceTest.java]$ jpa-setup --jpa-provider Hibernate
/ er is src/main/resources/META-INF/persistence.xml, met ds java:jboss/datasources/ExampleDS
/ Waarom deze ds? In jboss-cli: /subsystem=datasources/data-source=ExampleDS is enigste, de andere zijn /subsystem=datasources/xa-data-source
/ TODO
/ we edit deze: java:jboss/datasources/PostgreSQLDS en  org.hibernate.dialect.PostgreSQLDialect

[persistence.xml]$ jpa-new-entity --named Language
/ @Entity bean src/main/java/org.arquillian.cdi.study.model.Language.java
/ is WH geen EJB bean, want wordt nooit injected	, 
/ TODO

[Language.java]$ jpa-new-field --named name

[Language.java]$ jpa-generate-daos-from-entities --generator JPA_ENTITY --persistence-unit arquillian-jpa-persistence-unit
-targets org.arquillian.jpa.model.Language
/ er is src/main/java/org.arquillian.cdi.study.dao.LanguageDao	, is @Stateless	,

[LanguageDao.java]$ arquillian-create-test --targets org.arquillian.jpa.dao.LanguageDao --enable-jpa
/ creates src/test/java/org.arquillian.cdi.study.dao.LanguageDaoTest
/ pas @Deployment method aan: addClasses(...,Language.class)
/ forge completion kent LanguageDao niet,
/ TODO

$ build test

/ Wanneer verschijnt src/main/resources/META-INF/beans.xml	?
/ TODO

/ wordt een @WebService ooit injected?
/ TODO
/ een @Entity wordt nooit injected? 
/ TODO
/ Wat is context?  Wat is een contextual bean? Is dat een CDI bean?
/ TODO

/ lees,
https://github.com/tolis-e/arquillian-wildfly-example/blob/master/src/test/resources/arquillian.xml

/ 7	. 

/ em.persist , em.merge

/ google,
entitymananger merge persist
/ lees,
https://stackoverflow.com/questions/1069992/jpa-entitymanager-why-use-persist-over-merge
https://vladmihalcea.com/jpa-persist-and-merge/

/ 7	. 

MyEntity e = new MyEntity();

// scenario 1
// tran starts
em.persist(e); 
e.setSomeField(someValue); 
// tran ends, and the row for someField is updated in the database

// scenario 2
// tran starts
e = new MyEntity();
em.merge(e);
e.setSomeField(anotherValue); 
// tran ends but the row for someField is not updated in the database
// (you made the changes *after* merging)

// scenario 3
// tran starts
e = new MyEntity();
MyEntity e2 = em.merge(e);
e2.setSomeField(anotherValue); 
// tran ends and the row for someField is updated
// (the changes were made to e2, not e)

/ 7	. 

/ we gaan zelf verder	, 

/ we rename MyService naar OuterService	, een @SessionScoped	,

[LanguageDaoTest.java]$ ejb-new-bean --named InnerService --type
MESSAGEDRIVEN  SINGLETON  STATEFUL  STATELESS
[LanguageDaoTest.java]$ ejb-new-bean --named InnerService --type STATELESS
/ created src/main/java/org.arquillian.cdi.study.service.InnerService	, een @Stateless @LocalBean	,

/ lees,
http://theopentutorials.com/tutorials/java-ee/ejb3/session-beans/client-view/no-interface-client-view-in-ejb-3-1/
/ bij @Inject kun je de @LocalBean class geven, je hoeft niet een interface te maken, die de class moet implements, en die je bij @Inject dan zou use,



/ 13	. 

/ google
@Local @LocalBean
/ lees,
https://stackoverflow.com/questions/7362257/inject-ejb-local-remote-localbean-etc-confused

With Java EE 6, Java Enterprise has changed. A new JSR defines a so-called managed bean (don't confuse with JSF managed beans) as a sort of minimum component that can still benefit from the container in terms of dependency injection and lifecycle management. This means: If you have a component and "just" want to use DI and let the container control its lifecycle, you do not need to use EJBs for it. You'll end up using EJBs if - and only if - you explicitly need EJB functionality like transaction handling, pooling, passivation and clustering.

This makes the answer to your question come in three parts:

Use @Inject over @EJB, the concept of CDI (a) works for all managed beans (this includes EJBs) and (b) is stateful and therefore far superior over pure @EJB DI
Are you sure that you need EJBs for your components?
It's definitely worthwhile to have a look at the CDI documentation

/ google
implicit beans
/ lees,
https://docs.jboss.org/weld/reference/latest/en-US/html/ee.html#_implicit_bean_archive

/ 13	.

An explicit bean archive is an archive which contains a beans.xml file:

with a version number of 1.1 (or later), with the bean-discovery-mode of all, or,
like in CDI 1.0 – with no version number, or, that is an empty file.
It behaves just like a CDI 1.0 bean archive – i.e. Weld discovers each Java class, interface or enum in such an archive.

Note
The beans.xml file must be located at:

META-INF/beans.xml (for jar archives), or,
WEB-INF/beans.xml or WEB-INF/classes/META-INF/beans.xml (for WAR archives).
You should never place a beans.xml file in both of the WEB-INF and the WEB-INF/classes/META-INF directories. Otherwise your application would not be portable.

/ 13	.  

15.6.2. Implicit bean archive
An implicit bean archive is an archive which contains one or more bean classes with a bean defining annotation, or one or more session beans. It can also contain a beans.xml file with a version number of 1.1 (or later), with the bean-discovery-mode of annotated. Weld only discovers Java classes with a bean defining annotation within an implicit bean archive.

Note
The set of bean defining annotations contains:

@ApplicationScoped, @SessionScoped, @ConversationScoped and @RequestScoped annotations,
all other normal scope types,
@Interceptor and @Decorator annotations,
all stereotype annotations (i.e. annotations annotated with @Stereotype),
and the @Dependent scope annotation.
However, @Singleton is not a bean defining annotation. See 2.5.1. Bean defining annotations to learn more.
/ refs naar http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations

/ 13	. 

/ google,
arquillian test requestscoped
/ lees,
https://developer.jboss.org/thread/219867
->
https://stackoverflow.com/questions/13179180/isolated-testing-of-backing-bean-that-uses-requestparam-without-jsf-pages

/ lees arquillian docs,
https://docs.jboss.org/author/display/ARQ/Container+configuration

/ 13	. 

/ in forge,
servlet-new-servlet
soap-new service
rest/

/ google 
forge rest service
/ lees,
http://www.mastertheboss.com/jboss-frameworks/resteasy/creating-a-rest-application-with-jboss-forge-in-a-minute

[SoapService.java]$ jpa-new-entity --named Customer
***SUCCESS*** JPA Entity org.arquillian.cdi.study.model.Customer was created
[Customer.java]$ jpa-new-field --n
--named  --not-insertable  --not-nullable  --not-updatable
[Customer.java]$ jpa-new-field --named firstName
***SUCCESS*** Field firstName created
[Customer.java]$ jpa-new-field --named surName
***SUCCESS*** Field surName created
[Customer.java]$ jpa-new-field --named email
***SUCCESS*** Field email created
[Customer.java]$ cd ~~
/ TODO moet dit per se ?
[arquillian-cdi-study]$ rest-generate-endpoints-from-entities --targets org.arquillian.cdi.study.model.
org.arquillian.cdi.study.model.Customer  org.arquillian.cdi.study.model.Language
[arquillian-cdi-study]$ rest-generate-endpoints-from-entities --targets org.arquillian.cdi.study.model.Customer
***SUCCESS*** JAX-RS has been installed.
/ TODO
***SUCCESS*** Endpoint created
/ created subclass of javax.ws.rs.core.Application, created @Stateless CustomerEndpoint	,

/ Intermezzo

/ de Application class is ipv configuratie in web.xml,

/ lees,
https://stackoverflow.com/questions/12452064/how-to-configure-jax-rs-web-service-web-xml-properly

3

You've set the wrong servlet. Assuming that you're using Jersey, You need to specify your servlet as follows:

<servlet>
    <servlet-name>Rest</servlet-name>
    <servlet-class>com.sun.jersey.spi.container.servlet.ServletContainer</servlet-class>
    <init-param>
        <param-name>com.sun.jersey.config.property.packages</param-name>
        <param-value>org.LMS.Controller.Test</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Rest</servlet-name>
    <url-pattern>/rest/*</url-pattern>
</servlet-mapping>

And when you want to access it, you use the following url

http://(host)[:port]/(context path)/rest/test
e.g. 
http://localhost:8080/MyRestProject/rest/test

/ blijkbaar is er ook altijd een servlet,
/ bij ons ook?
/ TODO 

/ lees,
https://stackoverflow.com/questions/5930795/difference-between-servlet-and-web-service


/ Einde Intermezzo

/ 13	. 

/ in forge met build kun je alles doen wat je met mvn doet, behalve: clean, maar dat doet hij zelf al,
$ build
/ doet WH $ mvn clean install
$ build package
/ doet WH $ mvn clean package
$ build wildfly:redeploy
/ doet WH $ mvn clean wildfly:redeploy

$ vi pom.xml
	<packaging>war</packaging>
...
          <plugin>	<!--  self -->
			  <groupId>org.wildfly.plugins</groupId>
			  <artifactId>wildfly-maven-plugin</artifactId>
			  <version>1.2.2.Final</version>
			</plugin>
        </plugins>

/ Met de nieuwste versie 2.0.1.Final krijg ik een foutmelding bij
$ mvn clean wildfly:deploy

/ in jboss-cli kun je met $ deployment-info zien:
[standalone@localhost:9990 /] deployment-info
NAME                          RUNTIME-NAME                  PERSISTENT ENABLED STATUS
arquillian-cdi-study.war      arquillian-cdi-study.war      true       true    OK	

/ 13	. 

/ verder op,
http://www.mastertheboss.com/jboss-frameworks/resteasy/creating-a-rest-application-with-jboss-forge-in-a-minute

/ we gaan verder in een git-bash console,

$  curl -d '{ "firstName":"John","surName":"Doe","email":"john.doe@company.com" }' -H "Content-Type:application/json" -X POST http://localhost:8080/arquillian-cdi-study/rest/customers
$  curl -d '{ "firstName":"Uncle ","surName":"Tom","email":"uncle.tom@company.com" }' -H "Content-Type:application/json" -X POST http://localhost:8080/arquillian-cdi-study/rest/customers


/ geef in browser:
http://localhost:8080/arquillian-cdi-study/rest/customers/
[
{
id: 1,
version: 0,
firstName: "John",
surName: "Doe",
email: "john.doe@company.com"
},
{
id: 2,
version: 0,
firstName: "Uncle ",
surName: "Tom",
email: "uncle.tom@company.com"
}
]
/ of,
http://localhost:8080/arquillian-cdi-study/rest/customers/1
{
id: 1,
version: 0,
firstName: "John",
surName: "Doe",
email: "john.doe@company.com"
}

/ of op de command line,

ERVELDEN@LBNL031514 MINGW64 ~/eclipse/workspace-jbosstools-jee-oxygen/wildfly-swarm-examples (master)
$  curl -d '{ "firstName":"Uncle ","surName":"Tom","email":"uncle.tom@company.com" }' -H "Content-Type:application/json" -X POST http://localhost:8080/arquillian-cdi-study/rest/customers
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    72    0     0  100    72      0     72  0:00:01 --:--:--  0:00:01   230

$ curl http://localhost:8080/arquillian-cdi-study/rest/customers/
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   181  100   181    0     0    181      0  0:00:01 --:--:--  0:00:01   644[{"id":2,"version":0,"firstName":"Uncle ","surName":"Tom","email":"uncle.tom@company.com"},{"id":3,"version":0,"firstName":"Uncle ","surName":"Tom","email":"uncle.tom@company.com"}]

$ curl http://localhost:8080/arquillian-cdi-study/rest/customers/3
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    89  100    89    0     0     89      0  0:00:01 --:--:--  0:00:01   356{"id":3,"version":0,"firstName":"Uncle ","surName":"Tom","email":"uncle.tom@company.com"}


/ we doen nu,

$ curl -X DELETE http://localhost:8080/arquillian-cdi-study/rest/customers/1

/ geef,
http://localhost:8080/arquillian-cdi-study/rest/customers
[
{
id: 2,
version: 0,
firstName: "Uncle ",
surName: "Tom",
email: "uncle.tom@company.com"
}
]

/ 13	. 

/ MORGEN 

/ soap maken met forge,

/ lees,
https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/6/html/development_guide/sect-jax-ws_web_service_endpoints





		



/ 13	. 

/ forge, 

https://forge.jboss.org/documentation

/ lees,
https://forge.jboss.org/document/write-a-java-ee-rest-application---basic



/ 13	. 

/ google
cdi contextual bean
/ lees,
https://stackoverflow.com/questions/15520424/what-is-a-cdi-bean

PrintServlet.java

@WebServlet("/printservlet")
public class PrintServlet extends HttpServlet {
    @Inject private Message message;

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.getWriter().print(message.get());
    }
}

Message.java (This class is a CDI bean)

@RequestScoped
public class Message {
    @Override
    public String get() {
        return "Hello World!";
    }
}

/ 13	. 

/ google,
CDI annotations
/ lees,
http://www.sws.bfh.ch/~fischli/courses/info/javaee/doc/JavaEE7AnnotationsCheatSheet.pdf

CDI: javax.inject
CMF @Inject
@Named(value=””)
@Singleton

CDI: javax.enterprise.context
TMF @ApplicationScoped
TMF @SessionScoped
TMF @ConversationScoped
TMF @RequestScoped
TMF @Dependent

CDI: javax.enterprise.inject
TMF @New(value=Class.class)
TMF @Alternative
TMF @Any
MF @Produces, @Disposes

/ lees,	
https://dzone.com/refcardz/contexts-and-depencency?chapter=3

/ ook,
@Interceptor and @Decorator annotations
All stereotype annotations (i.e. annotations annotated with @Stereotype),
The @Dependent scope annotation.


/ 13	. 

$ vi pom.xml

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>3.0.3.Final</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
	  
/ we zien in de effective pom,

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>javax.annotation</groupId>
        <artifactId>jsr250-api</artifactId>
        <version>1.0</version>
        <scope>provided</scope>
      </dependency>
      <dependency>
        <groupId>javax.activation</groupId>
        <artifactId>activation</artifactId>
        <version>1.1.1</version>
      </dependency>
      <dependency>
        <groupId>javax.enterprise</groupId>
        <artifactId>cdi-api</artifactId>
        <version>1.0-SP4</version>
        <exclusions>
          <exclusion>
            <artifactId>jboss-interceptor-api</artifactId>
            <groupId>org.jboss.interceptor</groupId>
          </exclusion>
          <exclusion>
            <artifactId>jsr250-api</artifactId>
            <groupId>javax.annotation</groupId>
          </exclusion>
        </exclusions>
      </dependency>
	  
	  
/ als we in de Central repository,

https://search.maven.org/artifact/org.jboss.spec/jboss-javaee-6.0/3.0.3.Final/pom

/ dan zien we,

    <version.javax.activation>1.1.1</version.javax.activation>
    <version.javax.enterprise>1.0-SP4</version.javax.enterprise>
    <version.javax.inject>1</version.javax.inject>
    <version.javax.jws>1.0-MR1</version.javax.jws>

 <dependencyManagement>

    <dependencies>

      <!-- External JavaEE spec APIs (not part of the JBoss JavaEE Specs 
        project) -->
      <dependency>
        <groupId>javax.activation</groupId>
        <artifactId>activation</artifactId>
        <version>${version.javax.activation}</version>
      </dependency>
      <dependency>
        <groupId>javax.enterprise</groupId>
        <artifactId>cdi-api</artifactId>
        <version>${version.javax.enterprise}</version>
        <exclusions>
          <exclusion>
            <groupId>org.jboss.interceptor</groupId>
            <artifactId>jboss-interceptor-api</artifactId>
          </exclusion>
          <exclusion>
            <groupId>javax.annotation</groupId>
            <artifactId>jsr250-api</artifactId>
          </exclusion>
        </exclusions>
      </dependency>
 
/ klopt precies	,

/ 7	. 

/ workspace-jbosstools-jee-oxygen
/ proj 


/ native query in ItemDao,
/ TODO
/ named query in ItemDao
/ TODO
	
/ 7	 

/ lees,
https://www.postgresql.org/docs/9.5/ddl-constraints.html

/ het verschil tussen een fk in create table en in alter table is dat je de woorden 'foreign key' alleen in alter table plaats,
/ constraint gebruik je in create table en alter table alleen als je de fk een naam wilt geven, anders wordt deze gen; dat is makkelijk als je een fk wilt drop	,

/ on delete cascade

test=> create table order_(i int primary key,s text);
test=> create table item_(i int primary key,j int references order_ on delete cascade,s text);
/ of, voor als je een fk later wilt veranderen geef je de fk een naam, 
test=> create table item_(i int primary key,j int constraint order_fk references order_ on delete cascade,s text);
test=> insert into order_ values(1,'foo');
test=> insert into item_ values(11,1,'bar');
test=> delete from order_;
DELETE 1
test=> select * from item_;
 i | j | s
---+---+---
(0 rows)

/ on delete restrict

test=> alter table item_ drop constraint ord;
test=> alter table item_ add constraint order_fk foreign key(j)references order_ on delete restrict;
test=> insert into order_ values(1,'foo');
test=> insert into item_ values(11,1,'bar');
test=> delete from order_;
ERROR:  update or delete on table "order_" violates foreign key constraint "order_fk" on table "item_"
DETAIL:  Key (i)=(1) is still referenced from table "item_".

/ on delete no action

test=> alter table item_ drop constraint ord;
test=> alter table item_ add constraint order_fk foreign key(j)references order_ on delete no action;
/=
test=> alter table item_ add constraint order_fk foreign key(j)references order_;

test=> delete from order_;
ERROR:  update or delete on table "order_" violates foreign key constraint "order_fk" on table "item_"
DETAIL:  Key (i)=(1) is still referenced from table "item_".

Restricting and cascading deletes are the two most common options. RESTRICT prevents deletion of a referenced row. NO ACTION means that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is that NO ACTION allows the check to be deferred until later in the transaction, whereas RESTRICT does not.) 

/ 7	 .

@Entity
public class Item implements Serializable {
	@OneToMany(mappedBy = "item",cascade=CascadeType.ALL)
	private Set<Bid> bids = new HashSet<>();
/ cascade TODO

/ 7	. 

/ google,
hibernate import.sql
/ lees,
https://stackoverflow.com/questions/673802/how-to-import-initial-data-to-database-with-hibernate
	  
Hibernate will create the database when the entity manager factory is created (actually when Hibernate's SessionFactory is created by the entity manager factory). If a file named import.sql exists in the root of the class path ('/import.sql') Hibernate will execute the SQL statements read from the file after the creation of the database schema. It is important to remember that before Hibernate creates the schema it empties it (delete all tables, constraints, or any other database object that is going to be created in the process of building the schema).

/ we doen nu @BeforeClass in BidDaoTest.java, 
/ maar vervang door import.sql, 
/ en vervang in persistence.xml dat het schema niet door H. wordt create,
/ de arq test pakt WH src/test/resources/META-INF/test-persistence.xml TODO

/ 13	. 

/ we moeten een Item() ctor 	, want,

foo(org.arquillian.jpa.study2.dao.BidDaoTest)  Time elapsed: 0.345 sec  <<< ERROR!
javax.ejb.EJBException: javax.persistence.PersistenceException: org.hibernate.InstantiationException: No default constructor for entity:  : org.arquillian.jpa.study2.model.Item
        at org.hibernate.tuple.PojoInstantiator.instantiate(PojoInstantiator.java:84)
        at org.hibernate.tuple.PojoInstantiator.instantiate(PojoInstantiator.java:100)
        at org.hibernate.tuple.entity.AbstractEntityTuplizer.instantiate(AbstractEntityTuplizer.java:636)
        at org.hibernate.persister.entity.AbstractEntityPersister.instantiate(AbstractEntityPersister.java:4627)
        at org.hibernate.internal.SessionImpl.instantiate(SessionImpl.java:1470)
        at org.hibernate.internal.SessionImpl.instantiate(SessionImpl.java:1454)
        at org.hibernate.loader.Loader.instanceNotYetLoaded(Loader.java:1646)
        at org.hibernate.loader.Loader.getRow(Loader.java:1544)
        at org.hibernate.loader.Loader.getRowFromResultSet(Loader.java:727)
        at org.hibernate.loader.Loader.processResultSet(Loader.java:972)
        at org.hibernate.loader.Loader.doQuery(Loader.java:930)
        at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:336)
        at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:306)
        at org.hibernate.loader.Loader.loadEntity(Loader.java:2204)
        at org.hibernate.loader.entity.AbstractEntityLoader.load(AbstractEntityLoader.java:60)
        at org.hibernate.loader.entity.AbstractEntityLoader.load(AbstractEntityLoader.java:50)
        at org.hibernate.persister.entity.AbstractEntityPersister.load(AbstractEntityPersister.java:3967)
        at org.hibernate.event.internal.DefaultLoadEventListener.loadFromDatasource(DefaultLoadEventListener.java:508)
        at org.hibernate.event.internal.DefaultLoadEventListener.doLoad(DefaultLoadEventListener.java:478)
        at org.hibernate.event.internal.DefaultLoadEventListener.load(DefaultLoadEventListener.java:219)
        at org.hibernate.event.internal.DefaultLoadEventListener.proxyOrLoad(DefaultLoadEventListener.java:278)
        at org.hibernate.event.internal.DefaultLoadEventListener.doOnLoad(DefaultLoadEventListener.java:121)
        at org.hibernate.event.internal.DefaultLoadEventListener.onLoad(DefaultLoadEventListener.java:89)
        at org.hibernate.internal.SessionImpl.fireLoad(SessionImpl.java:1129)
        at org.hibernate.internal.SessionImpl.access$2600(SessionImpl.java:164)
        at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.load(SessionImpl.java:2696)
        at org.hibernate.internal.SessionImpl.get(SessionImpl.java:980)
        at org.hibernate.event.internal.DefaultMergeEventListener.entityIsDetached(DefaultMergeEventListener.java:290)
        at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:170)
        at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:69)
        at org.hibernate.internal.SessionImpl.fireMerge(SessionImpl.java:840)
        at org.hibernate.internal.SessionImpl.merge(SessionImpl.java:822)
        at org.hibernate.internal.SessionImpl.merge(SessionImpl.java:827)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.merge(AbstractEntityManagerImpl.java:1161)
        at org.jboss.as.jpa.container.AbstractEntityManager.merge(AbstractEntityManager.java:565)
        at org.arquillian.jpa.study2.dao.BidDao.create(BidDao.java:23)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(ManagedReferenceMethodInterceptor.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(Jsr299BindingsInterceptor.java:82)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(Jsr299BindingsInterceptor.java:93)
        at org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(UserInterceptorFactory.java:63)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(ExecutionTimeInterceptor.java:43)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(SBInvocationInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor.aroundInvoke(AbstractEJBRequestScopeActivationInterceptor.java:64)
        at org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(EjbRequestScopeActivationInterceptor.java:83)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(ConcurrentContextInterceptor.java:45)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InitialInterceptor.processInvocation(InitialInterceptor.java:21)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(ComponentDispatcherInterceptor.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(PooledInstanceInterceptor.java:51)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:275)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.required(CMTTxInterceptor.java:327)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(CMTTxInterceptor.java:239)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(CurrentInvocationContextInterceptor.java:41)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(WaitTimeInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(SecurityContextInterceptor.java:100)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(StartupAwaitInterceptor.java:22)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:67)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java:54)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:636)
        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:198)
        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)
        at org.arquillian.jpa.study2.dao.BidDao$$$view11.create(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(Reflections.java:433)
        at org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler.invoke(EnterpriseBeanProxyMethodHandler.java:128)
        at org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance.invoke(EnterpriseTargetBeanInstance.java:56)
        at org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(InjectionPointPropagatingEnterpriseTargetBeanInstance.java:67)
        at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:100)
        at org.arquillian.jpa.study2.dao.BidDao$Proxy$_$$_Weld$EnterpriseProxy$.create(Unknown Source)
        at org.arquillian.jpa.study2.dao.BidDaoTest.init(BidDaoTest.java:45)

foo(org.arquillian.jpa.study2.dao.BidDaoTest)  Time elapsed: 0.566 sec  <<< ERROR!
javax.ejb.EJBException: java.lang.IllegalArgumentException: Removing a detached instance org.arquillian.jpa.study2.model.Item#5
        at org.hibernate.jpa.event.internal.core.JpaDeleteEventListener.performDetachedEntityDeletionCheck(JpaDeleteEventListener.java:52)
        at org.hibernate.event.internal.DefaultDeleteEventListener.onDelete(DefaultDeleteEventListener.java:89)
        at org.hibernate.event.internal.DefaultDeleteEventListener.onDelete(DefaultDeleteEventListener.java:56)
        at org.hibernate.internal.SessionImpl.fireDelete(SessionImpl.java:921)
        at org.hibernate.internal.SessionImpl.delete(SessionImpl.java:860)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.remove(AbstractEntityManagerImpl.java:1179)
        at org.jboss.as.jpa.container.AbstractEntityManager.remove(AbstractEntityManager.java:655)
        at org.arquillian.jpa.study2.dao.ItemDao.delete(ItemDao.java:28)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(ManagedReferenceMethodInterceptor.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(Jsr299BindingsInterceptor.java:82)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(Jsr299BindingsInterceptor.java:93)
        at org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(UserInterceptorFactory.java:63)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(ExecutionTimeInterceptor.java:43)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(SBInvocationInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor.aroundInvoke(AbstractEJBRequestScopeActivationInterceptor.java:64)
        at org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(EjbRequestScopeActivationInterceptor.java:83)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(ConcurrentContextInterceptor.java:45)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InitialInterceptor.processInvocation(InitialInterceptor.java:21)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(ComponentDispatcherInterceptor.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(PooledInstanceInterceptor.java:51)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:275)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.required(CMTTxInterceptor.java:327)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(CMTTxInterceptor.java:239)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(CurrentInvocationContextInterceptor.java:41)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(WaitTimeInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(SecurityContextInterceptor.java:100)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(StartupAwaitInterceptor.java:22)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:67)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java:54)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:636)
        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:198)
        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)
        at org.arquillian.jpa.study2.dao.ItemDao$$$view16.delete(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(Reflections.java:433)
        at org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler.invoke(EnterpriseBeanProxyMethodHandler.java:128)
        at org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance.invoke(EnterpriseTargetBeanInstance.java:56)
        at org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(InjectionPointPropagatingEnterpriseTargetBeanInstance.java:67)
        at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:100)
        at org.arquillian.jpa.study2.dao.ItemDao$Proxy$_$$_Weld$EnterpriseProxy$.delete(Unknown Source)
        at org.arquillian.jpa.study2.dao.BidDaoTest.fini(BidDaoTest.java:53)





/ set b in GreeterTest.java


/ 13	. 

/ in dit quickstart voorbeeld (tasks-rs) worden geen Users rm	,

/ let op dat je em.merge(user) weer toekent aan user, anders blijft user detached,

public class Task implements Serializable {
    @ManyToOne
    private User owner;
	
public class User implements Serializable {
    @OneToMany(cascade = ALL, mappedBy = "owner")
    @Column(updatable = false)
    private List<Task> tasks = new ArrayList<>();
	
@Stateful
public class TaskDaoImpl implements TaskDao {
    @Override
    public void createTask(User user, Task task) {
        if (!em.contains(user)) {
            user = em.merge(user);					/ !
        }
        user.getTasks().add(task);
        task.setOwner(user);
        em.persist(task);
    }
    @Override
    public void deleteTask(Task task) {
        if (!em.contains(task)) {
            task = em.merge(task);
        }
        em.remove(task);
    }

@Stateful
public class UserDaoImpl implements UserDao {
    public void createUser(User user) {
        em.persist(user);
    }

/ 13	. 

/ we hebben,

@Entity
public class Item implements Serializable {
...
	@OneToMany(mappedBy = "item",cascade=CascadeType.ALL)
	@Column(updatable=false)
	private Set<Bid> bids = new HashSet<>();
	
@Entity
public class Bid implements Serializable {
...
	@ManyToOne
	@JoinColumn(nullable = false)
	private Item item;
	
/ toch werkt de cascade niet:
	

/ we krijgen	,

2019-03-27 07:56:40,441 DEBUG [org.jboss.as.jpa] (default task-103) default task-103:transaction scoped EntityManager [9c24d8aa-cb89-485f-9cb1-45b189c8ac07.war#arquillian-jpa-study2-persistence-unit]: closing e
ntity managersession
2019-03-27 07:56:40,443 ERROR [org.jboss.as.ejb3.invocation] (default task-103) WFLYEJB0034: EJB Invocation failed on component ItemDao for method public void org.arquillian.jpa.study2.dao.ItemDao.delete(org.ar
quillian.jpa.study2.model.Item): javax.ejb.EJBTransactionRolledbackException: Transaction rolled back
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.handleEndTransactionException(CMTTxInterceptor.java:137)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(CMTTxInterceptor.java:117)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:279)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.required(CMTTxInterceptor.java:327)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(CMTTxInterceptor.java:239)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(CurrentInvocationContextInterceptor.java:41)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(WaitTimeInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(SecurityContextInterceptor.java:100)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(StartupAwaitInterceptor.java:22)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:67)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java:54)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:636)
        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:198)
        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)
        at org.arquillian.jpa.study2.dao.ItemDao$$$view34.delete(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
		at org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(Reflections.java:433)
        at org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler.invoke(EnterpriseBeanProxyMethodHandler.java:128)
        at org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance.invoke(EnterpriseTargetBeanInstance.java:56)
        at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:100)
        at org.arquillian.jpa.study2.dao.ItemDao$Proxy$_$$_Weld$EnterpriseProxy$.delete(Unknown Source)
        at org.arquillian.jpa.study2.dao.BidDaoTest.fini(BidDaoTest.java:53)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
        at org.junit.internal.runners.statements.RunAfters.invokeMethod(RunAfters.java:46)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:33)
        at org.jboss.arquillian.junit.Arquillian$StatementLifecycleExecutor.invoke(Arquillian.java:468)
        at org.jboss.arquillian.container.test.impl.execution.AfterLifecycleEventExecuter.on(AfterLifecycleEventExecuter.java:35)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.testenricher.cdi.CreationalContextDestroyer.destory(CreationalContextDestroyer.java:44)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:92)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:114)
        at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.after(EventTestRunnerAdaptor.java:122)
		at org.jboss.arquillian.junit.Arquillian$5$1.evaluate(Arquillian.java:265)
        at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:431)
        at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:55)
        at org.jboss.arquillian.junit.Arquillian$5.evaluate(Arquillian.java:260)
        at org.jboss.arquillian.junit.Arquillian$7$1.invoke(Arquillian.java:324)
        at org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(BeforeLifecycleEventExecuter.java:35)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:92)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:114)
        at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(EventTestRunnerAdaptor.java:159)
        at org.jboss.arquillian.junit.Arquillian$7.evaluate(Arquillian.java:317)
        at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:365)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
        at org.junit.runners.ParentRunner$4.run(ParentRunner.java:330)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:78)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:328)
        at org.junit.runners.ParentRunner.access$100(ParentRunner.java:65)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:292)
        at org.jboss.arquillian.junit.Arquillian$2.evaluate(Arquillian.java:205)
        at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:431)
        at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:55)
        at org.jboss.arquillian.junit.Arquillian$3.evaluate(Arquillian.java:219)
        at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:305)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:412)
        at org.jboss.arquillian.junit.Arquillian.run(Arquillian.java:167)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
		at org.jboss.arquillian.junit.container.JUnitTestRunner.execute(JUnitTestRunner.java:66)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(ServletTestRunner.java:170)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(ServletTestRunner.java:135)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(ServletTestRunner.java:98)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
        at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85)
        at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
        at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
        at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:131)
        at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
        at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)
        at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)
        at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77)
        at io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(NotificationReceiverHandler.java:50)
        at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135)
        at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)
        at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104)
        at io.undertow.server.Connectors.executeRootHandler(Connectors.java:202)
        at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:805)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
Caused by: org.postgresql.util.PSQLException: ERROR: update or delete on table "item" violates foreign key constraint "fkofartcioobwpek3qex4cmturt" on table "bid"
  Detail: Key (id)=(1) is still referenced from table "bid".
        at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2182)
        at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1911)
        at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:173)
        at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:615)
        at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:465)
        at org.postgresql.jdbc2.AbstractJdbc2Statement.executeUpdate(AbstractJdbc2Statement.java:411)
        at sun.reflect.GeneratedMethodAccessor110.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(AbstractJdbc23PooledConnection.java:453)
        at com.sun.proxy.$Proxy210.executeUpdate(Unknown Source)
        at org.jboss.jca.adapters.jdbc.WrappedPreparedStatement.executeUpdate(WrappedPreparedStatement.java:537)
        at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:204)
        ... 220 more

/ 13	. 

/ lees,
https://vladmihalcea.com/a-beginners-guide-to-jpa-and-hibernate-cascade-types/
@OneToOne(mappedBy = "post",
        cascade = CascadeType.ALL, orphanRemoval = true)
    private PostDetails details;
 

/ 13	. 

/ google,
jboss.jdbc.spy show transcations
/ lees,	
https://gist.github.com/rafaeltuelho/1540b3c708c6ddfa9019
->
https://docs.jboss.org/author/display/WFLY/JPA+Reference+Guide#JPAReferenceGuide-Troubleshooting

/ 13	. 

/ JBOSS LOGGING

/ see ook LOG_arquillian-tmp.txt, JBOSS LOGGING

/ google,
jboss logging WARN DEBUG
/ lees	,
https://docs.jboss.org/author/display/WFLY10/Logging+Configuration
https://docs.jboss.org/author/display/WFLY10/How+To
https://developer.jboss.org/thread/176398
https://github.com/wildfly/quickstart/tree/master/logging

https://developer.jboss.org/thread/229857?start=15&tstart=0

/ 13	. 

/ we zien in server.log,
2019-03-29 17:33:19,619 WARN  [org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$AS7DataSourceDeployer] (MSC service thread 1-7) IJ020016: Missing <recovery> element. XA recovery disabled for: java:jboss/datasources/H2DS
2019-03-29 17:33:19,619 WARN  [org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$AS7DataSourceDeployer] (MSC service thread 1-3) IJ020016: Missing <recovery> element. XA recovery disabled for: java:jboss/datasources/PostgreSQLDS

/ 7	 

/ JCA

/ lees,
https://developer.jboss.org/thread/229857
http://www.ironjacamar.org/doc/userguide/1.1/en-US/html/ch05.html

/ lees,
http://www.ironjacamar.org/doc/userguide/1.1/en-US/html/ch01.html

The Java Connector Architecture (JCA) defines a standard architecture for connecting the Java EE platform to heterogeneous Enterprise Information Systems (EIS). Examples of EISs include Enterprise Resource Planning (ERP), mainframe transaction processing (TP), databases and messaging systems.

/ 13	. 

/ google,
XA recovery disabled for: java:jboss/datasources
/ lees ,
https://developer.jboss.org/thread/248652
->
https://developer.jboss.org/wiki/HowToUseOutOfProcessActiveMQWithWildFly
/ over externe amq	,

/ google,
wildfly external activemq
/ lees,
https://stackoverflow.com/questions/39284009/how-to-send-jms-messages-from-wildfly-10-to-remote-activemq
->
https://docs.jboss.org/author/display/WFLY10/Connect+a+pooled-connection-factory+to+a+Remote+Artemis+Server

/ lees,
https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/5/html/hornetq_user_guide/xa-recovery

https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/4.3/html/transactions_failure_recovery_guide/
https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/4.3/html/transactions_failure_recovery_guide/sect-transactions_failure_recovery_guide-architecture_of_the_recovery_manager-recovery_modules

/ lees,
http://narayana.io//docs/project/index.html#d0e2553

/ 13	. 

/ @ManyToMany(cascade=true)
/ TODO

/ 13	. 

/ we willen testen of we een Set kunnen persist,

/ Zo kan het NIET:

$ vi SetDaoTest.java

@RunWith(Arquillian.class)
public class SetDaoTest {

	@Inject 
	private CategoryDao categoryDao;

	@Deployment
	public static WebArchive createDeployment() {
		return ShrinkWrap.create(WebArchive.class)
				.addAsWebInfResource(new File("src/main/webapp","beans.xml"))
				.addAsResource("META-INF/persistence.xml")
				.addClasses(Category.class,CategoryDao.class,Item.class,Bid.class);
	}
// we moeten inderdaad de hele keten aan classes in de WAR opnemen: een Category heeft een Set van Item, en een Item heeft weer een Set van Bid	,
	
	@PersistenceContext(unitName = "arquillian-jpa-study2-persistence-unit")
	private EntityManager em;
	
	private Category clothing;
	private Category furniture;
	private Category red;
	private Category blue;
	

	@Before
	public  void init() {
		
		// Dit is OK,
		clothing=new Category("clothing");
		categoryDao.create(clothing);
		furniture=new Category("furniture");
		categoryDao.create(furniture);
		red=new Category("red");
		categoryDao.create(red);
		blue=new Category("blue");
		categoryDao.create(blue);
		
		// Dit kan NIET: moet binnen tx,
		Set<Category>categories=new HashSet<>();
		categories.add(clothing);
		categories.add(red);
		em.persist(categories);
		
/ javax.persistence.TransactionRequiredException: WFLYJPA0060: Transaction is required to perform this operation (either use a transaction or extended persistence context)

/ 1313	. 

/ we hebben dit opgelost	, maar we zien dat we een Set niet kunnen em.persist:

$ vi CategoryDao.java

@Stateless
public class CategoryDao {
	@PersistenceContext(unitName = "arquillian-jpa-study2-persistence-unit")
	private EntityManager em;

	public void create(Category entity) {
		em.persist(entity);
	}
	
	public void create(Set<Category>categories) {
		em.persist(categories);
	}

$ vi SetDaoTest.java

@RunWith(Arquillian.class)
public class SetDaoTest {

	
	@Inject 
	private CategoryDao categoryDao;

	@Deployment
	public static WebArchive createDeployment() {
		return ShrinkWrap.create(WebArchive.class)
				.addAsWebInfResource(new File("src/main/webapp","beans.xml"))
				.addAsResource("META-INF/persistence.xml")
				.addClasses(Category.class,CategoryDao.class,Item.class,Bid.class);
				
		
	}
	
	
	private Category clothing;
	private Category furniture;
	private Category red;
	private Category blue;
	
	
	
	@Before
	public  void init() {
		
		clothing=new Category("clothing");
//		categoryDao.create(clothing);
		furniture=new Category("furniture");
//		categoryDao.create(furniture);
		red=new Category("red");
//		categoryDao.create(red);
		blue=new Category("blue");
//		categoryDao.create(blue);
		
		Set<Category>categories=new HashSet<>();
		categories.add(clothing);
		categories.add(red);
		categoryDao.create(categories);
/ ERR	,
Caused by: java.lang.IllegalArgumentException: Unknown entity: java.util.HashSet
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.persist(AbstractEntityManagerImpl.java:1149)
        at org.jboss.as.jpa.container.AbstractEntityManager.persist(AbstractEntityManager.java:580)
        at org.arquillian.jpa.study2.dao.CategoryDao.create(CategoryDao.java:25)

/	7	. 

@ManyToMany

/ lees, 
https://vladmihalcea.com/the-best-way-to-use-the-manytomany-annotation-with-jpa-and-hibernate/		
https://www.baeldung.com/jpa-many-to-many
https://hellokoding.com/jpa-many-to-many-relationship-mapping-example-with-spring-boot-maven-and-mysql/

/ 7	 .

/ google,	
junit initialize once
/ lees,
https://stackoverflow.com/questions/12087959/junit-run-set-up-method-once

/ voor iedere @Test wordt er een nieuwe inst van de test class gemaakt, en wordt @Before called,

/ workspace-jbosstools-jee-oxygen,
/ proj abc-collection-study,

public class JUnitTest {
	
	private static boolean isInit=false;
	
	@Before
	public void init() {
		if(isInit==false) {
			System.out.println("isInit="+isInit);
			isInit=true;
		}
		System.out.println("in init, test class inst="+this);

	}
	@Test
	public void t1() {
		System.out.println("in t1, test class inst="+this);
	}
	@Test
	public void t2() {
		System.out.println("in t2, test class inst="+this);
	}
	
/ we zien,

Running set.JUnitTest
isInit=false
in init, test class inst=set.JUnitTest@5aaa6d82
in t1, test class inst=set.JUnitTest@5aaa6d82
in init, test class inst=set.JUnitTest@69222c14
in t2, test class inst=set.JUnitTest@69222c14
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 sec

/ 13	. 

/ we kunnen dit doen, maar de objs die je creates in init moeten static, want voor iedere test worden er een nieuwe test class inst create,

/ we kunnen het op 2 manieren doen	,


$ vi ManyToManyTest.java

public class ManyToManyTest {

	private static Item dress;
	private static Item chair;
	private static Category clothing;
	private static Category furniture;
	private static Category red;
	private static Category blue;

	private static boolean isInit = false;

	@BeforeClass
	public static void init() {
		
			System.out.println("isInit="+isInit);
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			furniture = new Category();
			furniture.setName("furniture");
			red = new Category();
			red.setName("red");
			blue = new Category();
			blue.setName("blue");

			dress = new Item();
			dress.setName("dress");
			dress.addCategory(clothing);
			dress.addCategory(red);

			chair = new Item();
			chair.addCategory(furniture);
			chair.addCategory(blue);
		

	}

	@Test
	public void sizeCollections() {
		Assert.assertTrue(dress.getCategories().contains(red));
		Assert.assertEquals(2, dress.getCategories().size());
		System.out.println("test class inst: "+this);
	}
	@Test
	public void sizeCollectionsAgain() {
		Assert.assertTrue(chair.getCategories().contains(blue));
		Assert.assertEquals(2, dress.getCategories().size());
		System.out.println("test class inst: "+this);

	}
}

/ of,

public class ManyToManyTest {

	private static Item dress;
	private static Item chair;
	private static Category clothing;
	private static Category furniture;
	private static Category red;
	private static Category blue;

	private static boolean isInit = false;

	@Before
	public void init() {
		if (isInit == false) {
			System.out.println("isInit="+isInit);
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			...
			
			


/ 13	. 

/ HIER HIER HIER

No marketplace entries found to handle maven-dependency-plugin:3.0.2:unpack in Eclipse.  Please see Help for more information.



/ 13	. 

/ we hebben een runconfig gemaakt,	
name: abc-collection-study-clean-test-debuggable
base dir: ${project_loc:abc-collection-study}
goals: -Dmaven.surefire.debug clean test

/ we hebben een debug gemaakt,
name: abc-collection-study-attach
project: abc-collection-study
host: localhost
port: 5005

/ TODO Hij valt niet in de b's
/ ook niet als je een JUnit debug config hebt	, via Debug As, Junit,





/ 13	. 

/ 13	. 

/ DEBUG TX

/ de 2de debugs wildfly, dus de test 	, en we moeten eerst  op de command line:
$ standalone.bat --debug
/ daarna in eclipse: 
aquillian-forge4-remote-wildfly	/ localhost 8787
/ daarna in forge:
$ build test

/ WH de proj met forge moeten we met build test run of met mvn clean test, maar niet in eclipse met Run as Junit 
/ rinse_and_repeat is niet met forge, en dus niet met chameleon, en die kan wel in eclipse met Run as,

/ 13	. 

/ dit doen we niet,

/ wat is in de run config arquillian-forge4-clean-test-debuggable:
-Dmaven.surefire.debug clean test

/ 1313	 .

/ lees op getting started	,
If you’re using a remote container, Debug As does not cause breakpoints to be activated. Instead, you needto start the container in debug mode and attach the debugger. That’s because the test is run in a different JVM than the original test runner.

/ we hebben create /d/Users/ervelden/misc_codebase/ en daarin copied uit /c/Users/ervelden/eclipse/workspace-jbosstools-jee-oxygen:
arquillian-getting_started
arquillian-jpa-study2
arquillian-rinse_and_repeat

/ we hebben een nieuwe workspace gemaakt in /d/Users/ervelden/workspaces: workspace-arquillian, 
/ open /c/Users/ervelden/eclipse/jbosstools-jee-oxygen/eclipse hierop, 

/ add in arquillian-getting_started/pom.xml de remote profile,	en edit arquillian.xml

/ maak in eclipse een remote application debug config, 
naam: arquillian-getting_started-attach
project: arquillian-getting_started
host: localhost
port: 8787

/ start 
$ standalone.bat --debug
/ set b, 
run debug config arquillian-getting_started
/ doe in forge: build test
/ hij valt in b,

@RunWith(Arquillian.class)
public class GreeterTest {
...
	@Test
	public void shouldCreateGreeting() {
		String s=greeter.createGreeting("Earthling");

$ vi pom.xml
	
		<profile>
			<id>wildfly-remote</id>
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
			<dependencyManagement>
				<dependencies>
					<dependency>
						<groupId>org.wildfly.arquillian</groupId>
						<artifactId>wildfly-arquillian-container-remote</artifactId>
						<version>2.1.0.Final</version>
						<scope>test</scope>
					</dependency>
					<dependency>
						<groupId>org.jboss.arquillian.protocol</groupId>
						<artifactId>arquillian-protocol-servlet</artifactId>
						<version>1.1.13.Final</version>
						<scope>test</scope>
					</dependency>
				</dependencies>
			</dependencyManagement>
			<dependencies>
				<dependency>
					<groupId>org.wildfly.arquillian</groupId>
					<artifactId>wildfly-arquillian-container-remote</artifactId>
				</dependency>
				<dependency>
					<groupId>org.jboss.arquillian.protocol</groupId>
					<artifactId>arquillian-protocol-servlet</artifactId>
				</dependency>
			</dependencies>
		</profile>

$ vi arquillian.xml

<arquillian	...>
	<engine>
		<property name="deploymentExportPath">target/deployments</property>
	</engine>
	<defaultProtocol type="Servlet 3.0"></defaultProtocol>
</arquillian>

/ 7	 

/ debug unit test,

/ we hebben project abc-collection-study, standalone, niet deployed in wildfly,
/ deze draait in dezelfde jvm als ... TODO
/ we kunnen right click, Debug as, JUnit 
/ maar we kunnen ook een run config maken,
name: abc-collection-study
base dir: ${project_loc:abc-collection-study}
goals: -Dmaven.surefire.debug clean test
/ en maak de debug config 'Remote Java application'
name : abc-collection-study-attach
project: abc-collection-study
host: localhost
port: 5005
/ start eerst de run config abc-collection-study
/ deze wacht, op port 5005	,
/ run dan de debug config 'abc-collection-study-attach	', 
/ je valt in een b,

/ Einde DEBUG TX

/ ARQUILLIAN-JPA-STUDY2

/ we debug BidDaoTest,

/ 7	. 

/ 13	. 

/c
/s
BidDaoTest.init() line: 136	
			itemDao.create(dress);
			
/ na dit command heeft dress een id, en de 2 cat ook,
this	BidDaoTest  (id=348)	
	dress	Item  (id=372)	
		bids	PersistentSet  (id=434)	
		categories	PersistentSet  (id=438)	
			[0]	Category  (id=367)	
				id	Long  (id=446)				2
				items	PersistentSet  (id=447)	
					[0]	Item  (id=372)				/= dress
				name	"clothing" (id=448)	
				version	0	
			[1]	Category  (id=369)	
				id	Long  (id=449)				3
				items	PersistentSet  (id=450)	
					[0]	Item  (id=372)				/= dress
				name	"red" (id=451)	
				version	0	
		id	Long  (id=439)			1
		name	"dress" (id=442)	
		version	0	

/ deze is nog transient	,
furniture	Category  (id=368)	
	id	null	
	items	HashSet<E>  (id=671)	/ []	
	name	"furniture" (id=672)	
	version	0	

/ de txs zijn al afgesloten,

test=> select*from item_category;
 item_id | category_id
---------+-------------
       1 |           2
       1 |           3
(2 rows)


test=> select*from item;
 id | name  | version
----+-------+---------
  1 | dress |       0
(1 row)


test=> select*from category;
 id |   name   | version
----+----------+---------
  2 | clothing |       0
  3 | red      |       0
(2 rows)

/ persistent in H. betekent WH dat ze in de persistence context zitten; ze hebben dan WH een id, 
/ maar ze hoeven nog niet zijn flush naar de db, dat gebeurt pas als de tx commits, 
/ TODO
/ maar hier zijn de txs al commit,

/ 13	 .

			chair.addCategory(blue);
/ chair heeft id=null, en heeft 2 cats, die ook id=null hebben, 

			itemDao.create(chair);
/ nu hebben chair en de 2 cats een id,

/ 13	. 

/ we geven cont, we vallen in de 1ste test,

	@Test
	public void should_be_deployed() {
		Assert.assertNotNull(bidDao);
bidDao	BidDao$Proxy$_$$_Weld$EnterpriseProxy$  (id=373)	

/ 13	 

/c,
BidDaoTest.size_collections() line: 165	

/ 7	. 

/c
/s,
ItemDao.create(Item) line: 24
/cb,
BidDaoTest.init() line: 134	
		em.persist(item);
this	org.arquillian.jpa.study2.dao.ItemDao  (id=508)	
	em	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=526)	
/c
/s,
ItemDao.create(Item) line: 24	
/cb,
BidDaoTest.init() line: 140	
this	org.arquillian.jpa.study2.dao.ItemDao  (id=508)	
	em	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=526)	

/c,
/s,
BidDaoTest.should_be_deployed() line: 157	

/c,
/s,
BidDaoTest.size_collections() line: 176	
		for(Item item:red.getItems()) {
			Assert.assertTrue(red.getItems().contains(item));		/ deze is false, waarom?
/s,
/ we zien Edit source lookup path,
/ Add...
/ kies External archive,
hibernate-core-5.0.10.Final-sources
/ OK,
/s,
PersistentSet.contains(Object) line: 154	
		final Boolean exists = readElementExistence( object );
null
		return exists == null
				? set.contains( object )
				: exists;
/s,
HashSet<E>.contains(Object) line: 203	
        return map.containsKey(o);
/s,
HashMap<K,V>.containsKey(Object) line: 595	
        return getNode(hash(key), key) != null;
/s,
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
/t,
/s,
HashMap<K,V>.getNode(int, Object) line: 568	
hash=32

/ 7	. 

/ lees,
https://thoughts-on-java.org/ultimate-guide-to-implementing-equals-and-hashcode-with-hibernate/

https://thoughts-on-java.org/naturalid-good-way-persist-natural-ids-hibernate/
/ we hebben @NaturalId niet echt nodig,

/ als we dat wel hebben, kunnen we in de pom van arquillian-jpa-study2's:
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.0.1.Final</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>
/ nu kunnen we,

import org.hibernate.annotations.NaturalId;
class Item{ 
		@NaturalId
		private String name

/ 7	. 
 

/ workspace-arquillian
/ proj arquillian-jpa-study2

/ bij many to many is er een active en een passieve kant,
/ we moeten eerst de passive kant save, en als laatste de active kant, anders wordt de relatietabel niet geschreven	,

/ we doen in A, B zonder cascade persist, en in C met cascade persist,
/ in A is category de actieve kant, in B en C item,

/ 13	.  

/ A	,

@Entity
public class Item implements Serializable {
	@ManyToMany(mappedBy="items")
	private Set<Category>categories=new HashSet<>();
}

@Entity
public class Category implements Serializable {
	@ManyToMany
	private Set<Item> items = new HashSet<>();
	
	public void addItem(Item item) {
		items.add(item);
		item.getCategories().add(this);
	}
	public void removeItem(Item item) {
		items.remove(item);
		item.getCategories().remove(this);
	}
}
	
/ 1313	. 

/ B,

@Entity
public class Item implements Serializable {
	@ManyToMany
	private Set<Category>categories=new HashSet<>();
	
	public void addCategory(Category category) {
		categories.add(category);
		category.getItems().add(this);
	}
	public void removeCategory(Category category) {
		categories.remove(category);
		category.getItems().remove(this);
	}
}
	
@Entity
public class Category implements Serializable {
	@ManyToMany(mappedBy="categories")
	private Set<Item> items = new HashSet<>();
}	

/ C,

@Entity
public class Category implements Serializable {
	@ManyToMany(mappedBy="categories")
	private Set<Item> items = new HashSet<>();

@Entity
public class Item implements Serializable {
	@ManyToMany(cascade=CascadeType.PERSIST)
	private Set<Category>categories=new HashSet<>();
	

/ A,

@RunWith(Arquillian.class)
public class ItemCategoryDaoTest {
	@Before
	public void init2a() {
		if (isInit == false) {
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			furniture = new Category();
			furniture.setName("furniture");
			red = new Category();
			red.setName("red");
			blue = new Category();
			blue.setName("blue");

			dress = new Item();
			dress.setName("dress");

			chair = new Item();
			chair.setName("chair");
			
			
			clothing.addItem(dress);
			red.addItem(dress);
			furniture.addItem(chair);
			blue.addItem(chair);
// of,		
//			dress.addCategory(clothing);
//			dress.addCategory(red);
//			chair.addCategory(furniture);
//			chair.addCategory(blue);
			
			itemDao.create(dress);
			itemDao.create(chair);
			
			categoryDao.create(clothing);
			categoryDao.create(furniture);
			categoryDao.create(red);
			categoryDao.create(blue);

			

		}

	}

/ B,

@RunWith(Arquillian.class)
public class ItemCategoryDaoTest {
	@Before
	public void initb() {
		if (isInit == false) {
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			furniture = new Category();
			furniture.setName("furniture");
			red = new Category();
			red.setName("red");
			blue = new Category();
			blue.setName("blue");

			dress = new Item();
			dress.setName("dress");
			chair = new Item();
			chair.setName("chair");
			
			dress.addCategory(clothing);
			dress.addCategory(red);
			chair.addCategory(furniture);
			chair.addCategory(blue);
// of,
//			clothing.addItem(dress);
//			red.addItem(dress);
//			furniture.addItem(chair);
//			blue.addItem(chair);
			
			categoryDao.create(clothing);
			categoryDao.create(furniture);
			categoryDao.create(red);
			categoryDao.create(blue);
			
			itemDao.create(dress);
			itemDao.create(chair);

		}

	}
	
/ C,

@RunWith(Arquillian.class)
public class ItemCategoryDaoTest {
	 @Before
	public void initc() {
		if (isInit == false) {
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			furniture = new Category();
			furniture.setName("furniture");
			red = new Category();
			red.setName("red");
			blue = new Category();
			blue.setName("blue");

			dress = new Item();
			dress.setName("dress");
			chair = new Item();
			chair.setName("chair");
			
			dress.addCategory(clothing);
			dress.addCategory(red);
			chair.addCategory(furniture);
			chair.addCategory(blue);
			
			itemDao.create(dress);
			itemDao.create(chair);
		}
	}
	


	


/ 13	. 

/ met cascade persist

/ de @ManyToMany(cascade=CascadeType.PERSIST en de @ManyToMany(mappedBy kunnen maar aan 1 kant staan, 
/ de @ManyToMany(cascade=CascadeType.PERSIST staat aan de kant die we persist,

class DaoTest{

	@Before
	public void init() {
		if (isInit == false) {
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			furniture = new Category();
			furniture.setName("furniture");
			red = new Category();
			red.setName("red");
			blue = new Category();
			blue.setName("blue");

			dress = new Item();
			dress.setName("dress");
			dress.addCategory(clothing);
			dress.addCategory(red);
			itemDao.create(dress);

			chair = new Item();
			chair.setName("chair");
			chair.addCategory(furniture);
			chair.addCategory(blue);
			itemDao.create(chair);
		}
	}
	
class Item{

	@ManyToMany(cascade=CascadeType.PERSIST)
	@JoinTable(joinColumns = { @JoinColumn(name = "item_id") }, inverseJoinColumns = {
			@JoinColumn(name = "category_id") })
	private Set<Category>categories=new HashSet<>();
	
class Category{
	@ManyToMany(mappedBy="categories")
	private Set<Item> items = new HashSet<>();
	
/ 13	. 

/ zonder cascade persist,

/ de @ManyToMany(cascade=CascadeType.PERSIST en de @ManyToMany(mappedBy kunnen aan beide kanten staan, want beide kanten worden persist,

class DaoTest{

	@Before
	public void init() {
		if (isInit == false) {
			isInit = true;

			clothing = new Category();
			clothing.setName("clothing");
			furniture = new Category();
			furniture.setName("furniture");
			red = new Category();
			red.setName("red");
			blue = new Category();
			blue.setName("blue");

			categoryDao.create(clothing);
			categoryDao.create(furniture);
			categoryDao.create(red);
			categoryDao.create(blue);

			dress = new Item();
			dress.setName("dress");
			dress.addCategory(clothing);
			dress.addCategory(red);
			itemDao.create(dress);

			chair = new Item();
			chair.setName("chair");
			chair.addCategory(furniture);
			chair.addCategory(blue);
			itemDao.create(chair);

		}

	}
	
/ of,
	
@Entity
class Item{
	@ManyToMany
	@JoinTable(joinColumns = { @JoinColumn(name = "item_id") }, inverseJoinColumns = {
		@JoinColumn(name = "category_id") })
	private Set<Category>categories=new HashSet<>();

@Entity
public class Category implements Serializable {
	@ManyToMany(mappedBy="categories")
	private Set<Item> items = new HashSet<>();
	
/ of,

@Entity
class Item implements Serializable {	
	@ManyToMany(mappedBy="items")
	private Set<Category>categories=new HashSet<>();

@Entity
public class Category implements Serializable {	
	@ManyToMany
	@JoinTable(joinColumns = { @JoinColumn(name = "category_id") }, inverseJoinColumns = {
			@JoinColumn(name = "item_id") })
	private Set<Item> items = new HashSet<>();








/ Einde ARQUILLIAN-JPA-STUDY2

/ DEBUG TX

/ 7	. 

/ hier zijn alle source jars,
/ d:\Users\ervelden\java\wildfly-source-jars


/ 7	. 

/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 579	
/cb,
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21

package org.jboss.as.jpa.container;

import static org.jboss.as.jpa.messages.JpaLogger.ROOT_LOGGER;

public abstract class AbstractEntityManager implements EntityManager {

  private final transient boolean isTraceEnabled = ROOT_LOGGER.isTraceEnabled();

    protected abstract EntityManager getEntityManager();
	

    public void persist(Object entity) {
        long start = 0;
        if (isTraceEnabled)
            start = System.currentTimeMillis();
        try {
            transactionIsRequired();
            getEntityManager().persist(entity);
        } finally {
            if (isTraceEnabled) {
                long elapsed = System.currentTimeMillis() - start;
                ROOT_LOGGER.tracef("persist entityClass '%s' took %dms", entity.getClass().getName(), elapsed);
            }
        }
    }
/ maak logging voor mekaar	,

/ lees,
https://thoughts-on-java.org/hibernate-logging-guide/
https://docs.jboss.org/author/display/WFLY10/JPA+Reference+Guide#JPAReferenceGuide-Troubleshooting

https://docs.wildfly.org/16/Admin_Guide.html
/subsystem=logging/root-logger=ROOT:change-root-log-level(level=WARN)
/ TODO set op TRACE

/ 7	.

/ in mijn test doen we,
			categoryDao.create(clothing);
/ er wordt dan een tx gemaakt, en we komen in 
@Stateless
public class CategoryDao {
	@PersistenceContext(unitName = "arquillian-jpa-study2-persistence-unit")
	private EntityManager em;
	public void create(Category entity) {
		em.persist(entity);						<-
	}

/ in meer detail,

/s,
org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261	
			categoryDao.create(clothing);
...
/s,
org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
                case REQUIRED:
                    return required(invocation, component, timeoutInSeconds);
component=StatelessSessionComponent CategoryDao
/s,
org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
        final Transaction tx = tm.getTransaction();
        if (tx == null) {
/j,
            return invokeInOurTx(invocation, tm, component);
/s,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e status: ActionStatus.RUNNING >
            try {
                return invocation.proceed();
...
/s,
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
		
/ 7	. 

/c,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
		final BasicAction current = BasicAction.Current();
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
/cb,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52		/ WH base class tx
		return TransactionImple.getTransaction();
/cb,	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109
   /**
     * Get the transaction associated with the thread.
    public Transaction getTransaction()
        return transactionManager.getTransaction() ;
/cb,	 
org.jboss.as.jpa.transaction.TransactionUtil.getTransaction(javax.transaction.TransactionManager) line: 93	
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 56	
org.jboss.as.jpa.container.TransactionScopedEntityManager.isInTx() line: 105	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).transactionIsRequired() line: 876	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 579	
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	

/ 7	. 

/ je wilt een tx scoped em hebben,


/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            transactionIsRequired();
/d,
            getEntityManager().persist(entity);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
        isInTx = TransactionUtil.isInTx(transactionManager);

        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
...
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getEntityManagerInTransactionRegistry(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 116	
        return (EntityManager)tsr.getResource(scopedPuName);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106	
/**
 * Most of this implementation delegates down to the underlying transactions implementation to provide the services of the
 * TransactionSynchronizationRegistry. The one area it modifies is the registration of the interposed Synchronizations. The
 * reason this implementation needs to differ is because the JCA Synchronization and JPA Synchronizations are both specified as
 * Interposed however there are defined ordering requirements between them both.
 *
 * The current implementation orders JCA relative to all other Synchronizations. For beforeCompletion, it would be possible to
 * restrict this to the one case where JCA is ordered before JPA, however it is possible that other interposed Synchronizations
 * would require the services of JCA and as such if the JCA is allowed to execute delistResource during beforeCompletion as
 * mandated in JCA spec the behaviour of those subsequent interactions would be broken. For afterCompletion the JCA
 * synchronizations are called last as that allows JCA to detect connection leaks from frameworks that have not closed the JCA
 * managed resources. This is described in (for example)
 * http://docs.oracle.com/javaee/5/api/javax/transaction/TransactionSynchronizationRegistry
 * .html#registerInterposedSynchronization(javax.transaction.Synchronization) where it says that during afterCompletion
 * "Resources can be closed but no transactional work can be performed with them".
 *
 * One implication of this approach is that if the underlying transactions implementation has special handling for various types
 * of Synchronization that can also implement other interfaces (i.e. if interposedSync instanceof OtherInterface) these
 * behaviours cannot take effect as the underlying implementation will never directly see the actual Synchronizations.
 */
public class TransactionSynchronizationRegistryWrapper implements TransactionSynchronizationRegistry {
    @Override
    public Object getResource(Object key) throws IllegalStateException {
        return delegate.getResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 116	
        if (jtaLogger.logger.isTraceEnabled()) {
/j,
        return transactionImple.getTxLocalResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);
{}
/ key=8fad5696-b932-4054-a142-f024a75c4efd.war#arquillian-jpa-study2-persistence-unit


/ 7	. 

/ jta logging,

/ lees,
https://stackoverflow.com/questions/24903118/enable-useful-transaction-logging-in-jboss-7-1-x

<logger category="com.arjuna.ats.jta">
    <level name="TRACE"/>
</logger>
<logger category="com.arjuna">
    <level name="WARN"/>
</logger>
/ TODO LOGGER
/ we hebben "com.arjuna"	, 
/ TODO Misschien teveel?

/ 7	. 

/ LEES,
/ tx bound to thread

/ lees,
https://developer.jboss.org/thread/279662

it depends on what you want to achieve. Do the two methods (starttx and the account) run on two different JVMs? Do I understand correctly you want to start a JTA transaction on one JVM (let's say a microservice) and you want the other JVM would join the same transaction? The JTA transactions are associated with one thread in one JVM. If you want to get multiple JVMs to run with one transaction you need to propagate context over the remote call. In this case you expect the transaction context is propagated over HTTP REST calls. Narayana provides for the propagation the subproject REST-AT (atomic transactions for REST) and you need to configure it to your project for propagation to start working. Please take a look at the Narayana quickstart quickstart/rts/at at master · jbosstm/quickstart · GitHub for this purpose.

/ 7	. 

/ hibernate logging,

/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 157	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
        if (entityManager == null) {
/j,
           entityManager = createEntityManager(emf, properties, synchronizationType);
...
/s,
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1317

package org.hibernate.internal;
public final class SessionFactoryImpl implements SessionFactoryImplementor {
	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( SessionFactoryImpl.class );
	public SessionFactoryImpl(final MetadataImplementor metadata, SessionFactoryOptions options) {
		LOG.debug( "Building session factory" );
...
	static class SessionBuilderImpl implements SessionBuilderImplementor {
		private static final Logger log = CoreLogging.logger( SessionBuilderImpl.class );
		@Override
		public Session openSession() {
			log.tracef( "Opening Hibernate Session.  tenant=%s, owner=%s", tenantIdentifier, sessionOwner );
/ log=org.jboss.logging.JBossLogManagerLogger@c58de09
/ LOG= 'n CoreMessageLogger_$logger
/ TODO LOGGER

/ lees,
https://thoughts-on-java.org/hibernate-logging-guide/

The better way to activate the logging of executed SQL statements is to set the log level of the org.hibernate.SQL category to DEBUG (or the corresponding log level of your log framework). Hibernate will write the SQL statements without any information about the values bound to the JDBC parameters or extracted from the query result. If you also want to get this information, you have to set the log level of org.hibernate.type.descriptor.sql to DEBUG (see the development recommendation for an example).

/ lees,
https://medium.com/@scadge/how-to-enable-hibernate-logging-dc11545efd3d

...
/s,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 278	
			this.currentHibernateTransaction = getTransaction();
/s,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 315	
			this.currentHibernateTransaction = new TransactionImpl( getTransactionCoordinator() );
/s,
org.hibernate.engine.transaction.internal.TransactionImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinator) line: 36	
/ TODO Wat is dit voor een ding, vergl met arjuna's TransactionImple?
/t,
/s,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 315	
			this.currentHibernateTransaction = new TransactionImpl( getTransactionCoordinator() );
/d,
		getTransactionCoordinator().pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 132	
		if ( synchronizationRegistered ) {
/j,
			return;
		}
...
/ anders,
		joinJtaTransaction();
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 347	
...
		if ( TRACE_ENABLED ) {
/n,
			LOG.tracef( "Opened session at timestamp: %s", timestamp );
		}
/ TODO LOGGER
LOG is een org.hibernate.internal.CoreMessageLogger_$logger@67b59e01
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 158	
            entityManager = createEntityManager(emf, properties, synchronizationType);
/d,
/ deze moeten we te pakken zien te krijgen straks,
entityManager	EntityManagerImpl  (id=4545)	
	session	SessionImpl  (id=4610)	
		persistenceContext	StatefulPersistenceContext  (id=4621)	
			entityEntryContext	EntityEntryContext  (id=4631)	

            if (ROOT_LOGGER.isDebugEnabled()) {
                ROOT_LOGGER.debugf("%s: created entity manager session %s", TransactionUtil.getEntityManagerDetails(entityManager, scopedPuName),
                        TransactionUtil.getTransaction(transactionManager).toString());
            }
/ in org.jboss.as.jpa.container.TransactionScopedEntityManager,
import static org.jboss.as.jpa.messages.JpaLogger.ROOT_LOGGER;
/ deze hebben we, WH omdat we org.jboss.as.jpa hebben in jboss-cli,

            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
            TransactionUtil.putEntityManagerInTransactionRegistry(scopedPuName, entityManager, transactionSynchronizationRegistry);
/s,
    /**
     * Save the specified EntityManager in the local threads active transaction.  The TransactionSynchronizationRegistry
     * will clear the reference to the EntityManager when the transaction completes.
     *
org.jboss.as.jpa.transaction.TransactionUtil.putEntityManagerInTransactionRegistry(java.lang.String, javax.persistence.EntityManager, javax.transaction.TransactionSynchronizationRegistry) line: 127	
/=
    public static void putEntityManagerInTransactionRegistry(String scopedPuName, EntityManager entityManager, TransactionSynchronizationRegistry tsr) {
        tsr.putResource(scopedPuName, entityManager);
    }
/ Intermezzo

    /**
     * Get current persistence context.  Only call while a transaction is active in the current thread.
     *
     * @param puScopedName
     * @return
     */
    public static EntityManager getTransactionScopedEntityManager(String puScopedName, TransactionSynchronizationRegistry tsr) {
        return getEntityManagerInTransactionRegistry(puScopedName, tsr);
    }

    private static EntityManager getEntityManagerInTransactionRegistry(String scopedPuName, TransactionSynchronizationRegistry tsr) {
        return (EntityManager)tsr.getResource(scopedPuName);
    }


/ Einde Intermezzo

/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 109	
        if (jtaLogger.logger.isTraceEnabled()) {
/j,
            jtaLogger.logger.trace("TransactionSynchronizationRegistryImple.putResource");
        }
...
        TransactionImple transactionImple = getTransactionImple();
        transactionImple.putTxLocalResource(key, value);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 109	
        TransactionImple transactionImple = getTransactionImple();
...
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
/=
	public static final TransactionImple getTransaction()
/ dit is een static method, tx zal de Transaction zijn (TransactionImple is een Transcation),
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
/s,
com.arjuna.ats.arjuna.coordinator.BasicAction.Current() line: 1256	
        return ThreadActionData.currentAction();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 56	
/=
public class ThreadActionData
	private static ThreadLocal<Deque<BasicAction>> _threadList = new ThreadLocal<Deque<BasicAction>>();

	public static BasicAction currentAction ()
	{
...
		Deque<BasicAction> txs = _threadList.get();
txs	ArrayDeque<E>  (id=5124)	
	elements	Object[16]  (id=5125)	
		[15]	AtomicAction  (id=1906)	
			_childThreads	Hashtable<K,V>  (id=5133)	{TSThread:6b=Thread[default task-72,5,main]}
/ klopt, dat is de thread waar alles in gebeurt,
			objectUid	Uid  (id=1908)	0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e

		if (txs != null && !txs.isEmpty())
		{
			return txs.peekFirst();
...
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 110	
        TransactionImple transactionImple = getTransactionImple();
/d,
        transactionImple.putTxLocalResource(key, value);
key	"8fad5696-b932-4054-a142-f024a75c4efd.war#arquillian-jpa-study2-persistence-unit" (id=1912)	
value	EntityManagerImpl  (id=4545)	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTxLocalResource(java.lang.Object, java.lang.Object) line: 1096	
		_txLocalResources.put(key, value);
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/pd,
...
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 73	
		final SessionImplementor source = event.getSession();
		final Object object = event.getObject();
source	SessionImpl  (id=4610)	
object	Category  (id=538)	
	id	null	
	items	HashSet<E>  (id=1891)	
		map	HashMap<K,V>  (id=5205)	
{Item =java.lang.Object@6e3e5f0e}
	name	"clothing" (id=1892)	
/ Wat gaat .persist met het Item doen?

		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
null
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
TRANSIENT, want id=null,		
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).getEntityState(java.lang.Object, java.lang.String, org.hibernate.engine.spi.EntityEntry, org.hibernate.engine.spi.SessionImplementor) line: 488	
		final boolean traceEnabled = LOG.isTraceEnabled();
false
this	JpaPersistEventListener  (id=5188)	
	log	JBossLogManagerLogger  (id=5190)	
	LOG	CoreMessageLogger_$logger  (id=5191)	org.hibernate.internal.CoreMessageLogger_$logger@7b658aa3
	LOG	CoreMessageLogger_$logger  (id=5192)	
	log	JBossLogManagerLogger  (id=5193)	
/ TODO LOGGER
/ Geef LOG trace enabled,

		if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source ) ) {

/t,
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 185	
		LOG.trace( "Saving transient instance" );
/ TODO LOGGING check of deze in de log komt,

/c,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
select nextval ('hibernate_sequence')
/cb,	
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/cb,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/cb,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	

/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).<init>(org.hibernate.engine.jdbc.internal.StatementPreparerImpl, java.lang.String) line: 158	
/=
	private abstract class StatementPreparationTemplate {
		protected final String sql;

		protected StatementPreparationTemplate(String incomingSql) {
			final String inspectedSql = jdbcCoordinator.getJdbcSessionOwner()
					.getJdbcSessionContext()
					.getStatementInspector()
					.inspect( incomingSql );		/ doet niets, TODO
			this.sql = inspectedSql == null ? incomingSql : inspectedSql;
/ hier gaat hij de sql inspect, see cursus security,
/ INSPECT SQL
/t,
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
					preparedStatement = doPrepare();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 85	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )			
						: connection().prepareStatement( sql );	<-
/s,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl@62df5cf9
/cb,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	

/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 398	
      return super.getManagedConnection(trackByTransaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
         return pool.getConnection(transaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getManagedConnectionPool(java.lang.Object, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 295	
         ManagedConnectionPool mcp = mcpPools.get(key);
mpc={false=SemaphoreConcurrentLinkedQueueManagedConnectionPool@15a2d2d7[pool=PostgreSQLDS]}
key=false
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 584	
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
/d,
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/ deze zie je bij JPA en JCA 
/ TODO
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;

/ 13	. 


/ we komen via jdbc in jca,
/c,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);
/cb,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126
        return transactionImple.getTxLocalResource(key);
/cb,	
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 659	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 593	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429
/cb, (1)	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/cb,	
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94	
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21
	
/ in meer detail,
/ we zijn dus in,
/ s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090
		return _txLocalResources.get(key);
	
this	TransactionImple  (id=1746)	
	_transactions	ConcurrentHashMap<K,V>  (id=1751)
{0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e=TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e status: ActionStatus.RUNNING >}	
	_theTransaction	AtomicAction  (id=1906)	
BasicAction: 0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e status: ActionStatus.RUNNING
	_txLocalResources	Collections$SynchronizedMap<K,V>  (id=1937)	
{
 8fad5696-b932-4054-a142-f024a75c4efd.war#arquillian-jpa-study2-persistence-unit=org.hibernate.jpa.internal.EntityManagerImpl@6718656,
 SemaphoreConcurrentLinkedQueueManagedConnectionPool@15a2d2d7[pool=PostgreSQLDS]=org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@5d1a99dc[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@7f9e35b6 connection handles=0 lastReturned=1555846503672 lastValidated=1555846503672 lastCheckedOut=1555846503672 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@da8ad16 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@15a2d2d7[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@998be1d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@7f9e35b6 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=null], 
 
 org.jboss.jca.core.connectionmanager.transaction.LockKey@2a=java.util.concurrent.locks.ReentrantLock@ef8b4a0[Locked by thread default task-72], 
 
 __TX_LISTENERS=[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@181ab6a3]}
			
}
/ hij vraagt hier om de TxConnectionListener	,


/ 1313	. 



/ lees,
https://www.baeldung.com/java-threadlocal

/ hierboven bij 
/cb, (1) 
/ gaan we verder, bij cb, (2)

/c,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 59
/cb,		
com.arjuna.ats.arjuna.coordinator.BasicAction.Current() line: 1256	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
org.jboss.jca.core.tx.jbossts.TransactionManagerDelegator.getTransaction() line: 85	
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 286	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 553	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).reconnectManagedConnection(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 928	
/ cb, (2)
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	

/ in meer detail,
/s,
com.arjuna.ats.arjuna.coordinator.BasicAction.Current() line: 1256	
/**
 * BasicAction does most of the work of an atomic action, but does not manage
 * thread scoping. This is the responsibility of any derived classes.
 *
public class BasicAction extends StateManager
    /**
     * @return the thread's notion of the current transaction.
     */

    public static BasicAction Current ()
    {
        return ThreadActionData.currentAction();
    }
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 59
/=
/**
 * This class maintains a mapping between a thread and its notion of the current
 * transaction. Essentially this is a stack of transactions.
 * 
public class ThreadActionData
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private static ThreadLocal<Deque<BasicAction>> _threadList = new ThreadLocal<Deque<BasicAction>>();

		Deque<BasicAction> txs = _threadList.get();
[BasicAction: 0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e status: ActionStatus.RUNNING]

		if (txs != null && !txs.isEmpty())
		{
			return txs.peekFirst();
		}
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1060	
		final BasicAction current = BasicAction.Current();
/ is thread local,
		if (current != null)
		{
			final Uid txid = current.get_uid();
0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e	, in feite ook thread local,
			tx = (TransactionImple) _transactions.get(txid);
/ in feite dan ook thread local,
			if (tx == null)
				tx = new TransactionImple(current);
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 344	
            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());
/s,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.getRegisteredSynchronizer(javax.transaction.Transaction, org.jboss.jca.core.spi.transaction.TransactionIntegration) line: 198
/=	
/**
 * Organizes transaction synchronization done by JCA.
 * 
 * <p> 
 * This class exists to make sure all Tx synchronizations
 * are invoked before the cached connection manager closes any
 * closed connections.
 *
public class TransactionSynchronizer implements Synchronization
   public static TransactionSynchronizer getRegisteredSynchronizer(Transaction tx, 
                                                                   TransactionIntegration ti)
throws SystemException, RollbackException
      Object id = ti.getIdentifier(tx);
      Record record = records.get(id);
      return record.getTransactionSynchronizer();
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 357	
            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());
        
         // First time through, create a transaction synchronization
         if (transactionSynchronization == null)
         {
            TransactionSynchronization synchronization = new TransactionSynchronization(threadTx, isTrackByTx());
            synchronizer.addUnenlisted(synchronization);
			transactionSynchronization = synchronization;
synchronizer=org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer@22add46a
synchronization=org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization@1765488939{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=false cancel=false}
           
      // Perform the enlistment(s)
      List<Synchronization> unenlisted = synchronizer.getUnenlisted();
	  ...
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986	
            XAResource resource = getXAResource();
XAResourceWrapperImpl@998be1d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@7f9e35b6 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]
/ dus de resource is de connection naar pg	,

            if (!currentTx.enlistResource(resource)) 	/ currentTx is jta tx, resource heeft xid=jta tx id & branch tx id,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
		return enlistResource(xaRes, null);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 430	
		if (jtaLogger.logger.isTraceEnabled()) {
/j,
            jtaLogger.logger.trace("TransactionImple.enlistResource ( " + xaRes + " )");
/ TODO LOGGING WH is jtaLogger een class,

				xid = createXid(branchRequired, theModifier, xaRes);
branchRequired=true
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1529	
        if(branch) {
/j,
            if(_xaResourceRecordWrappingPlugin != null) {
                eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);
/s,
com.arjuna.ats.internal.jbossatx.jta.XAResourceRecordWrappingPluginImpl.getEISName(javax.transaction.xa.XAResource) line: 70	
			String jndiName = ((XAResourceWrapper) xaResource).getJndiName();
java:jboss/datasources/PostgreSQLDS
			Integer key = nameToKey.get(jndiName);
2
nameToKey={java:jboss/datasources/RemoteExampleDS=3, java:jboss/datasources/ExampleDS=1, java:jboss/datasources/PostgreSQLDS=2}
	return key;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1535	
                 eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);
2
		Xid xid = new XidImple(_theTransaction.get_uid(), branch, eisName);
_theTransaction.get_uid()=0:ffffc0a82b5e:39439cb1:5ca6e6b0:a35e
/s,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 60	
        if (branch)
            return getXid(uid, new Uid(), FORMAT_ID, eisName);

/ de conn met pg is de branch, wel logisch	,
/ TODO Afmaken,



		
		
		
		
	

/ 7	. 

/ we hadden hibernate-core als maven dep opgenomen voor @NaturalId,
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.0.1.Final</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>

/ we zijn aan het debug, en we doen een F3 op CoreLogging, dan zien we,
Change attached source...
C:/Users/ervelden/.m2/repository/org/hibernate/hibernate-core/5.0.1.Final/hibernate-core-5.0.1.Final-sources.jar
/ deze is er, maar toch ...
/ TODO

/ vaker krijgen we:
Edit source lookup path,
Add...
kies External archive,
hibernate-core-5.0.10.Final-sources

/ dus je hebt (als mvn dep, maar vindt sources niet),
Change attached source...
/ en (WH als mvn dep er niet is),
Edit source lookup path,

$ find -name "*.jar" | grep hibernate-core
./modules/system/layers/base/org/hibernate/main/hibernate-core-5.0.10.Final.jar

/ die 5.0.1.Final was fout, 
/ maar halen de dep weg,
/ TODO (probeer met 5.0.10.Final, en kijk of CoreLogging F3 nog fout geeft),

/ 7	 .

hibernate-core-5.0.10.Final				v
hibernate-entity-manager-5.0.10.Final	v
ironjacamar-core-api-1.3.4.Final			v
ironjacamar-core-impl-1.3.4.Final			v
ironjacamar-jdbc-1.3.4.Final				v
jboss-invocation-1.4.1.Final
jboss-msc-1.2.6.Final
jboss-transaction-spi-7.3.0.Final			v
jipijapa-hibernate5-10.1.0.Final-sources
narayana-jts-idlj-5.3.3.Final-sources		v
narayana-jts-integration-5.3.3.Final-sources.jar	v
postgresql-9.4-1202-jdbc42-sources			v
weld-core-impl-2.3.5.Final-sources
wildfly-connector-10.1.0.Final-sources		v
wildfly-ee-10.1.0.Final-sources				v
wildfly-ejb3-10.1.0.Final-sources			v
wildfly-elytron-1.0.2.Final-sources
wildfly-jpa-10.1.0.Final-sources			v
wildfly-transactions-10.1.0.Final-sources		v
wildfly-weld-10.1.0.Final-sources				v

/ 7	. 

/ we hebben niet scope provided moeten maken, anders wordt de src niet opgepakt, 

		<dependency>
			<groupId>org.wildfly</groupId>
			<artifactId>wildfly-ejb3</artifactId>
			<version>10.1.0.Final</version>
			<scope>provided</scope>
		</dependency>
		
/ hier zit class CMTTxInterceptor in,

/ 7	.

Thread [default task-1] (Suspended)	
	owns: com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=19323)	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).actionInitialise(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 3561	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Begin(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 1391	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).start(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 76	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).start() line: 65	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 116	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 104	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 98	
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).begin() line: 78	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	...
	org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261	
	...
	
$ vi TwoPhaseCoordinator.java

	public int start ()
	{
		return start(BasicAction.Current());
BasicAction.Current()==null,
	}

	public int start (BasicAction parentAction)
parentAction==null,
	{
		if (parentAction != null)
/n,
		{
		    if (typeOfAction() == ActionType.NESTED)
			parentAction.addChildAction(this);
		}

		return super.Begin(parentAction);
parentAction==null,
	}
/s,
$ vi BasicAction.java

    private final void actionInitialise (BasicAction parent)
parent==null
    {
        currentHierarchy.add(get_uid(), actionType);
/ get_uid() in StateManager	,

        switch (actionType)
        {
            case ActionType.NESTED:
                if (parent == null)
/j,
                    actionType = ActionType.TOP_LEVEL;
                break;
        }
/s,
$ vi StateManager.java
    protected StateManager (Uid objUid, int ot, int om)
    {
        objectModel = om;
        myType = ot;

        objectUid = objUid;

        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("StateManager::StateManager( " + get_uid() + " )");
        }
    }
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Begin(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 1424	
                if (TxStats.enabled())
/n,
/ TODO

/ hierarchy,
Object
	com.arjuna.ats.arjuna.StateManager
		com.arjuna.ats.arjuna.coordinator.BasicAction
			com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator
				com.arjuna.ats.arjuna.AtomicAction
					com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction

/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 116	
		_theTransaction = new AtomicAction();
		_theTransaction.begin(timeout);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 124	
		int status = super.start();

		if (status == ActionStatus.RUNNING)
		{
			/*
			 * Now do thread/action tracking.
			 */

			ThreadActionData.pushAction(this);
this=BasicAction: 0:ffffc0a82b5e:540d6fac:5cca8694:a9e status: ActionStatus.RUNNING
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 69	
		pushAction(a, true);
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction, boolean) line: 93	
		Deque<BasicAction> txs = _threadList.get();
		if (txs == null)
/j,
		{
			txs = new ArrayDeque<BasicAction>();
			txs.push(a);
/ _threadList is dus een ArrayDeque met BasicActions er in,

			_threadList.set(txs);
		}
		else
			txs.push(a);

		if (register)
/j,

                    a.addChildThread(Thread.currentThread());
/s,
    /**
     * Add the specified thread to the list of threads associated with this
     * transaction.
     *
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).addChildThread(java.lang.Thread) line: 608
/=
    public final boolean addChildThread (Thread t)
t=Thread[default task-1,5,main]
	
        if (tsLogger.logger.isTraceEnabled()) {
/ TODO LOGGING 
                if (_childThreads == null)
                    _childThreads = new Hashtable<String, Thread>();

                _childThreads.put(ThreadUtil.getThreadId(t), t); // makes sure so we don't get 
					// duplicates
/s,
com.arjuna.ats.arjuna.utils.ThreadUtil.getThreadId(java.lang.Thread) line: 60	
	final Object id = THREAD_ID.get() ;
null
	if (id != null)
	{
	    return (String)id ;
	}
	
	final String newId = getNextId() ;
TSThread:1
	THREAD_ID.set(newId) ;					
	
/ THREAD_ID is 'n ThreadLocal, addChildThread werd called met Thread.currentThread()	, dus in de current thread's THREAD_ID staat TSThread:1	, en erachter in _childThreads staat t, maar dat is de current thread!	,

/ Intermezzo

	public class ThreadUtil
{
    /**
     * The ID associated with the thread.
     */
    private static final ThreadLocal THREAD_ID = new ThreadLocal() ;
    /**
     * The thread id counter.
     */
    private static long id ;
    /**
     * Get the next thread id to use.
     * @return The next thread id.
     */
	 
    private static synchronized String getNextId()
    {
	return "TSThread:" + Long.toHexString(++id) ;
    }
/ Einde Intermezzo

/t,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction, boolean) line: 94	
			_threadList.set(txs);

		if (register)
                    a.addChildThread(Thread.currentThread());
/d,
a	AtomicAction  (id=19323)	
	_childThreads	Hashtable<K,V>  (id=19438)	
{TSThread:1=Thread[default task-1,5,main]}

/ in ThreadActionData zit de AtomicAction in de ThreadLocal _threadList, en in de AtomicAction (eig. in ThreadUtil) zit de current thread in de ThreadLocal THREAD_ID ,


/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 124
	
			ThreadActionData.pushAction(this);
/d,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 111
	/*
	 * Only works with AtomicAction and TwoPhaseCoordinator.
	 */

	/**
	 * Create a new transaction with the specified timeout.
	 */

	public TransactionImple(int timeout)
	{	
		_theTransaction = new AtomicAction();

		_theTransaction.begin(timeout);

		_resources = new Hashtable();
		_duplicateResources = new Hashtable();
		_suspendCount = 0;
		_xaTransactionTimeoutEnabled = getXATransactionTimeoutEnabled();
/ TODO TIMEOUT
        _txLocalResources = Collections.synchronizedMap(new HashMap());
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTransaction(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple) line: 1578	
		TransactionImple.putTransaction(new TransactionImple(v));
/pd,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTransaction(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple) line: 1578	
/=
	static final protected void putTransaction(TransactionImple tx)
	{
		_transactions.put(tx.get_uid(), tx);
{0:ffffc0a82b5e:540d6fac:5cca8694:a9e=TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:540d6fac:5cca8694:a9e status: ActionStatus.RUNNING >}
/t,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 273	
            tm.begin();
/d,
            Transaction tx = tm.getTransaction();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
        return transactionManager.getTransaction() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
		return TransactionImple.getTransaction();
//////////////////
/ Nu volgt een keten van static calls, 
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
/=
	public static final TransactionImple getTransaction()
	{
		final BasicAction current = BasicAction.Current();
/s,
com.arjuna.ats.arjuna.coordinator.BasicAction.Current() line: 1256
/=
    public static BasicAction Current ()
    {
        return ThreadActionData.currentAction();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 59
/=
	public static BasicAction currentAction ()
	{	
		Deque<BasicAction> txs = _threadList.get();
		if (txs != null && !txs.isEmpty())
		{
			return txs.peekFirst();

/////////////////////////
/ _threadList is een thread local, dus zo vind je een tx,
/ het lijkt erop dat er maar 1 tx is per thread, 
/ dus geen nested txs,
/ TODO
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1065	
		final BasicAction current = BasicAction.Current();
/d,
		if (current != null)
		{
			final Uid txid = current.get_uid();		/ zit er gewoon in, heet objectUid,

			tx = (TransactionImple) _transactions.get(txid);

			if (tx == null)
/n,
				tx = new TransactionImple(current
/n,
		}
		
	private static final ConcurrentHashMap _transactions = new ConcurrentHashMap();

tx	TransactionImple  (id=19321)	
	_theTransaction	AtomicAction  (id=19323)	/=  current,
current	AtomicAction  (id=19323)

/ Intermezzo

tx	TransactionImple  (id=19321)	
	_transactions	ConcurrentHashMap<K,V>  (id=19533)	/ bevat tx,
	_theTransaction	AtomicAction  (id=19323)

public class BasicAction extends StateManager
{
    public static BasicAction Current ()
    {
        return ThreadActionData.currentAction();
    }

/ de AtomicAction (die een BasicAction is) heeft niet zoiets als de tx _transactions heeft	, de AtomicActions zitten in een thread local in ThreadActionData, en WH zit er daar maar 1 AtomicAction in,


/ Einde Intermezzo

/t,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
/d,
            try {
                return invocation.proceed();
/c,

/ Intermezzo

/ we waren in 	,
org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261	
			categoryDao.create(clothing);
/ maar,
@Stateless
public class CategoryDao {


/ Einde Intermezzo	

/c,
/s,
Thread [default task-1] (Suspended (breakpoint at line 78 in com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate))	
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).begin() line: 78	
        transactionManager.begin() ;
/cb,
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();														<- Maar hij is al begonnen	,
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
/cb,
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, 
	org.jboss.as.ejb3.component.EJBComponent, int) line: 344
        final TransactionManager tm = component.getTransactionManager();

        if (timeout != -1) {
            tm.setTransactionTimeout(timeout);
        }

        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();								/ (**)
            try {
                return invokeInOurTx(invocation, tm, component);
/cb,	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68
        final EJBComponent component = (EJBComponent) invocation.getPrivateData(Component.class);

        switch (transactionAttributeType) {
            case MANDATORY:
                return mandatory(invocation, component);
            case NEVER:
                return never(invocation, component);
            case NOT_SUPPORTED:
                return notSupported(invocation, component);
            case REQUIRED:
                return required(invocation, component, transactionTimeout);
            case REQUIRES_NEW:
                return requiresNew(invocation, component, transactionTimeout);
/cb ,
	org.jboss.invocation.InterceptorContext.proceed() line: 340
	org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 161	
        waitForComponentStart();
        // create the component instance
        final BasicComponentInstance basicComponentInstance = this.instantiateComponentInstance(preDestroyInterceptor, interceptorInstanceMap, context);
        if(instance != null) {
            basicComponentInstance.setInstanceData(BasicComponentInstance.INSTANCE_KEY, instance);
        }
        if (invokePostConstruct) {
            // now invoke the postconstruct interceptors
            final InterceptorContext interceptorContext = new InterceptorContext();
            interceptorContext.putPrivateData(Component.class, this);
            interceptorContext.putPrivateData(ComponentInstance.class, basicComponentInstance);
            interceptorContext.putPrivateData(InvocationType.class, InvocationType.POST_CONSTRUCT);
            interceptorContext.setContextData(new HashMap<String, Object>());

            try {
                postConstructInterceptor.processInvocation(interceptorContext);
/cb,	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean) line: 134
/=
    /**
     * Construct the component instance.  Upon return, the object instance should have injections and lifecycle
     * invocations completed already.
     *
     *
     * @param instance An instance to be wrapped, or null if a new instance should be created
     * @return the component instance
     */
    protected BasicComponentInstance constructComponentInstance(ManagedReference instance, boolean invokePostConstruct) {
        return constructComponentInstance(instance, invokePostConstruct, Collections.emptyMap());
/cb,	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).createInstance() line: 88	
        BasicComponentInstance instance = constructComponentInstance(null, true);
/cb,
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 64	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 61	
        StatelessObjectFactory<StatelessSessionComponentInstance> factory = new StatelessObjectFactory<StatelessSessionComponentInstance>() {
            @Override
            public StatelessSessionComponentInstance create() {
                return (StatelessSessionComponentInstance) createInstance();
/cb,
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 56	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, 
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();			/ (*)
/cb,
	org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327
        final EJBComponent component = (EJBComponent) invocation.getPrivateData(Component.class);
StatelessSessionComponent CategoryDao
/ TODO
        final TransactionManager tm = component.getTransactionManager();
        final int oldTimeout = getCurrentTransactionTimeout(component);
        try {
            final MethodIntf methodIntf = MethodIntfHelper.of(invocation);
            final TransactionAttributeType attr = component.getTransactionAttributeType(methodIntf, invocation.getMethod());
            final int timeoutInSeconds = component.getTransactionTimeout(methodIntf, invocation.getMethod());
            switch (attr) {
                case MANDATORY:
                    return mandatory(invocation, component);
                case NEVER:
                    return never(invocation, component);
                case NOT_SUPPORTED:
                    return notSupported(invocation, component);
                case REQUIRED:
                    return required(invocation, component, timeoutInSeconds);
	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	

/ Bij (*) waren we	,

		
/ Intermezzo

[standalone@localhost:9990 /] /subsystem=transactions:write-attribute(name=default-timeout,value=604800)  
{  
    "outcome" => "success",  
    "response-headers" => {  
        "operation-requires-reload" => true,  
        "process-state" => "reload-required"  
    }  
} 

/ Einde Intermezzo

/ Intermezzo

/ begin tx is WH de action in de thread local set, 
/ WH als er daar 1 staat, is dat de current tx; er kan er maar 1 in staan, 
/ TODO

/ eerder	,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1069	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();		/ thread local	,
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);	/ zoekt in hash map ogv uid in de BasicAction, die ook in de tx zit,
tx	TransactionImple  (id=19398)	
	_theTransaction	AtomicAction  (id=19433)	
			if (tx == null)
				tx = new TransactionImple(current);
		}

		return tx;
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 273	
org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	



/ Einde Intermezzo

/ bij (**) suspend 	,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).removeChildThread(java.lang.String) line: 676
        synchronized (this)
        {
            if (_childThreads != null)
            {
                _childThreads.remove(threadId);
                result = true;
            }
        }
/cb,	
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.purgeActions(java.lang.Thread, boolean) line: 245
		Deque<BasicAction> txs = _threadList.get();

		_threadList.set(null);

		if (txs != null)
		{
			if (unregister)
			{
				while (!txs.isEmpty())
				{
					BasicAction act = txs.pop();

					if (act != null)
                    {
						act.removeChildThread(ThreadUtil.getThreadId(t));
/cb,	
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.purgeActions() line: 221	
com.arjuna.ats.arjuna.AtomicAction.suspend() line: 334	
	/**
	 * Suspend all transaction association from the invoking thread. When this
	 * operation returns, the thread will be associated with no transactions.
	 *
	 * If the current transaction is not an AtomicAction then this method will
	 * not suspend.
	 *
	 * @return a handle on the current AtomicAction (if any) so that the thread
	 *         can later resume association if required.
	 *
	 */
		BasicAction curr = ThreadActionData.currentAction();

		if (curr != null)
		{
			if (curr instanceof AtomicAction)
				ThreadActionData.purgeActions();
			else {
                tsLogger.i18NLogger.warn_ats_atomicaction_1(curr.toString());

                curr = null;
            }
		}

		return (AtomicAction) curr;	/ maar wordt niet used,
/cb,	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.suspend() line: 71	
			TransactionImple tx = TransactionImple.getTransaction();

			if (tx != null)
			{
				tx.getAtomicAction().suspend();
			}

			return tx;	/ niet used,
/cb,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).suspend() line: 194	
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 342	
        Transaction tx = tm.getTransaction();			/ zo wordt de tx die wordt suspended onthouden	, en kan later weer resume,
        if (tx != null) {
            tm.suspend();		<-
            try {
                return invokeInOurTx(invocation, tm, component);
            } finally {
                tm.resume(tx);
            }
/cb,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68	

/ als suspend done,	
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();								<-
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 98	
		else
		    v = TxControl.getDefaultTimeout();		/ 604800s=1week	,

		// TODO set default timeout

)		TransactionImple.putTransaction(new TransactionImple(v));

/ tm.begin(): eerst een tx maken,

/ WH gaat hij in deze tx injection EntityManager, 
/ TODO

/t,
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();								
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
/d,
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx		<-
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
        transactionManager.commit() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
		theTransaction.commitAndDisassociate();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1177	
				switch (_theTransaction.commit(true))
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
		int status = super.end(report_heuristics);		<-
		/*
		 * Now remove this thread from the action state.
		 */

		ThreadActionData.popAction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 96	
		if (canEnd)
		{
			outcome = super.End(report_heuristics);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).End(boolean) line: 1533	
        else
        {
            ActionManager.manager().remove(get_uid());
/s,
com.arjuna.ats.arjuna.coordinator.ActionManager.remove(com.arjuna.ats.arjuna.common.Uid) line: 109
_allActions=
{0:ffffc0a82b5e:-568fb2e0:5cd447b9:72=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@79bd1c2e, 0:ffffc0a82b5e:-568fb2e0:5cd447b9:71=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@4908d03f}
		_allActions.remove(id);
_allActions=
{0:ffffc0a82b5e:-568fb2e0:5cd447b9:71=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@4908d03f}
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).End(boolean) line: 1537	
            ActionManager.manager().remove(get_uid());
/d,
            actionStatus = ActionStatus.COMMITTED;
            if (TxStats.enabled())
/ TODO STATS
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 168	
		int status = super.end(report_heuristics);
/d,
		/*
		 * Now remove this thread from the action state.
		 */

		ThreadActionData.popAction();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction() line: 141	
		return popAction(ThreadUtil.getThreadId(), true);
/s,
com.arjuna.ats.arjuna.utils.ThreadUtil.getThreadId() line: 43	
	return getThreadId(Thread.currentThread()) ;

/ Intermezzo
/ de thread id staat achter de thread in een thread local, is bijv 'TsThread:4'	,
/ wanneer wordt deze set of veranderd?
/ TODO

public class ThreadUtil
{
    /**
     * The ID associated with the thread.
     */
    private static final ThreadLocal THREAD_ID = new ThreadLocal() ;

	    /**
     * Get the string ID for the specified thread.
     * @param thread The thread.
     * @return The thread id
     */
    public static String getThreadId(final Thread thread)
    {
	final Object id = THREAD_ID.get() ;
	if (id != null)
	{
	    return (String)id ;
	}
	
	final String newId = getNextId() ;
	THREAD_ID.set(newId) ;
	return newId ;
    }
/ Einde Intermezzo

/t,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction() line: 141	
		return popAction(ThreadUtil.getThreadId(), true);
/pd,
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction(java.lang.String, boolean) line: 166	
		Deque<BasicAction> txs = _threadList.get();		/ _threadList is een thread local,
[BasicAction: 0:ffffc0a82b5e:-568fb2e0:5cd447b9:72 status: ActionStatus.COMMITTED]

		if (txs != null)
		{
			BasicAction a = txs.pop();
[]
			if (a != null && unregister)
			{
				a.removeChildThread(threadId);
/s,
					_childThreads.remove(threadId);
/t,
			if (txs.size() == 0)
			{
				_threadList.set(null);
/ TODO
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1242	
				switch (_theTransaction.commit(true))
/d,
		finally
		{
			TransactionImple.removeTransaction(this);
/s,
					_transactions.remove(tx.get_uid());
/t,
/ TX THREADS MECHANISM
/ herinner: in de static thread local ThreadLocalData._threadList zit de BasicAction: 0:ffffc0a82b5e:-568fb2e0:5cd447b9:71 status: ActionStatus.RUNNING,
/ deze heeft een Uid objectUid, en achter deze zit in static TransactionImple.hash map _transactions de (current) TransactionImple tx,
/ herinner: de thread zit in de inst AtomicAction (eig. BasicAction)'s Hashtable _childThreads	, achter een id zoals TSThread:1, die een thread local is,
/ dus in _threadList zitten geen threads, maar BasicActions, in _childThreads zitten threads,

/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();								
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();

            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
/d,
/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 344	
        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);
/d,
tx	TransactionImple  (id=20260)	
	_theTransaction	AtomicAction  (id=20508)	
BasicAction: 0:ffffc0a82b5e:-568fb2e0:5cd447b9:71 status: ActionStatus.RUNNING
///////////////////////
/ dit is de vorige	, die suspended is,
            } finally {
                tm.resume(tx);
...
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.resume(javax.transaction.Transaction) line: 111	
		        AtomicAction act = ((theTransaction == null) ? null : theTransaction.getAtomicAction());

		        if (!AtomicAction.resume(act))
/s,
com.arjuna.ats.arjuna.AtomicAction.resume(com.arjuna.ats.arjuna.AtomicAction) line: 366	
			ThreadActionData.restoreActions(act);
/s,
...
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction, boolean) line: 93	
		Deque<BasicAction> txs = _threadList.get();

		if (txs == null)
/j,
		{
			txs = new ArrayDeque<BasicAction>();
			txs.push(a);

			_threadList.set(txs);
		}
		else
			txs.push(a);

		if (register)
                    a.addChildThread(Thread.currentThread());
/s,
						_childThreads.put(ThreadUtil.getThreadId(t), t); // makes sure so we don't get
/t,
public class CMTTxInterceptor implements Interceptor {
    protected Object requiresNew(InterceptorContext invocation, final EJBComponent component, final int timeout) throws Exception {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);
            } finally {
                tm.resume(tx);
/d,
/t,
/**
 * Transaction interceptor for Singleton and Stateless beans,
 */
public class LifecycleCMTTxInterceptor extends CMTTxInterceptor {
    @Override
    public Object processInvocation(InterceptorContext invocation) throws Exception {
        final EJBComponent component = (EJBComponent) invocation.getPrivateData(Component.class);

        switch (transactionAttributeType) {
             case REQUIRES_NEW:
                return requiresNew(invocation, component, transactionTimeout);
/d,
/c,
Thread [default task-104] (Suspended (breakpoint at line 21 in org.arquillian.jpa.study2.dao.CategoryDao))	
	org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
/cb,
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93
        switch (interceptionType) {
            case AROUND_INVOKE:
                return doMethodInterception(context.getInvocationContext(), InterceptionType.AROUND_INVOKE, interceptorInstances, interceptorBindings);
/cb,	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83
        return aroundInvoke(context.getInvocationContext());
/cb,
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();		<-
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
            }
/cb,
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327
        final Transaction tx = tm.getTransaction();

        if (tx == null) {
            return invokeInOurTx(invocation, tm, component);
/cb,	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
                case REQUIRED:
                    return required(invocation, component, timeoutInSeconds);

/ we komen toch weer terug op dit punt, maar nu gaan we een andere keten van interceptors in ?
/ TODO

/ we gaan er in verder,
/s,
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            transactionIsRequired();
            getEntityManager().persist(entity);
/c,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);
{}
/cb,
    // Get an object from the Map of resources being managed for the transaction bound to the current thread at the time this method is called.
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126	
        TransactionImple transactionImple = getTransactionImple();
        return transactionImple.getTxLocalResource(key);
/cb,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106
        return delegate.getResource(key);
/cb,	
org.jboss.as.jpa.transaction.TransactionUtil.getEntityManagerInTransactionRegistry(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 116
        return (EntityManager)tsr.getResource(scopedPuName);
/cb,	
org.jboss.as.jpa.transaction.TransactionUtil.getTransactionScopedEntityManager(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 69
        return getEntityManagerInTransactionRegistry(puScopedName, tsr);
scopedPuName=ebca07ea-cf95-4bdf-bbb0-94b79afaf718.war#arquillian-jpa-study2-persistence-unit
/cb,
     * get or create a Transactional entity manager.
     * Only call while a transaction is active in the current thread.		/ dat doet hij ook, zie de caller	,
     *	
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 155	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
/cb,	 
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87
        isInTx = TransactionUtil.isInTx(transactionManager);
        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/cb,	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580
            transactionIsRequired();
            getEntityManager().persist(entity);
...
/s,
	static class SessionBuilderImpl implements SessionBuilderImplementor {
		private static final Logger log = CoreLogging.logger( SessionBuilderImpl.class );
/ TODO LOGGING
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1317	
			log.tracef( "Opening Hibernate Session.  tenant=%s, owner=%s", tenantIdentifier, sessionOwner );
			final SessionImpl session = new SessionImpl(
				...
				
/c,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 141	
		if ( !autoJoinTransactions ) {
			return;
		}

		if ( synchronizationRegistered ) {
			return;
		}

		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
			log.trace( "JTA platform says we cannot currently resister synchronization; skipping" );
			return;
		}

		joinJtaTransaction();
/cb,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 92
		this.jtaPlatform = jdbcSessionContext.getServiceRegistry().getService( JtaPlatform.class );
this	JtaTransactionCoordinatorImpl  (id=21929)	
	jtaPlatform	JBossAppServerJtaPlatform  (id=21932)	
		jtaManager	JtaManagerImpl  (id=21953)	
		serviceRegistry	StandardServiceRegistryImpl  (id=21861)	
		synchronizationStrategy	SynchronizationRegistryBasedSynchronizationStrategy  (id=21954)	
		tmSynchronizationStrategy	TransactionManagerBasedSynchronizationStrategy  (id=21955)	
		transactionManager	TransactionManagerDelegate  (id=20628)	
		userTransaction	null	

		pulse();
/ TODO		
/cb,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 28	
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 274
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(		<-
					this.jdbcCoordinator,
					this
			);
			this.currentHibernateTransaction = getTransaction();
			...
			if ( factory.getStatistics().isStatisticsEnabled() ) {
/ TODO LOGGING
				factory.getStatisticsImplementor().openSession();
			}
/cb,
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1327	
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 133	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse();
this	EntityManagerImpl  (id=21806)	
	session	SessionImpl  (id=21863)	
		factory	SessionFactoryImpl  (id=21805)	
		persistenceContext	StatefulPersistenceContext  (id=21868)		/ onthoud: de pc zit in de session,
/cb,

org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 83	
org.hibernate.jpa.internal.EntityManagerFactoryImpl.internalCreateEntityManager(javax.persistence.SynchronizationType, java.util.Map) line: 319	
org.hibernate.jpa.internal.EntityManagerFactoryImpl.createEntityManager() line: 286	
org.jboss.as.jpa.container.TransactionScopedEntityManager.createEntityManager(javax.persistence.EntityManagerFactory, java.util.Map, javax.persistence.SynchronizationType) line: 187	
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 157	
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	

/t,
    /**
     * get or create a Transactional entity manager.
     * Only call while a transaction is active in the current thread.
     *
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 158	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
        if (entityManager == null) {
            entityManager = createEntityManager(emf, properties, synchronizationType);
/d,
entityManager	EntityManagerImpl  (id=21806)	
	session	SessionImpl  (id=21863)	

/////////////////////////////////////
/ een entityManager manages entities, dus class insts met @Entity,

            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
/ TODO
            TransactionUtil.putEntityManagerInTransactionRegistry(scopedPuName, entityManager, transactionSynchronizationRegistry);
/ TODO
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/pd,
/c,
org.hibernate.internal.SessionFactoryImpl.getEntityPersister(java.lang.String) line: 779
		EntityPersister result = entityPersisters.get( entityName );	
this	SessionFactoryImpl  (id=21805)	
	entityPersisters	HashMap<K,V>  (id=22036)	
		[0]	HashMap$Node<K,V>  (id=22053)	
			key	"org.arquillian.jpa.study2.model.Item" (id=22056)	
			value	SingleTableEntityPersister  (id=22057)	
		[1]	HashMap$Node<K,V>  (id=22054)	
			key	"org.arquillian.jpa.study2.model.Category" (id=22246)	
			value	SingleTableEntityPersister  (id=22270)	
		[2]	HashMap$Node<K,V>  (id=22055)	
			key	"org.arquillian.jpa.study2.model.Bid" (id=22272)	
			value	SingleTableEntityPersister  (id=22273)	
/cb,
org.hibernate.internal.SessionImpl.getEntityPersister(java.lang.String, java.lang.Object) line: 1529	
org.hibernate.engine.internal.ForeignKeys.isTransient(java.lang.String, java.lang.Object, java.lang.Boolean, org.hibernate.engine.spi.SessionImplementor) line: 225	
		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );		<-
		isUnsaved = persister.isTransient( entity, session );		<<-
/cb,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).getEntityState(java.lang.Object, java.lang.String, org.hibernate.engine.spi.EntityEntry, org.hibernate.engine.spi.SessionImplementor) line: 510	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 99	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	

/ iets verder, bij <<-	,
/c,
org.hibernate.property.access.spi.GetterFieldImpl.get(java.lang.Object) line: 39	
		try {
			return field.get( owner );
owner	Category  (id=21081)	
	id	null	
/cb,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).getIdentifier(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 225	
			else {
				id = idGetter.get( entity );
/cb,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getIdentifier(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 4612
		return getEntityTuplizer().getIdentifier( entity, session );
/cb,	
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).isTransient(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 4324
		if ( canExtractIdOutOfEntity() ) {
			id = getIdentifier( entity, session );			<-
		}
		...
		// we *always* assume an instance with a null
		// identifier or no identifier property is unsaved!
		if ( id == null ) {									/ hier zal hij komen,
			return Boolean.TRUE;
		}
/cb,				
org.hibernate.engine.internal.ForeignKeys.isTransient(java.lang.String, java.lang.Object, java.lang.Boolean, org.hibernate.engine.spi.SessionImplementor) line: 226	
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
		isUnsaved = persister.isTransient( entity, session );		<<-
		if ( isUnsaved != null ) {
			return isUnsaved;			/ hier zal hij komen,
		}
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/d,
		switch ( entityState ) {
			case TRANSIENT: {
				entityIsTransient( event, createCache );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 185	
		LOG.trace( "Saving transient instance" );
/ TODO LOGGING
	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultPersistEventListener.class );

	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultPersistEventListener.class );
/s,
...
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/ dit ziet er onschuldig uit	, maar hij gaat sql doen:
select nextval ('hibernate_sequence')

/c,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986
            XAResource resource = getXAResource();
            if (!currentTx.enlistResource(resource))
currentTx=TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:-568fb2e0:5cd447b9:40f status: ActionStatus.RUNNING >
xaRes	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22428)	
	xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22435)	
		mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=22445)	
			autoCommit	true	
			conn	org.postgresql.jdbc42.Jdbc42Connection  (id=22454)	
			currentXid	null	
			isXA	true	
/cb,	
/ ENLIST
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 379
      // This method is a bit convulted, but it has to be such because
      // there is a race condition in the transaction manager where it
      // unlocks during the enlist of the XAResource. It does this
      // to avoid distributed deadlocks and to ensure the transaction
      // timeout can fail a badly behaving resource during the enlist.
      //
      // When two threads in the same transaction are trying to enlist						<-
      // connections they could be from the same resource manager
      // or even the same connection when tracking the connection by transaction.
      //
      // For the same connection, we only want to do the real enlist once.
      // For two connections from the same resource manager we don't
      // want the join before the initial start request.
      //
      // The solution is to build up a list of unenlisted resources
      // in the TransactionSynchronizer and then choose one of the
      // threads that is contending in the transaction to enlist them
      // in order. The actual order doesn't really matter as it is the
      // transaction manager that calculates the enlist flags and determines
      // whether the XAResource was already enlisted.
      //
      // Once there are no unenlisted resources the threads are released
      // to return the result of the enlistments.
      //
      // In practice, a thread just takes a snapshot to try to avoid one
      // thread having to do all the work. If it did not do them all
      // the next waiting thread will do the next snapshot until there
      // there is either no snapshot or no waiting threads.
      //
      // A downside to this design is a thread could have its resource enlisted by
      // an earlier thread while it enlists some later thread's resource.
      // Since they are all a part of the same transaction, this is probably
      // not a real issue.

      // If we are already enlisted there is no reason to check again, as this method
      // could be called multiple times during a transaction lifecycle.
      // We know that we can only be inside this method if we are allowed to
	
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())
sync=...jca...TransactionSynchronization@2144836931{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:-568fb2e0:5cd447b9:40f status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=false cancel=false}
/cb,
 *
 * 1. When an application component requests a new ConnectionHandle,
 *    it must find a ManagedConnection, and make sure a
 *    ConnectionEventListener is registered. It must inform the
 *    CachedConnectionManager that a connection handle has been given
 *    out. It needs to count the number of handles for each
 *    ManagedConnection.  If there is a current transaction, it must
 *    enlist the ManagedConnection's LocalTransaction in the transaction
 *    using the ConnectionEventListeners XAResource XAResource implementation.
 * Entry point: ConnectionManager.allocateConnection.
 * written.
 *
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 553	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).reconnectManagedConnection(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 928	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
cm=org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl@69cbaeef
mcf=XAManagedConnectionFactory@11e9fa33[xaDataSourceClass=org.postgresql.xa.PGXADataSource xaProps=44d2bf7b userName=null password=**** transactionIsolation=-1]
/cb,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/cb,		
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386
				return connectionProvider.getConnection();
/cb,	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87
				physicalConnection = jdbcConnectionAccess.obtainConnection();
/cb,	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47
		return logicalConnection().getPhysicalConnection();
/cb,	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );		<- eerst connection()	, dan later .prepareStatement()
/cb,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
					preparedStatement = doPrepare();
/cb,

org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/cb,	
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
sql=select nextval ('hibernate_sequence')
/cb,	
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
		IntegralDataTypeHolder value = callback.getNextValue();
/cb,
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/cb,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity ); / hier waren we,
/cb,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	

/ we zien keten, in de richting van steeds dieper:
jpa-jdbc-jca-jta(arjuna)

/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
/=
	public boolean enlistResource(XAResource xaRes) throws RollbackException,
xaRes	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22428)	
	xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22435)	
		mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=22445)	
			autoCommit	true	
			conn	org.postgresql.jdbc42.Jdbc42Connection  (id=22454)	
			currentXid	null	
			isXA	true	

/ de xa resource is de conn,

/ we gaan hier verder mee,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
		return enlistResource(xaRes, null);
/s,
/ ENLIST
/ we gaan de resource enlist in de jta tx,
/ eerst wordt er een xid gemaakt, met de global tx id en de branch tx id er in,
/ dan wordt de resource gestart: pg driver sets autocommit off, en sets xid in itself	,
/ dan wordt de resource in _resources van de global tx set: _resources.put(xaRes, new TxInfo(xid));
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 586
			/*
			 * We definitely haven't seen this specific resource instance
			 * before, but that doesn't mean that we haven't seen the RM it is
			 * connected to.
			 */	
			Xid xid = null;
			TxInfo existingRM = isNewRM(xaRes);
null
			if (existingRM == null)
			{
				/*
				 * New RM, so create xid with new branch.
				 */

				boolean branchRequired = true;
				...
				xid = createXid(branchRequired, theModifier, xaRes);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1532	
        int eisName = 0;
        if(branch) {
            if(_xaResourceRecordWrappingPlugin != null) {
                eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);
2
/s,
com.arjuna.ats.internal.jbossatx.jta.XAResourceRecordWrappingPluginImpl.getEISName(javax.transaction.xa.XAResource) line: 72	
			String jndiName = ((XAResourceWrapper) xaResource).getJndiName();
java:jboss/datasources/PostgreSQLDS
			Integer key = nameToKey.get(jndiName);
2
nameToKey={java:jboss/datasources/RemoteExampleDS=3, java:jboss/datasources/ExampleDS=1, java:jboss/datasources/PostgreSQLDS=2}
		Xid xid = new XidImple(_theTransaction.get_uid(), branch, eisName);
/s,
com.arjuna.ats.jta.xa.XidImple.<init>(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 92	
			_theXid = XATxConverter.getXid(id, branch, eisName);
id=0:ffffc0a82b5e:-568fb2e0:5cd447b9:40f		# global tx 
branch=true
eisName=2
/s,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 60	
        if (branch)
            return getXid(uid, new Uid(), FORMAT_ID, eisName);
/s,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, com.arjuna.ats.arjuna.common.Uid, int, java.lang.Integer) line: 78	
/=
    private static XID getXid(Uid uid, Uid branch, int formatId, Integer eisName) throws IllegalStateException
uid=0:ffffc0a82b5e:-568fb2e0:5cd447b9:40f		/ global tx id
branch=0:ffffc0a82b5e:-568fb2e0:5cd447b9:39b6	/ branch tx id
format id=131077

        XID xid = new XID();
/ hier komt alles in,
        xid.formatID = formatId;
		
		byte[] gtridUid = uid.getBytes();		/ gtrid=global tx id,

		String nodeName = TxControl.getXANodeName();
"1"
/ TODO
		...
        // src, srcPos, dest, destPos, length
        System.arraycopy(gtridUid, 0, xid.data, 0, gtridUid.length);
        System.arraycopy(nodeName.getBytes(), 0, xid.data, gtridUid.length, nodeNameLengthToUse);

            // bqual is uid byte form plus EIS name.
            byte[] bqualUid = branch.getBytes();
			...
            // src, srcPos, dest, destPos, length
            int offset = xid.gtrid_length;
            System.arraycopy (bqualUid, 0, xid.data, offset, bqualUid.length);
            setEisName(xid, eisName);
2
/ XID is dus
global tx id
xa node name 1 / TODO
branch id
eis name (pg) 2
xid=< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b5e:-568fb2e0:5cd447b9:40f, node_name=1, branch_uid=0:ffffc0a82b5e:-568fb2e0:5cd447b9:39b6, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 609	
				xid = createXid(branchRequired, theModifier, xaRes);
/d,
				while (!associatedWork)
				{
					try
					{
						if (_xaTransactionTimeoutEnabled)
						{
							int timeout = _theTransaction.getTimeout();	/ 604800

							if (timeout > 0)
							{
								try
								{
									xaRes.setTransactionTimeout(timeout);
xaRes=XAResourceWrapperImpl@9a5969[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@77aa4bf pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]

						int xaStartNormal = ((theModifier == null) ? XAResource.TMNOFLAGS			<-
								: theModifier
										.xaStartParameters(XAResource.TMNOFLAGS));
/ Intermezzo

public interface XAResource
{
    /**
     *  Flag value indicating that no flags are set.
     */
    public static final int TMNOFLAGS = 0;
     *  Flag value for the {@link #start(Xid, int) start} method indicating
     *  that the resource should associate with a transaction previously seen
     *  by this resource manager.
     */
    public static final int TMJOIN = 2097152;	
    /**
     *  Flag value for the {@link #start(Xid, int) start} method indicating
     *  that the resource should associate with a transaction where the
     *  association was suspended.
     */
    public static final int TMRESUME = 134217728;

    /**
     *  Flag value for the {@link #end(Xid, int) end} method indicating that
     *  the transaction should be disassociated, and that the work has
     *  completed sucessfully.
     */
    public static final int TMSUCCESS = 67108864;
...

/ Einde Intermezzo

                        // Pay attention now, this bit is hairy. We need to add a new AbstractRecord (XAResourceRecord)
                        // to the BasicAction, which will thereafter drive its completion. However, the transaction
                        // core is not directly XA aware, so it's our job to start the XAResource. Problem is, if
                        // adding the record fails, BasicAction will never end the resource via the XAResourceRecord,
                        // so we must do so directly.  start may fail due to dupl xid or other reason, and transactions
                        // may rollback async, for which reasons we can't call add before start.
                        // The xid will change on each pass of the loop, so we need to create a new record on each pass.
                        // The add will fail in the case of multiple last resources being disallowed
                        // see JBTM-362 and JBTM-363
                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);
params=null
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createRecord(javax.transaction.xa.XAResource, java.lang.Object[], javax.transaction.xa.Xid) line: 812	
            return new XAResourceRecord(this, xaRes, xid, params);
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.<init>(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple, javax.transaction.xa.XAResource, javax.transaction.xa.Xid, java.lang.Object[]) line: 109	
		super(new Uid(), null, ObjectType.ANDPERSISTENT);
...
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord(com.arjuna.ats.arjuna.StateManager).<init>(int, int) line: 812	
/=
    protected StateManager (int ot, int om)
ot=ObjectType.ANDPERSISTENT
om=ObjectModel.SINGLE
        objectModel = om;
        currentStatus = (((objectModel == ObjectModel.SINGLE) && (ot == ObjectType.RECOVERABLE)) ? ObjectStatus.ACTIVE
/n,
                : ObjectStatus.PASSIVE_NEW);
        initialStatus = currentStatus;
        myType = ot;

        objectUid = new Uid();
/t,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.<init>(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple, javax.transaction.xa.XAResource, javax.transaction.xa.Xid, java.lang.Object[]) line: 111	
		super(new Uid(), null, ObjectType.ANDPERSISTENT);
/d,
this	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=22720)	
	_committed	false	
	_prepared	false	
	_recovered	false	
	...
		_theXAResource = res;
        if(_xaResourceRecordWrappingPlugin != null) {
            _xaResourceRecordWrappingPlugin.transcribeWrapperData(this);
        }
this	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=22720)	
	_committed	false	
	_jndiName	"java:jboss/datasources/PostgreSQLDS" (id=22432)	
	_prepared	false	
	_productName	"PostgreSQL" (id=22433)	
	_productVersion	"9.6.5" (id=22434)	
	_recovered	false	
	_theXAResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22428)
	
		_recoveryObject = null;
		_tranID = xid;

		_valid = true;

		...

		_prepared = false;
		_heuristic = TwoPhaseOutcome.FINISH_OK;
		_theTransaction = tx;
this	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=22720)	
	_heuristic	7	
	_tranID	com.arjuna.ats.jta.xa.XidImple  (id=22695)	
	_valid	true	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20640)	
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 661	
                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);
/d,
						if(abstractRecord != null) {
                            xaRes.start(xid, xaStartNormal);
/s,
org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.start(javax.transaction.xa.Xid, int) line: 215	
      xaResource.start(xid, flags);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 245	
            xaResource.start(xid, flags);
/s,
    /**** XAResource interface ****/

    /**
     * Preconditions:
     * 1. flags must be one of TMNOFLAGS, TMRESUME or TMJOIN		<- bij ons nu TMNOFLAGS
     * 2. xid != null
     * 3. connection must not be associated with a transaction
     * 4. the TM hasn't seen the xid before
     *
     * Implementation deficiency preconditions:
     * 1. TMRESUME not supported.
     * 2. if flags is TMJOIN, we must be in ended state,
     *    and xid must be the current transaction
     * 3. unless flags is TMJOIN, previous transaction using the 
     *    connection must be committed or prepared or rolled back
     * 
     * Postconditions:
     * 1. Connection is associated with the transaction
     */
org.postgresql.xa.PGXAConnection.start(javax.transaction.xa.Xid, int) line: 206	

/ Intermezzo

/ we hebben ook b set in:
PGXAConnection [line: 301] - prepare(Xid)	
PGXAConnection [line: 352] - recover(int)	
PGXAConnection [line: 409] - rollback(Xid)	
PGXAConnection [line: 450] - commit(Xid, boolean)
        if (onePhase)
            commitOnePhase(xid);
        else
            commitPrepared(xid);	
PGXAConnection [line: 476] - commitOnePhase(Xid)	
PGXAConnection [line: 515] - commitPrepared(Xid)	

/ Einde Intermezzo

        // Check preconditions
        if (flags != XAResource.TMNOFLAGS && flags != XAResource.TMRESUME && flags != XAResource.TMJOIN)
            throw new PGXAException(GT.tr("Invalid flags"), XAException.XAER_INVAL);

        if (xid == null)
            throw new PGXAException(GT.tr("xid must not be null"), XAException.XAER_INVAL);

        if (state == STATE_ACTIVE)
            throw new PGXAException(GT.tr("Connection is busy with another transaction"), XAException.XAER_PROTO);

        // We can't check precondition 4 easily, so we don't. Duplicate xid will be catched in prepare phase.

        // Check implementation deficiency preconditions
        if (flags == TMRESUME)
            throw new PGXAException(GT.tr("suspend/resume not implemented"), XAException.XAER_RMERR);
		...
        try
        {
            localAutoCommitMode = conn.getAutoCommit();	/ true
            conn.setAutoCommit(false);
        }
        // Preconditions are met, Associate connection with the transaction
        state = STATE_ACTIVE;
        currentXid = xid;
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 275	
            xaResource.start(xid, flags);
/d,
         synchronized (stateLock)
         {
            currentXid = xid;
            inManagedTransaction = true;
         }
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 663	
                        if(abstractRecord != null) {
                            xaRes.start(xid, xaStartNormal);
/d,
                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {
/s,
    /**
     * Add a record to the atomic action. This function returns AR_ADDED if the
     * record is added. AR_REJECTED if the record cannot be added because the
     * action is past the prepare phase, and IGNORED otherwise.
     *
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).add(com.arjuna.ats.arjuna.coordinator.AbstractRecord) line: 301	
            if (pendingList == null)
                pendingList = new RecordList();

            result = (pendingList.insert(A) ? AddOutcome.AR_ADDED
                    : AddOutcome.AR_DUPLICATE);
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 664	
                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {
/d,
/j,
                                _resources.put(xaRes, new TxInfo(xid));
_resources={XAResourceWrapperImpl@9a5969[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@77aa4bf pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]=com.arjuna.ats.internal.jta.xa.TxInfo@312459c8} 
								return true; // dive out, no need to set associatedWork = true;
...
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 381	
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())
/d,  
sync=...jca...TransactionSynchronization@2144836931{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b5e:-568fb2e0:5cd447b9:40f status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}           
				{
                  synchronizer.addEnlisted(sync);
         finally
         {
            synchronizer.enlisted();	/ sets enListingThread=null
         }

/ er zijn,
this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22388)	
ourSynchronization	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22387)	
synchronizer	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=22851)	
	enlisted	java.util.ArrayList<E>  (id=22852)	
	[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22387)	

	    setEnlisted(true);
...
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 753	
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/d,
/ see ENLIST
/ reconnect xaresource=conn is start de conn (autocommit=off, save xid), en enlist in global jta tx: set in _resources,

      // Ask the managed connection for a connection
      Object connection = null;
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);

/ herinner	,
/ we zitten nog steeds in ,
						: connection().prepareStatement( sql );		<- eerst connection()	, dan later .prepareStatement()

/ we zien stack: 	jpa(hibernate)-jdbc-jca
/ we zitten nu in jca,




/ Einde DEBUG TX

/ DEBUG TX START WILDFLY

/ 7	. 

/ een ds is een administratief ding, met databasename,servername, user, password, waarmee de url wordt gemaakt,  en de driver,
/ de driver maakt de conn,

/ er is nu geen tx,

/ uiteindelijk komen we in,
/s,
package org.postgresql.core;
public class PGStream
    public PGStream(HostSpec hostSpec, int timeout) throws IOException
    {
        this.hostSpec = hostSpec;

        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);

/ als we in forge: build test, dan vallen we in:

Thread [ServerService Thread Pool -- 113] (Suspended)	
	owns: org.hibernate.boot.registry.internal.StandardServiceRegistryImpl  (id=20939)
org.postgresql.Driver.makeConnection(java.lang.String, java.util.Properties) line: 414	
        return new org.postgresql.jdbc42.Jdbc42Connection(hostSpecs(props),
                                      user(props), database(props),
                                      props, url);
/cb,
org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 251	
                return makeConnection(url, props);
/cb,	
	java.sql.DriverManager.getConnection(java.lang.String, java.util.Properties, java.lang.Class<?>) line: 664	
        for(DriverInfo aDriver : registeredDrivers) {
            // If the caller does not have permission to load the driver then
            // skip it.
            if(isDriverAllowed(aDriver.driver, callerCL)) {
                try {
                    println("    trying " + aDriver.driver.getClass().getName());
                    Connection con = aDriver.driver.connect(url, info);
/cb,
	java.sql.DriverManager.getConnection(java.lang.String, java.lang.String, java.lang.String) line: 247
        return (getConnection(url, info, Reflection.getCallerClass()));
url=jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10	
/cb,
	org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getConnection(java.lang.String, java.lang.String) line: 88	
            Connection con = DriverManager.getConnection(getUrl(), user, password);
/cb,
	org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection(java.lang.String, java.lang.String) line: 54	
	org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection() line: 39	
        return getXAConnection(getUser(), getPassword());
/ user, password komen uit de ds,
/ net als databasename, servername	,
/ cb,
	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 492	
	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 416	
	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1320	
	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getSimpleConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 617	
	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 589	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
	org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
	org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection() line: 180	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 68	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 35	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(org.hibernate.service.spi.ServiceInitiator<R>) line: 88	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).createService(org.hibernate.service.spi.ServiceBinding<R>) line: 254	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 228	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(java.util.Map) line: 51	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(org.hibernate.service.spi.ServiceBinding<R>) line: 94	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 237	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.handleTypes(org.hibernate.boot.spi.MetadataBuildingOptions) line: 352	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(org.hibernate.boot.model.process.spi.ManagedResources, org.hibernate.boot.spi.MetadataBuildingOptions) line: 111	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata() line: 847	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build() line: 874	
	org.jboss.as.jpa.hibernate5.TwoPhaseBootstrapImpl.build() line: 44	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 161	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 121	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedAction<T>, java.security.AccessControlContext) line: 667	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1.run() line: 193	
	java.util.concurrent.ThreadPoolExecutor.runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	org.jboss.threads.JBossThread(java.lang.Thread).run() line: 748	
	org.jboss.threads.JBossThread.run() line: 320	

/ 7	. 

/ later,

Thread [ServerService Thread Pool -- 113] (Suspended (breakpoint at line 122 in org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl))	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.tool.hbm2ddl.SuppliedConnectionProviderConnectionHelper.prepare(boolean) line: 33	
	org.hibernate.tool.hbm2ddl.DatabaseExporter.<init>(org.hibernate.tool.hbm2ddl.ConnectionHelper, org.hibernate.engine.jdbc.spi.SqlExceptionHelper) line: 35	
	org.hibernate.tool.hbm2ddl.SchemaExport.execute(org.hibernate.tool.hbm2ddl.Target, org.hibernate.tool.hbm2ddl.SchemaExport$Type) line: 425	
	org.hibernate.tool.hbm2ddl.SchemaExport.create(org.hibernate.tool.hbm2ddl.Target) line: 361	
	org.hibernate.tool.hbm2ddl.SchemaExport.create(boolean, boolean) line: 350	
	org.hibernate.internal.SessionFactoryImpl.<init>(org.hibernate.boot.spi.MetadataImplementor, org.hibernate.boot.spi.SessionFactoryOptions) line: 467
			new SchemaExport( serviceRegistry, metadata, createDropNamespaces )
					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
					.create( false, true );
/cb,
	org.hibernate.boot.internal.SessionFactoryBuilderImpl.build() line: 444	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build() line: 879	
	org.jboss.as.jpa.hibernate5.TwoPhaseBootstrapImpl.build() line: 44	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 161	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 121	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedAction<T>, java.security.AccessControlContext) line: 667	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1.run() line: 193	
	java.util.concurrent.ThreadPoolExecutor.runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	org.jboss.threads.JBossThread(java.lang.Thread).run() line: 748	
	org.jboss.threads.JBossThread.run() line: 320	

/ later,

/ er wordt een AtomicAction gemaakt, en in .begin wordt deze in de thread local set, en wordt de thread in de AtomicAction register,
/ de AtomicAction, of de TransactionImple is de globale tx,

Thread [default task-118] (Suspended)	
	com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction, boolean) line: 94
		Deque<BasicAction> txs = _threadList.get();

		if (txs == null)
		{
			txs = new ArrayDeque<BasicAction>();
			txs.push(a);

			_threadList.set(txs);
		}
		else
			txs.push(a);

		if (register)
                    a.addChildThread(Thread.currentThread());
/cb,	
	com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 69	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 124	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 104	
		_theTransaction = new AtomicAction();
		_theTransaction.begin(timeout);	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 98
/cb,		
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).begin() line: 78	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272
            tm.begin();												<-
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
/cb,	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	org.arquillian.jpa.study2.dao.CategoryDao$$$view27.create(org.arquillian.jpa.study2.model.Category) line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	org.arquillian.jpa.study2.dao.CategoryDao$Proxy$_$$_Weld$EnterpriseProxy$.create(org.arquillian.jpa.study2.model.Category) line: not available	
	org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261	
	...

/ 7	. 

/ later 	,

/ LifecycleCMTTxInterceptor, 
/ deze vereiste een nieuwe tx, requiresNew, en ended de tx
/ TODO

/ 7	. 

/ later,

/ eerder zagen we als dat .create werd called, maar toen ging hij eerst een tx maken (niet de lifecycle tx die er tussendoor kwam), nu pas echt in de mth	,

@Stateless
public class CategoryDao {
	@PersistenceContext(unitName = "arquillian-jpa-study2-persistence-unit")
	private EntityManager em;

	public void create(Category entity) {
		em.persist(entity);						<-
	}
	
/ 7	. 

/ later,

/ de branch tx joins de global jta tx,

/ zie het enorme verschil tussen,

	org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
/cb,
...
	org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261	
			categoryDao.create(clothing);
			
/ dat heeft allemaal te maken met bijv eerst tx maken,
/ wat is er nog meer?
/ TODO

Thread [default task-118] (Suspended (breakpoint at line 146 in org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl))	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 146	
		joinJtaTransaction();
/ de branch tx joins de global jta tx,
/cb,	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 92	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 28	
	org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 274	
	org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1327	
	org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 133	
	org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
	org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 83	
	org.hibernate.jpa.internal.EntityManagerFactoryImpl.internalCreateEntityManager(javax.persistence.SynchronizationType, java.util.Map) line: 319	
	org.hibernate.jpa.internal.EntityManagerFactoryImpl.createEntityManager() line: 286	
	org.jboss.as.jpa.container.TransactionScopedEntityManager.createEntityManager(javax.persistence.EntityManagerFactory, java.util.Map, javax.persistence.SynchronizationType) line: 187	
	org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 157	
	org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
	org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
	org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
/cb,
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	org.arquillian.jpa.study2.dao.CategoryDao$$$view27.create(org.arquillian.jpa.study2.model.Category) line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	org.arquillian.jpa.study2.dao.CategoryDao$Proxy$_$$_Weld$EnterpriseProxy$.create(org.arquillian.jpa.study2.model.Category) line: not available	
	org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261	
			categoryDao.create(clothing);
			
/ we gaan hier verder in,
/ TODO REGISTER SYNCHRONIZATION

/ adds een com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple aan de AtomicAction	, in _sync	,

/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).addSynchronization(com.arjuna.ats.arjuna.coordinator.SynchronizationRecord) line: 135	
/=
	public int addSynchronization (SynchronizationRecord sr)
	
sr	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=22458)	
	_isInterposed	true	
	_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22404)	
	_theUid	com.arjuna.ats.arjuna.common.Uid  (id=22459)	

                // need to guard against synchs being added while we are performing beforeCompletion processing
                if (_synchs.add(sr))			
                {
                    result = AddOutcome.AR_ADDED;
                }

com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.registerSynchronizationImple(com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple) line: 388	
			if (_theTransaction.addSynchronization(synchronizationImple) != AddOutcome.AR_ADDED)
			
synchronizationImple	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=22458)	
	_isInterposed	true	
	_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22404)	
	_theUid	com.arjuna.ats.arjuna.common.Uid  (id=22459)	
/cb,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.registerInterposedSynchronization(javax.transaction.Synchronization) line: 133
/=
    public void registerInterposedSynchronization(Synchronization synchronization)
	
synchronization	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22404)	
	jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21063)	
	jcaSyncs	java.util.ArrayList<E>  (id=22406)	
	tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21323)	

        TransactionImple transactionImple = getTransactionImple();
        try
        {
            transactionImple.registerSynchronizationImple(new SynchronizationImple(synchronization, true));	<-

org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 68	
            Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
            if (jcaOrderedLastSynchronization == null) {
/j,
/ jcaOrderedLastSynchronization={jcaSyncs, preJcaSyncs, ...} staat achter de global tx, dus is van de global tx, 
/ deze bevat Synchronizations (added bij (*), in preJcaSyncs) en WH is die van de branch, de local tx,
/ TODO
                JCAOrderedLastSynchronizationList toPut = new JCAOrderedLastSynchronizationList((com.arjuna.ats.jta.transaction.Transaction) tx, interposedSyncs);
                jcaOrderedLastSynchronization = interposedSyncs.putIfAbsent(tx, toPut);
                if (jcaOrderedLastSynchronization == null) {
                    jcaOrderedLastSynchronization = toPut;
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization);	<- (*)
                }
            }
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync);	
/cb,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29
		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
				synchronization
		);
/cb,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform(org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform).registerSynchronization(javax.transaction.Synchronization) line: 126	
		getSynchronizationStrategy().registerSynchronization( synchronization );
		
synchronization	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21575)	
	synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=21574)	
		target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=21559)	
			jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=21576)	
				jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=22253)	
				serviceRegistry	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl  (id=21219)	
				synchronizationStrategy	org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy  (id=21577)	
				tmSynchronizationStrategy	org.hibernate.engine.transaction.jta.platform.internal.TransactionManagerBasedSynchronizationStrategy  (id=22303)	
				transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=21016)	
			synchronizationRegistry	org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl  (id=22279)	
			transactionCoordinatorBuilder	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl  (id=21560)	
			transactionCoordinatorOwner	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=22280)	
/cb,
	/**
	 * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the
	 * RegisteredSynchronization with the JTA system
	 */
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );		<-
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
/cb,	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 146	
		joinJtaTransaction();
	
/t,
/ jcaOrderedLastSynchronization={jcaSyncs, preJcaSyncs, ...} staat achter de global tx, dus is van de global tx, 
/ deze bevat Synchronizations (added bij (*), in preJcaSyncs) en WH is die van de branch, de local tx,
/ TODO
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 78	
            Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
            if (jcaOrderedLastSynchronization == null) {
                JCAOrderedLastSynchronizationList toPut = new JCAOrderedLastSynchronizationList((com.arjuna.ats.jta.transaction.Transaction) tx, interposedSyncs);
                jcaOrderedLastSynchronization = interposedSyncs.putIfAbsent(tx, toPut);
                if (jcaOrderedLastSynchronization == null) {
                    jcaOrderedLastSynchronization = toPut;
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization); / (*)
/d,
                }
            }
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync);
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.registerInterposedSynchronization(javax.transaction.Synchronization) line: 90	
            preJcaSyncs.add(synchronization);
...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 159	
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/d,
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl.synchronizationRegistered() line: 77	
		registrationThreadId = Thread.currentThread().getId();

/ 7	. 

/ later,

/ de sql wordt gechecked	, 
/ dit is bij preparedstatement	,

Thread [default task-118] (Suspended)	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).<init>(org.hibernate.engine.jdbc.internal.StatementPreparerImpl, java.lang.String) line: 159	
			final String inspectedSql = jdbcCoordinator.getJdbcSessionOwner()
					.getJdbcSessionContext()
					.getStatementInspector()
					.inspect( incomingSql );									/ WH gebeurt hier niets, TODO
			this.sql = inspectedSql == null ? incomingSql : inspectedSql;
/cb,
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.<init>(org.hibernate.engine.jdbc.internal.StatementPreparerImpl, java.lang.String, boolean) line: 82	
		return new StatementPreparationTemplate( sql ) {				<- we zijn nog hier,
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}

	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.buildPreparedStatementPreparationTemplate(java.lang.String, boolean) line: 82	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/cb,	
	org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );	<-
sql=select nextval ('hibernate_sequence')
/cb,	
	org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40
		IntegralDataTypeHolder value = callback.getNextValue();
/cb,	
	org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/cb,	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101
		EntityPersister persister = source.getEntityPersister( entityName, entity );
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );		<-
/cb,	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67
	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
	org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
	org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
	org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
	org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
	org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
	org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	org.arquillian.jpa.study2.dao.CategoryDao$$$view27.create(org.arquillian.jpa.study2.model.Category) line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	org.arquillian.jpa.study2.dao.CategoryDao$Proxy$_$$_Weld$EnterpriseProxy$.create(org.arquillian.jpa.study2.model.Category) line: not available	
	org.arquillian.jpa.study2.dao.ItemCategoryDaoTest.initb() line: 261

/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/pd,
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
					preparedStatement = doPrepare();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 85	
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );

/ 7	 .

/ later,

/ we zien,
         return pool.getConnection(transaction, subject, cri);
/ TODO

org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl.getTransactionSynchronizationRegistry() line: 112
      return tsr;
/cb,	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionSynchronizationRegistry() line: 377
      if (getTransactionIntegration() != null)
         return getTransactionIntegration().getTransactionSynchronizationRegistry();
/cb,	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 584
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();		<-
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;	/ 0:ffffc0a82b5e:-568fb2e0:5cd447b9:39ea WH globale jta tx,
      if (trackByTransaction == null || transactionKey == null)
/n,
      {
         return getSimpleConnection(subject, cri, mcp);		/ wel eerder, toen was er geen globale jta tx
      }

      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
null 
      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);	<-
      }
/cb,	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
         return pool.getConnection(transaction, subject, cri);
/cb,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	

/ 	7 .

/ later,

org.postgresql.xa.PGXAConnection(org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection).getConnection() line: 154	

this	org.postgresql.xa.PGXAConnection  (id=22590)	
	autoCommit	true	
	con	org.postgresql.jdbc42.Jdbc42Connection  (id=22594)	
		autoCommit	true	
		commitQuery	org.postgresql.core.v3.SimpleQuery  (id=22600)	
		creatingURL	"jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10" (id=22601)	
		protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22602)	
			pgStream	org.postgresql.core.PGStream  (id=22611)	
				connection	java.net.Socket  (id=22616)	
				pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=22620)	
				pg_output	java.io.BufferedOutputStream  (id=22621)	
	currentXid	null	
/cb,
org.postgresql.xa.PGXAConnection.getConnection() line: 111
        Connection conn = super.getConnection();
Pooled connection wrapping physical connection org.postgresql.jdbc42.Jdbc42Connection@322a7999
/cb,	
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.<init>(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory, javax.sql.XAConnection, java.util.Properties, int, int) line: 68	
      super(mcf, xaConnection.getConnection(), props, transactionIsolation, psCacheSize);		<- (*)
/cb,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).newXAManagedConnection(java.util.Properties, javax.sql.XAConnection) line: 523	
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 416	
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1320	
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 598	


/ we waren in,

org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.<init>(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory, javax.sql.XAConnection, java.util.Properties, int, int) line: 68	
      super(mcf, xaConnection.getConnection(), props, transactionIsolation, psCacheSize);		<- (*)

/ en xaConnection.getConnection() is gedaan, en nu super(),
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).<init>(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnectionFactory, java.sql.Connection, java.util.Properties, int, int) line: 207	

      if (transactionIsolation == -1)
         this.transactionIsolation = con.getTransactionIsolation();
/ read_committed	,
      metadata = new ManagedConnectionMetaDataImpl(con, props.getProperty("user"));
/s,
org.jboss.jca.adapters.jdbc.ManagedConnectionMetaDataImpl.<init>(java.sql.Connection, java.lang.String) line: 79	
            productName = connection.getMetaData().getDatabaseProductName();
PostgreSQL
            productVersion = connection.getMetaData().getDatabaseProductVersion();
9.6.5
      this.maxConnections = 1;	/ TODO
      this.user = user;	
null

/ 7	. 

/ later,

org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.createConnectionListener(javax.resource.spi.ManagedConnection,             if (xaResource == null)
            {
               XAResource xar = mc.getXAResource();
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2d08c7b5
               if (!(xar instanceof org.jboss.jca.core.spi.transaction.xa.XAResourceWrapper))
               {
                  xaResource = txIntegration.createXAResourceWrapper(xar, padXid,
                                                                     isSameRMOverride,
                                                                     eisProductName, eisProductVersion,
                                                                     getJndiName(), txIntegration.isFirstResource(mc),
                                                                     getXAResourceStatistics());
txIntegration	org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl  (id=20975)	
	rr	com.arjuna.ats.jbossatx.jta.RecoveryManagerService  (id=21037)	
	terminator	com.arjuna.ats.internal.jbossatx.jta.jca.XATerminator  (id=21039)	
	tm	org.jboss.jca.core.tx.jbossts.TransactionManagerDelegator  (id=20980)	
	tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=21040)	
	utr	org.jboss.jca.core.tx.jbossts.UserTransactionRegistryImpl  (id=21041)	
	
      ConnectionListener cli = new TxConnectionListener(this, mc, getPool(), mcp,
                                                        getFlushStrategy(), getTracking(), getEnlistmentTrace(),
                                                        xaResource, explicitXAResourceTimeout);
      mc.addConnectionEventListener(cli);

																	 
/cb,
org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 716	
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1329	
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496
               // No, the pool was empty, so we have to make a new one.
               clw = new ConnectionListenerWrapper(createConnectionEventListener(subject, cri), true, true);
/d,
clw	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool$ConnectionListenerWrapper  (id=22800)	
	cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22779)	
		xaResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22777)	
/cb,	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699
      // Need a new one for this transaction
      // This must be done outside the tx local lock, otherwise
      // the tx timeout won't work and get connection can do a lot of other work
      // with many opportunities for deadlocks.
      // Instead we do a double check after we got the transaction to see
      // whether another thread beat us to the punch.
      ConnectionListener cl = mcp.getConnection(subject, cri);	/ zonder global tx,
	  
         // Check we weren't racing with another transaction
         ConnectionListener other =							/ (*)
            (ConnectionListener)tsr.getResource(mcp);
null
         // This is the connection for this transaction			/ CONNECTION FOR TRANSACTION !
         cl.setTrackByTx(true);
         tsr.putResource(mcp, cl);						/ (**)
/cb,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 598	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();

/ (*)
package com.arjuna.ats.internal.jta.transaction.arjunacore;
public class TransactionSynchronizationRegistryImple implements TransactionSynchronizationRegistry, Serializable, ObjectFactory

    // Get an object from the Map of resources being managed for the transaction bound to the current thread at the time this method is called.
/ klopt: BasicAction.Current() is een thread local ,en geeft dus de global tx bound to current thread, 
    public Object getResource(Object key)
    {
		...
        TransactionImple transactionImple = getTransactionImple();		/ thread local global tx,
        return transactionImple.getTxLocalResource(key); / deze heeft in ons geval 3 resources, 
    }

/ (**)
    // Add or replace an object in the Map of resources being managed for the transaction bound to the current thread at the time this method is called.
    public void putResource(Object key, Object value)
    {
		...
        TransactionImple transactionImple = getTransactionImple();
        transactionImple.putTxLocalResource(key, value);
    }
transactionImple	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21323)	
	_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=22857)	
		[0]	java.util.HashMap$Node<K,V>  (id=22885)	
			key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=21030)	
			value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22779)	
				trackByTx	java.util.concurrent.atomic.AtomicBoolean  (id=22786)	
				xaResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22777)	
					jndiName	"java:jboss/datasources/PostgreSQLDS" (id=20968)	
					xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22592)	
		[1]	java.util.HashMap$Node<K,V>  (id=22861)	
			key	org.jboss.jca.core.connectionmanager.transaction.LockKey  (id=22870)	
			value	java.util.concurrent.locks.ReentrantLock  (id=22580)	
		[2]	java.util.HashMap$Node<K,V>  (id=22862)	
			key	"__TX_LISTENERS" (id=22868)	
			value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=22869)	
		[3]	java.util.HashMap$Node<K,V>  (id=22863)	
			key	"5f4ed3ec-2fe3-4e20-a3e0-9f29e2ac1546.war#arquillian-jpa-study2-persistence-unit" (id=22867)	
			value	org.hibernate.jpa.internal.EntityManagerImpl  (id=21563)	

/ 7	.

/ later,
 
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      ConnectionListener cl = getManagedConnection(subject, cri);

      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 552	
         if (shouldEnlist(cl.getManagedConnection()))
            cl.enlist();
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 267	
      Transaction threadTx = tm.getTransaction();
            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());
/s,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.getRegisteredSynchronizer(javax.transaction.Transaction, org.jboss.jca.core.spi.transaction.TransactionIntegration) line: 244	
      Record record = records.get(id);
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer$Record@76338eb5 
id=global tx,
      return record.getTransactionSynchronizer();
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 267
            synchronizer =
/d,
         // First time through, create a transaction synchronization
         if (transactionSynchronization == null)
         {
            TransactionSynchronization synchronization = new TransactionSynchronization(threadTx, isTrackByTx());
            synchronizer.addUnenlisted(synchronization);			<- soort tussenstap	? TODO
            transactionSynchronization = synchronization;
         }

         ourSynchronization = transactionSynchronization;

      // Perform the enlistment(s)
      List<Synchronization> unenlisted = synchronizer.getUnenlisted();
      if (unenlisted != null)
      {
         try
         {
            int size = unenlisted.size();
            for (int i = 0; i < size; ++i)
            {
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())
               {
                  synchronizer.addEnlisted(sync);
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986	
            XAResource resource = getXAResource();
            if (!currentTx.enlistResource(resource))	/ Dit is wat een synchronization doet: enlist, register de conn (xa res = conn) bij de global tx	, ROL SYNCHRONIZATION 
/s,	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 430	
...
			/*
			 * We definitely haven't seen this specific resource instance
			 * before, but that doesn't mean that we haven't seen the RM it is
			 * connected to.
			 */

			Xid xid = null;
			TxInfo existingRM = isNewRM(xaRes);
null
				xid = createXid(branchRequired, theModifier, xaRes);
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b5e:-568fb2e0:5cd447b9:39ea, node_name=1, branch_uid=0:ffffc0a82b5e:-568fb2e0:5cd447b9:39f0, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >

						int xaStartNormal = ((theModifier == null) ? XAResource.TMNOFLAGS	<-
								: theModifier
										.xaStartParameters(XAResource.TMNOFLAGS));

                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);
abstractRecord	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=23217)	
	_jndiName	"java:jboss/datasources/PostgreSQLDS" (id=20968)	
	_productName	"PostgreSQL" (id=22725)	
	_productVersion	"9.6.5" (id=22612)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21323)	
	_theXAResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22777)	
	_tranID	com.arjuna.ats.jta.xa.XidImple  (id=23203)	
	objectUid	com.arjuna.ats.arjuna.common.Uid  (id=23225)	
	uidOfObject	com.arjuna.ats.arjuna.common.Uid  (id=23218)	

                        if(abstractRecord != null) {
                            xaRes.start(xid, xaStartNormal);
...
/s,
org.postgresql.xa.PGXAConnection.start(javax.transaction.xa.Xid, int) line: 206	
            localAutoCommitMode = conn.getAutoCommit();
true
            conn.setAutoCommit(false);
			
        // Preconditions are met, Associate connection with the transaction
        state = STATE_ACTIVE;
        currentXid = xid;				/ ASSOCIATE CONNECTION WITH GLOBAL TRANSACTION
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 664	

                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {	/ adds record in pendingList in de AtomicAction	, TODO
                                _resources.put(xaRes, new TxInfo(xid));
{XAResourceWrapperImpl@550d41ff[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2d08c7b5 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]=com.arjuna.ats.internal.jta.xa.TxInfo@53d5a837}
                                return true; // dive out, no need to set associatedWork = true;
...
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 381	
               if (sync.enlist())
/d,
               {
                  synchronizer.addEnlisted(sync);
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 753	
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/d,
      // Ask the managed connection for a connection
      Object connection = null;
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getWrappedConnection() line: 1193	

this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22592)	
	xaConnection	org.postgresql.xa.PGXAConnection  (id=22590)	
		con	org.postgresql.jdbc42.Jdbc42Connection  (id=22594)	
			autoCommit	false	
			protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22602)	
				pgStream	org.postgresql.core.PGStream  (id=22611)	

      WrappedConnection lc = WRAPPED_CONNECTION_FACTORY.createWrappedConnection(this,
                                                                                mcf.getSpy().booleanValue(),
                                                                                mcf.getJndiName(),
                                                                                mcf.isDoLocking());
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).<init>(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection, boolean, java.lang.String, boolean) line: 103	
      setManagedConnection(mc);		/ mc=this hierboven, de XAManagedConnection	,
      setSpy(spy);
      setJndiName(jndiName);
      this.doLocking = doLocking;
/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 139	

this	org.jboss.jca.adapters.jdbc.WrapperDataSource  (id=20954)	
	cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=20971)	
		pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=20973)	
			mcpPools	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21023)	
				[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=23483)	
					key	java.lang.Boolean  (id=21017)	
					value	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=21030)	
						cls	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21034)	
							[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=23533)	
								key	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22779)	
								value	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool$ConnectionListenerWrapper  (id=22800)	
									cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22779)	
										xaResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22777)	
											xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22592)	/ (*)
												currentXid	com.arjuna.ats.jta.xa.XidImple  (id=23203)	
												xaResource	org.postgresql.xa.PGXAConnection  (id=22590)	
													conn	org.postgresql.jdbc42.Jdbc42Connection  (id=22594)	
														protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22602)	
															pgStream	org.postgresql.core.PGStream  (id=22611)	
																connection	java.net.Socket  (id=22616)	
																pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=22620)	
																pg_output	java.io.BufferedOutputStream  (id=22621)	
	mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=20966)	
		xads	org.postgresql.xa.PGXADataSource  (id=21125)	
			databaseName	"test" (id=21133)	
			logger	null	
			password	"vi_lang17" (id=21134)	
			portNumber	0	
			properties	java.util.Properties  (id=21135)	
			serverName	"localhost" (id=21141)	
			user	"eric" (id=21136)	
		xaProps	java.util.Collections$SynchronizedMap<K,V>  (id=23355)	
			[0]	java.util.HashMap$Node<K,V>  (id=24448)	
				key	"DatabaseName" (id=24454)	
				value	"test" (id=21133)	
			[1]	java.util.HashMap$Node<K,V>  (id=24449)	
				key	"User" (id=24456)	
				value	"eric" (id=21136)	
			[2]	java.util.HashMap$Node<K,V>  (id=24450)	
				key	"Password" (id=24458)	
				value	"vi_lang17" (id=21134)	
			[3]	java.util.HashMap$Node<K,V>  (id=24451)	
				key	"ServerName" (id=24546)	
				value	"localhost" (id=21141)	

         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/d,
         wc.setDataSource(this);
wc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=23324)	
	dataSource	org.jboss.jca.adapters.jdbc.WrapperDataSource  (id=20954)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22592)	/ deze zien we ook in de pool bij (*)

         wc.setSpy(mcf.getSpy().booleanValue());
         wc.setJndiName(mcf.getJndiName());
         return wc;
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/pd,
/s,
/ van H. naar jca,

org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 743	
         return doPrepareStatement(sql, resultSetType, resultSetConcurrency);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	

      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);
con=Pooled connection wrapping physical connection org.postgresql.jdbc42.Jdbc42Connection@322a7999
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 347	
                    Statement st = (Statement)method.invoke(con, args);			<-
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).prepareStatement(java.lang.String, int, int) line: 282	
        return prepareStatement(sql, resultSetType, resultSetConcurrency, getHoldability());
/s,
org.postgresql.jdbc42.Jdbc42Connection.prepareStatement(java.lang.String, int, int, int) line: 40	
        return new Jdbc42PreparedStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
...
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 82	
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
cachedQuery	org.postgresql.core.CachedQuery  (id=24845)	
	key	"select nextval ('hibernate_sequence')" (id=22556)	
	query	org.postgresql.core.v3.SimpleQuery  (id=24849)	
		nativeQuery	org.postgresql.core.NativeQuery  (id=24854)	
			nativeSql	"select nextval ('hibernate_sequence')" (id=24852)	
		protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22602)	
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 347	
                    Statement st = (Statement)method.invoke(con, args);
/d,
                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{PreparedStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));

/ org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection heeft een  $ConnectionHandler en een $StatementHandler. Beide hebben een invoke fct	,
...
/d,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7.wrapPreparedStatement(java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 82	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/ lees https://www.baeldung.com/jdbc-resultset over CONCUR_READ_ONLY	,
/pd,
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7.wrapPreparedStatement(java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 82	
      return new WrappedPreparedStatementJDK7(this, statement, spy, jndiName, doLocking);
...
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/d,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 173	
					preparedStatement = doPrepare();
/d,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@7bab7a84			/ een jca ding,
...
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/d,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96	
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
/d,
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
				
/c,

/ WH is de TransactionSynchronizationRegistryImple de link tussen de resource en de jta tx; before 2 phase commit, de sync zegt tegen de resource dat hij de data moet flush naar de db, 
/ de TransactionSynchronizationRegistryImple kent dus de jta tx, en kan naar zijn status vragen	,

com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionStatus() line: 157	
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionStatus() line: 91	
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 236	
         if (mcf.getTransactionSynchronizationRegistry() != null)
            status = mcf.getTransactionSynchronizationRegistry().getTransactionStatus();
/cb,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransactionActive() line: 1928	
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkStatus() line: 1943	
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransaction() line: 1917	
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).checkTransaction() line: 1457	
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 495	
         checkTransaction();
/cb,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 70	
				rs = statement.executeQuery();
/cb,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );		<-
						try {
							rs.next();
/cb,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/cb,	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/cb,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
/ entity=Category

/13	. 

/ c,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 465
        execute(preparedQuery.query, preparedParameters, flags);
/cb,	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeQuery() line: 350	
        if (!executeWithFlags(0))
/cb,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 453	
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 504
         checkTransaction();
/d,
            ResultSet resultSet = ps.executeQuery();
	
/ we gaan hier verder in,
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 465
        execute(preparedQuery.query, preparedParameters, flags);
/s,	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 615
            connection.getQueryExecutor().execute(queryToExecute,
                                                  queryParameters,
                                                  handler,
                                                  maxrows,
                                                  fetchSize,
                                                  flags);
/ WAT IS EEN STATEMENT OF PREPAREDSTATEMENT 												  
/ we zien hier dat de query wordt execute door de conn's query executor, buiten de stmt om,
/ de stmt of pstmt is meer een mgnt ding, die de query params in orde maakt, en WH nog meer dingen,
/ een sql stmt is een select of insert of update of delete,
/s,												  
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 169
                handler = sendQueryPreamble(handler, flags);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendQueryPreamble(org.postgresql.core.ResultHandler, int) line: 357	
        // Send BEGIN on first statement in transaction.
        if ((flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) != 0 ||
                protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE)
/j,
            return delegateHandler;
org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler@4e1ffb8a
/ WH omdat we in een tx zijn, hoeven we geen BEGIN te doen 	,
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 169			
				ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
                sendSync();
                processResults(handler, flags);
/ s,
    // sendOneQuery sends a single statement via the extended query protocol.
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1519	
        sendParse(query, params, oneShot);
/ maakt een P... string in pgstream.output
        sendBind(query, params, portal, noBinaryTransfer);
/ maakt een B.. string, 
        sendExecute(query, portal, rows);
/ maakt een E... string
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 172	
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/d,
                sendSync();		
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendSync() line: 1167	
        pgStream.SendChar('S');     // Sync
        pgStream.SendInteger4(4); // Length
        pgStream.flush();
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 173	
                sendSync();
/d,
                processResults(handler, flags);
/s,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1718	
 
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case '2':    // Bind Complete  (response to Bind)
                pgStream.ReceiveInteger4(); // len, discarded
				
/ hiertussen case waarin BEGIN werd process,
				
            case 'C':  // Command Status (end of Execute)
                // Handle status.
                String status = receiveCommandStatus();
SELECT 1
                    Field[] fields = currentQuery.getFields();
fields	org.postgresql.core.Field[1]  (id=20854)	
	[0]	org.postgresql.core.Field  (id=20856)	
		BINARY_FORMAT	1	
		TEXT_FORMAT	0	
		columnLabel	"nextval" (id=20859)	
		format	0	
		length	8	
		nullable	2	
		oid	20	
		tableOid	0	
/ als je query pg_catalog.pg_type, doe dan select oid,*	, dan zien je 20	,

					if (fields != null || tuples != null) {
						// There was a resultset.
						handler.handleResultRows(currentQuery, fields, tuples,
								null);
/s,
org.postgresql.core.v3.QueryExecutorImpl$1.handleResultRows(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 372	
        // Insert a handler that intercepts the BEGIN.
        return new ResultHandler() {
                   private boolean sawBegin = false;

                   public void handleResultRows(Query fromQuery, Field[] fields, List tuples, ResultCursor cursor) {
                       if (sawBegin)																		/ nu hier,
                           delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
                   }
                   public void handleCommandStatus(String status, int updateCount, long insertOID) {
                       if (!sawBegin)																	/ WH eerder hier, TODO
                       {
                           sawBegin = true;
/s,
org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler.handleResultRows(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 267	
                ResultSet rs = AbstractJdbc2Statement.this.createResultSet(fromQuery, fields, tuples, cursor);
fields	org.postgresql.core.Field[1]  (id=20803)	
	[0]	org.postgresql.core.Field  (id=20827)	
		columnLabel	"nextval" (id=20834)	
		length	8	
		oid	20	
tuples	java.util.ArrayList<E>  (id=20823)	
	[0]	(id=20821)	
		[0]	(id=20822)	
			[0]	0	
			[1]	0	
			[2]	0	
			[3]	0	
			[4]	0	
			[5]	0	
			[6]	0	
			[7]	1	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.Jdbc42Statement).createResultSet(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 37	
        Jdbc42ResultSet newResult = new Jdbc42ResultSet(originalQuery,
                                                        this,
                                                        fields,
                                                        tuples,
                                                        cursor,
                                                        getMaxRows(),
                                                        getMaxFieldSize(),
                                                        getResultSetType(),	/     int TYPE_FORWARD_ONLY = 1003;
                                                        getResultSetConcurrency(),	/ int CONCUR_READ_ONLY = 1007;
                                                        getResultSetHoldability());	/     int CLOSE_CURSORS_AT_COMMIT = 2;
...
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).<init>(org.postgresql.core.Query, org.postgresql.core.BaseStatement, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor, int, int, int, int) line: 145	
        this.originalQuery = originalQuery;
        this.connection = (BaseConnection) statement.getConnection();
        this.statement = statement;
        this.fields = fields;			/ type,
        this.rows = tuples;				/ data, 
        this.cursor = cursor;
        this.maxRows = maxRows;
        this.maxFieldSize = maxFieldSize;
        this.resultsettype = rsType;			/ hoe door rs te gebruiken, hier hoe te scroll	,
        this.resultsetconcurrency = rsConcurrency;
        newResult.setFetchSize(getFetchSize());
        newResult.setFetchDirection(getFetchDirection());
        return newResult;
/t,
org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler.handleResultRows(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 273	
                ResultSet rs = AbstractJdbc2Statement.this.createResultSet(fromQuery, fields, tuples, cursor);
/d,
                append(new ResultWrapper(rs));
/t,
org.postgresql.core.v3.QueryExecutorImpl$1.handleResultRows(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 374	
/=
        return new ResultHandler() {
                   public void handleResultRows(Query fromQuery, Field[] fields, List tuples, ResultCursor cursor) {
                       if (sawBegin)
                           delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
                   }
/d,
/t,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1861	
					if (fields != null || tuples != null) {
						// There was a resultset.
						handler.handleResultRows(currentQuery, fields, tuples,
								null);
/d,
/t,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1718	
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case 'Z':    // Ready For Query (eventual response to Sync)
                receiveRFQ();
/s,
org.postgresql.core.v3.QueryExecutorImpl.receiveRFQ() line: 2255	
        char tStatus = (char)pgStream.ReceiveChar();
         case 'T':
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_OPEN);
            break;
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 174	
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
                sendSync();
                processResults(handler, flags);
/d,
...
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 470	
        execute(preparedQuery.query, preparedParameters, flags);
/d,
this	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=20789)	
	result	org.postgresql.jdbc2.ResultWrapper  (id=20900)	
		rs	org.postgresql.jdbc42.Jdbc42ResultSet  (id=20895)	
			fields	org.postgresql.core.Field[1]  (id=20803)	
				[0]	org.postgresql.core.Field  (id=20827)	
					columnLabel	"nextval" (id=20834)	
					oid	20	
			rows	java.util.ArrayList<E>  (id=20823)	
				[0]	(id=20821)	
					[0]	(id=20822)	
						[0]	0	
						[1]	0	
						[2]	0	
						[3]	0	
						[4]	0	
						[5]	0	
						[6]	0	
						[7]	1	
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeQuery() line: 353	
        if (!executeWithFlags(0))
            throw new PSQLException(GT.tr("No results were returned by the query."), PSQLState.NO_DATA);
/n,
        if (result.getNext() != null)
            throw new PSQLException(GT.tr("Multiple ResultSets were returned by the query."), PSQLState.TOO_MANY_RESULTS);
/ TODO 
/ niet te verwarren met .next()
/n,
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 505	
            ResultSet resultSet = ps.executeQuery();
            return registerResultSet(resultSet);		/ TODO register waarin?
...
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 73	
				rs = statement.executeQuery();
/d,
rs	org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7  (id=21064)	
	resultSet	org.postgresql.jdbc42.Jdbc42ResultSet  (id=20895)	
		fields	org.postgresql.core.Field[1]  (id=20803)	
		rows	java.util.ArrayList<E>  (id=20823)	
		statement	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=20789)	

			postExtract( rs, statement );
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.postExtract(java.sql.ResultSet, java.sql.Statement) line: 231	
		if ( rs != null ) {
			jdbcCoordinator.getResourceRegistry().register( rs, st );
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.register(java.sql.ResultSet, java.sql.Statement) line: 204	
				resultSets = new HashSet<ResultSet>();
				xref.put( statement, resultSets );
			resultSets.add( resultSet );
				
this	org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl  (id=21175)	
	xref	java.util.HashMap<K,V>  (id=21177)	
		[0]	java.util.HashMap$Node<K,V>  (id=21181)	
			key	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=20773)	
			value	java.util.HashSet<E>  (id=21190)	
				[0]	org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7  (id=21064)	
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 76	
				rs = statement.executeQuery();
		postExtract( rs, statement );
/d,
			return rs;
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96	
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/d,
						try {
							rs.next();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).next() line: 2682	
            return resultSet.next();
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).next() line: 1937	

this	org.postgresql.jdbc42.Jdbc42ResultSet  (id=20895)	
	fields	org.postgresql.core.Field[1]  (id=20803)	
	rows	java.util.ArrayList<E>  (id=20823)	
	statement	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=20789)	

        if (current_row + 1 >= rows.size())
/n,
-1+1>=1 NIET,
        else
        {
            current_row++;
        }

        initRowBuffer();
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).initRowBuffer() line: 3113	
        this_row = (byte[][]) rows.get(current_row);
[[0, 0, 0, 0, 0, 0, 0, 1]]
        // We only need a copy of the current row if we're going to
        // modify it via an updatable resultset.
        if (resultsetconcurrency == ResultSet.CONCUR_UPDATABLE) {
/n,
        } else {
            rowBuffer = null;
...
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 99	
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();	/ heeft result in rs.this_row gezet	,
											/ iedere rs.next() doet dat, want er is ook rs.rows()	, waar alle rows in staan,
/d,
rs	org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7  (id=21064)	
	resultSet	org.postgresql.jdbc42.Jdbc42ResultSet  (id=20895)	
		fields	org.postgresql.core.Field[1]  (id=20803)	
		rows	java.util.ArrayList<E>  (id=20823)	
		this_row	(id=20821)	[[0, 0, 0, 0, 0, 0, 0, 1]]			<- result van next()

/ Intermezzo

/ normaal doe je, 
while(rs.next()){
	Long l=rs.getLong(1)
	
/ rs.getLong(1) gaan we zo doen, maar rs.next() zet dus het volgende elem uit rs.rows() in rs.this_row, en WH rs.getLong(1) pakt deze op,

/ Einde Intermezzo

							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
							value.initialize( rs, 1 );
/s,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.initialize(java.sql.ResultSet, long) line: 280	
			long value = resultSet.getLong( 1 );
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).getLong(int) line: 1540	
         lock();
             return resultSet.getLong(columnIndex);
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).getLong(int) line: 2188	
        checkResultSet(columnIndex);
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).checkResultSet(int) line: 2929
		...
        checkColumnIndex(column);					/= if ( column < 1 || column > fields.length )
        wasNullFlag = (this_row[column - 1] == null);
/t,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).getLong(int) line: 2192	
        checkResultSet(columnIndex);
/d
       if (wasNullFlag)
            return 0; // SQL NULL			/ TODO 
/n,
        if (isBinary(columnIndex)) {        /= return fields[column - 1].getFormat() == Field.BINARY_FORMAT;
														/ GEEN text format,
/j,
            int col = columnIndex - 1;
            int oid = fields[col].getOID();
            if (oid == Oid.INT8) {
/j,
                return ByteConverter.int8(this_row[col], 0);
/s,
org.postgresql.util.ByteConverter.int8(byte[], int) line: 29	
        return
            ((long)(bytes[idx+0] & 255) << 56) +
            ((long)(bytes[idx+1] & 255) << 48) +
            ((long)(bytes[idx+2] & 255) << 40) +
            ((long)(bytes[idx+3] & 255) << 32) +
            ((long)(bytes[idx+4] & 255) << 24) +
            ((long)(bytes[idx+5] & 255) << 16) +
            ((long)(bytes[idx+6] & 255) <<  8) +
            (bytes[idx+7] & 255);
/ TODO 
/ Waarom cast (long) voor de voorste 7 bytes?
bytes=[0, 0, 0, 0, 0, 0, 0, 1]
/t,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.initialize(java.sql.ResultSet, long) line: 284	
			long value = resultSet.getLong( 1 );
/d,
			if ( resultSet.wasNull() ) {			/ see res.wasNullFlag
				value = defaultValue;
			}
/n,

			return initialize( value );
/s,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.initialize(long) line: 275	
			this.value = value;
			return this;
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 104	
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
							value.initialize( rs, 1 );
BasicHolder[java.lang.Long[1]]
							return value;
					finally {
						session.getJdbcCoordinator().afterStatementExecution();
...
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.afterStatementExecution() line: 281	
			getLogicalConnection().afterStatement();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.afterStatement() line: 125	
				releaseConnection();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.releaseConnection() line: 172				
			jdbcConnectionAccess.releaseConnection( physicalConnection );
/s,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.releaseConnection(java.sql.Connection) line: 397	
				connectionProvider.closeConnection( connection );
/s,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.closeConnection(java.sql.Connection) line: 127	
		connection.close();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).close() line: 253	
      returnConnection(false);
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).returnConnection(boolean) line: 264	
         if (!error)
         {
            mc.closeHandle(this);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).closeHandle(org.jboss.jca.adapters.jdbc.WrappedConnection) line: 541	
      returnHandle(handle, false);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).returnHandle(org.jboss.jca.adapters.jdbc.WrappedConnection, boolean) line: 551	
         ce = new ConnectionEvent(this, ConnectionEvent.CONNECTION_CLOSED);

      ce.setConnectionHandle(handle);

      for (ConnectionEventListener cel : cels)
            cel.connectionClosed(ce);
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.connectionClosed(javax.resource.spi.ConnectionEvent) line: 636	
      if (this.getManagedConnection() != (ManagedConnection)ce.getSource())
/n,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2579e05e

            this.getCachedConnectionManager().unregisterConnection(this.getConnectionManager(), this,
                                                                   ce.getConnectionHandle());
/s,
org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl.unregisterConnection(org.jboss.jca.core.api.connectionmanager.listener.ConnectionCacheListener, org.jboss.jca.core.api.connectionmanager.listener.ConnectionListener, java.lang.Object) line: 351	
/=
   public void unregisterConnection(org.jboss.jca.core.api.connectionmanager.listener.ConnectionCacheListener cm,
                                    org.jboss.jca.core.api.connectionmanager.listener.ConnectionListener cl,
                                    Object connection)
this	org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl  (id=21412)	
cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=20761)	
cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20760)	
connection	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21065)	

      KeyConnectionAssociation key = peekMetaAwareObject();
/s,
      LinkedList<KeyConnectionAssociation> stack = currentObjects.get();
      if (stack != null && !stack.isEmpty())
      {
         return stack.getLast();
/t,
key	org.jboss.jca.core.connectionmanager.ccm.KeyConnectionAssociation  (id=21439)	
	cmToConnectionsMap	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21441)	
		[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=21455)	
			key	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=20761)	
			value	java.util.concurrent.CopyOnWriteArrayList<E>  (id=21456)	
				[0]	org.jboss.jca.core.connectionmanager.ConnectionRecord  (id=21459)	
					connection	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21065)	
					connectionListener	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20760)	
		cachedConnectionManager	org.jboss.msc.value.InjectedValue<T>  (id=21504)	
			value	org.jboss.msc.value.ImmediateValue<T>  (id=21576)	
					currentObjects	java.lang.ThreadLocal<T>  (id=21417)	
						nextHashCode	java.util.concurrent.atomic.AtomicInteger  (id=21436)	
					objectToConnectionManagerMap	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21616)	
					transactionIntegration	org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl  (id=21617)	

      ConcurrentMap<ConnectionCacheListener, CopyOnWriteArrayList<ConnectionRecord>> cmToConnectionsMap =
         key.getCMToConnectionsMap();

      CopyOnWriteArrayList<ConnectionRecord> conns = cmToConnectionsMap.get(cm);

      // Note iterator of CopyOnWriteArrayList does not support remove method
      // We use here remove on CopyOnWriteArrayList directly
      for (ConnectionRecord connectionRecord : conns)
      {
         if (connectionRecord.getConnection() == connection)
         {
            conns.remove(connectionRecord);
            return;	
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.connectionClosed(javax.resource.spi.ConnectionEvent) line: 656	
            this.getCachedConnectionManager().unregisterConnection(this.getConnectionManager(), this,
                                                                   ce.getConnectionHandle());
/d,
         if (wasFreed(ce.getConnectionHandle()))
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.wasFreed(java.lang.Object) line: 836

this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20760)	
	connectionHandles	java.util.concurrent.CopyOnWriteArraySet<E>  (id=21852)			/ gaat hieruit worden verwijderd	,
	
      if (handle != null)
      {
         // Unregister the handle
         unregisterConnection(handle);	
/ handle=org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7@6eac7a52

      // Return if the managed connection was just freed
      return isManagedConnectionFree();		 
/s,
   //Important method!!
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.isManagedConnectionFree() line: 820	
      if (isTrackByTx() && transactionSynchronization != null)
/j,
         return false;
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.connectionClosed(javax.resource.spi.ConnectionEvent) line: 681	
         if (wasFreed(ce.getConnectionHandle()))
/n,
/ Intermezzo

/ als /j, dan,
         if (wasFreed(ce.getConnectionHandle()))
         {
            boolean success = delist();
/ TODO
/ TxConnectionListener.delist()
/ INTERESSANTE METHOD

            if (success || (tracking != null && !tracking.booleanValue()))
            {
               this.getConnectionManager().returnManagedConnection(this, false);

/ er zijn TxConnectionListener.enlist() en .delist(), 
/ maar er is ook TxConnectionListener$TransactionSynchronization.enlist(), 	en .beforeCompletion() en .afterCompletion(),
/ TODO


/ Einde Intermezzo


org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).returnHandle(org.jboss.jca.adapters.jdbc.WrappedConnection, boolean) line: 602	
      for (ConnectionEventListener cel : cels)
      {

         if (!error)
         {
            cel.connectionClosed(ce);
/d,
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).returnConnection(boolean) line: 305	
         if (!error)
         {
            mc.closeHandle(this);
/d,
         }
      mc = null;
      dataSource = null;
...
/t,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 41	
		IntegralDataTypeHolder value = callback.getNextValue();
/d,
value	org.hibernate.id.IdentifierGeneratorHelper$BasicHolder  (id=21287)	
	exactType	java.lang.Class<T> (java.lang.Long) (id=20537)	
	value	1	
		if ( incrementSize > 0 ) {
			while ( value.lt( 1 ) ) {
				value = callback.getNextValue();
/n,
/ TODO
		lastSourceValue = value;
		return value.makeValue();	/ value.value
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 102	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/d,
			return performSave( entity, generatedId, persister, false, anything, source, true );

/ Intermezzo

/ we zijn nog steeds in,


org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();								<- 
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
/cb,
org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
        final Transaction tx = tm.getTransaction();

        if (tx == null) {
            return invokeInOurTx(invocation, tm, component);
/cb,
org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
                    return required(invocation, component, timeoutInSeconds);



/ Einde Intermezzo

/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 159
	
			key = source.generateEntityKey( id, persister );
key	org.hibernate.engine.spi.EntityKey  (id=22111)	
	hashCode	630	
	identifier	java.lang.Long  (id=21960)		1
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	

	Object old = source.getPersistenceContext().getEntity( key );
null	
source=SessionImpl	, 
getEntity()=StatefulPersistenceContext.entitiesByKey.get( key )

			persister.setIdentifier( entity, id, source );
/ set id uit db in entity; in entity was id null, wel props zoals name="clothing"
	
		return performSaveOrReplicate(
				entity,
				key,
				persister,
				useIdentityColumn,
				anything,
				source,
				requiresImmediateIdAccess
		);
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 229	

		boolean inTxn = source.isTransactionInProgress();
/s,
org.hibernate.internal.SessionImpl.isTransactionInProgress() line: 500	
		checkTransactionSynchStatus();
/s,
org.hibernate.internal.SessionImpl.checkTransactionSynchStatus() line: 2218	
		pulseTransactionCoordinator();
/s,
org.hibernate.internal.SessionImpl.pulseTransactionCoordinator() line: 2224	
			transactionCoordinator.pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 136	
		if ( synchronizationRegistered ) {
/j,
			return;
		}
/ NIET
		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
			log.trace( "JTA platform says we cannot currently resister synchronization; skipping" );
			return;
		}

		joinJtaTransaction();
/ Einde NIET
/t,

	
/ Intermezzo

/ als synchronizationRegistered==false, dan wordt joinJtaTransaction()	, en wordt synchronizationRegistered=true set,

	/**
	 * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the
	 * RegisteredSynchronization with the JTA system
	 */
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction(){
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
		synchronizationRegistered = true;
		
synchronization	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21575)	
	synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=21574)	
		target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=21559)	
			jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=21576)	
				jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=22253)	
				serviceRegistry	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl  (id=21219)	
				synchronizationStrategy	org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy  (id=21577)	
				tmSynchronizationStrategy	org.hibernate.engine.transaction.jta.platform.internal.TransactionManagerBasedSynchronizationStrategy  (id=22303)	
				transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=21016)	
			synchronizationRegistry	org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl  (id=22279)	
			transactionCoordinatorBuilder	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl  (id=21560)	
			transactionCoordinatorOwner	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=22280)	
/cb,
	/**
	 * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the
	 * RegisteredSynchronization with the JTA system
	 */
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );		<-
		getSynchronizationCallbackCoordinator().synchronizationRegistered();

/ vs,

com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionStatus() line: 157	
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionStatus() line: 91	
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 236	
         if (mcf.getTransactionSynchronizationRegistry() != null)
            status = mcf.getTransactionSynchronizationRegistry().getTransactionStatus();
/cb,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransactionActive() line: 1928	
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkStatus() line: 1943	
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransaction() line: 1917	
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).checkTransaction() line: 1457	
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 495	

org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization
/ is in (in preJcaSync),
/ deze calls, heeft delegate,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionStatus() line: 91	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionStatus() line: 157	


/ TODO

/ Einde Intermezzo

/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 235
	
		boolean inTxn = source.isTransactionInProgress();
/d,

/ 1	. in de pc, (later in de db)
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 542
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,						<-
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		entityEntryContext.addEntityEntry( entity, e ); 		/ in e zit de id, (en de persister)
/s,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 123	
			else {
				if ( nonEnhancedEntityXref == null ) {
					nonEnhancedEntityXref = new IdentityHashMap<Object, ManagedEntity>();
				}
				managedEntity = new ManagedEntityImpl( entity );
				nonEnhancedEntityXref.put( entity, managedEntity );
			}
		}

		// associate the EntityEntry with the entity
		managedEntity.$$_hibernate_setEntityEntry( entityEntry );
		
		// finally, set up linking and count
		if ( tail == null ) {
			assert head == null;
			// Protect against stale data in the ManagedEntity and nullify previous/next references.
			managedEntity.$$_hibernate_setPreviousManagedEntity( null );
			managedEntity.$$_hibernate_setNextManagedEntity( null );
			head = managedEntity;
			tail = head;
			count = 1;
		}
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 249	
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
/d,
		
/ 2	. in de db (eerder in de pc)	,
	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
[0]	org.hibernate.collection.internal.PersistentSet  (id=22888)	
	[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
		bids	java.util.HashSet<E>  (id=22898)	
		categories	java.util.HashSet<E>  (id=22899)	
			[0]	org.arquillian.jpa.study2.model.Category  (id=22915)		/ heeft id null	, heeft nog niet,
			[1]	org.arquillian.jpa.study2.model.Category  (id=21961)		/ heeft id 1, onze Category	,
			id	null						/ heeft nog niet,
		name	"dress" (id=22900)	
[1]	"clothing" (id=21970)	
[2]	java.lang.Integer  (id=22871)	

		Type[] types = persister.getPropertyTypes();
types	org.hibernate.type.Type[3]  (id=22874)	
	[0]	org.hibernate.type.SetType  (id=22875)	
	[1]	org.hibernate.type.StringType  (id=22876)	
	[2]	org.hibernate.type.IntegerType  (id=22877)	

		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source ); 	
/ versioning 
/ TODO
		
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/ we hebben bs set in org.hibernate.engine.spi.ActionQueue	,

		return id;
...
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
			return performSave( entity, generatedId, persister, false, anything, source, true );
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 133	
			case TRANSIENT: {
				entityIsTransient( event, createCache );
				break;
			}
...
/t,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 776	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
			listener.onPersist( event );
		}
/t,
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 749	
		firePersist( new PersistEvent( entityName, object, this ) );
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1153	
			internalGetSession().persist( entity );
/d,
/t,
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 22	
		em.persist(entity);
/d,
...	/ de keten terug, 
/t,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            try {
                return invocation.proceed();
/d,
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
/s,
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 85	
            final int txStatus = tx.getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 353	
		if (_theTransaction != null)	/ BasicAction: 0:ffffc0a87b73:-12155dc1:5ce982bd:7b status: ActionStatus.RUNNING
		{
			status = StatusConverter.convert(_theTransaction.status());
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 44	
		switch (status)
		{
		case ActionStatus.RUNNING:
			return javax.transaction.Status.STATUS_ACTIVE;
/t,
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 86	
            final int txStatus = tx.getStatus();
/d,

/ Intermezzo

public class TransactionImple implements javax.transaction.Transaction,
		com.arjuna.ats.jta.transaction.Transaction
{
	public TransactionImple(int timeout)
	{
		_theTransaction = new AtomicAction();
		_theTransaction.begin(timeout);

	public void commit() throws javax.transaction.RollbackException,
			javax.transaction.HeuristicMixedException,
			javax.transaction.HeuristicRollbackException,
			java.lang.SecurityException, javax.transaction.SystemException,
			java.lang.IllegalStateException
	{
			int status = _theTransaction.end(true);

	public void rollback() throws java.lang.IllegalStateException,
			java.lang.SecurityException, javax.transaction.SystemException
	{
			int outcome = _theTransaction.cancel(); // use cancel of
			// TwoPhaseCoordinator to
			// avoid thread changes.
		

/ Einde Intermezzo

            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 88	
        transactionManager.commit() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 119	
		TransactionImple theTransaction = TransactionImple.getTransaction();
		theTransaction.commitAndDisassociate();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	

				switch (_theTransaction.commit(true))
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
		int status = super.end(report_heuristics);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 83	
		if (parent() != null)
/n, 
/ de tx is niet nested,
        if(status() != ActionStatus.ABORT_ONLY || TxControl.isBeforeCompletionWhenRollbackOnly())
/j,
        {
            canEnd = beforeCompletion();
/s,
	/**
	 * Drive beforeCompletion participants.
	 * 
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 310	
	        if (!_beforeCalled)		/ als beforeCompletion nog niet is called,
	        {
	            _beforeCalled = true;

	            /*
	             * If we have a synchronization list then we must be top-level.
	             */
                if (_synchs == null) {
/n,

this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=23016)	
	_synchs	java.util.TreeSet<E>  (id=23074)	
		[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=23077)	
			_isInterposed	true	
			_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=23085)	
				jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=23107)	
				jcaSyncs	java.util.ArrayList<E>  (id=23108)	
					[0]	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=23155)	
						enlisted	java.util.ArrayList<E>  (id=23159)	
							[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=20759)	
				preJcaSyncs	java.util.ArrayList<E>  (id=23109)	
					[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=23144)	
						synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=22124)	
					[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=23044)	
						manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=20755)	
						scopedPuName	"48683b37-59c6-4d30-8fcc-ef09d3136c9a.war#arquillian-jpa-study2-persistence-unit" (id=23149)	
						transactionDisassociatedFromApplication	true	
				tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20725)	
			_theUid	com.arjuna.ats.arjuna.common.Uid  (id=23086)	

                } else {
	                /*
	                 * We must always call afterCompletion() methods, so just catch (and
	                 * log) any exceptions/errors from beforeCompletion() methods.
	                 *
	                 * If one of the Syncs throws an error the Record wrapper returns false
	                 * and we will rollback. Hence we don't then bother to call beforeCompletion
	                 * on the remaining records (it's not done for rollabcks anyhow).
	                 *
	                 * Since Synchronizations may register other Synchronizations, we can't simply
	                 * iterate the collection. Instead we work from an ordered copy, which we periodically
	                 * check for freshness. The addSynchronization method uses _currentRecord to disallow
	                 * adding records in the part of the array we have already traversed, thus all
	                 * Synchronization will be called and the (jta only) rules on ordering of interposed
	                 * Synchronization will be respected.
	                 */
	                synchronized (_synchs) {
	                    copiedSynchs = (SynchronizationRecord[])_synchs.toArray(new SynchronizationRecord[] {});
	                }
/ van TreeSet naar Array	,

copiedSynchs	com.arjuna.ats.arjuna.coordinator.SynchronizationRecord[1]  (id=23318)	
	[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=23077)	
		_isInterposed	true	
		_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=23085)	
			jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=23107)	
			jcaSyncs	java.util.ArrayList<E>  (id=23108)	
			preJcaSyncs	java.util.ArrayList<E>  (id=23109)	
			tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20725)	
		_theUid	com.arjuna.ats.arjuna.common.Uid  (id=23086)	

	                while( (lastIndexProcessed < _synchs.size()-1) && !problem) {
/j,
_synchs.size()=1, en _synchs.size()-1 is een index die bij 0 begint	,
-1<0
	                    lastIndexProcessed = lastIndexProcessed+1;
0
	                    _currentRecord = copiedSynchs[lastIndexProcessed];
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=23077)	

	                    try
	                    {
	                        problem = !_currentRecord.beforeCompletion();
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 70	
this	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=23077)	
	_isInterposed	true	
	_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=23085)	
	_theUid	com.arjuna.ats.arjuna.common.Uid  (id=23086)	

		_theSynch.beforeCompletion();
/s,
    /**
     * Exceptions from Synchronizations that are registered with this TSR are not trapped for before completion. This is because
     * an error in a Sync here should result in the transaction rolling back.
     *
     * You can see that in effect in these classes:
     * https://github.com/jbosstm/narayana/blob/5.0.4.Final/ArjunaCore/arjuna/classes
     * /com/arjuna/ats/arjuna/coordinator/TwoPhaseCoordinator.java#L91
     * https://github.com/jbosstm/narayana/blob/5.0.4.Final/ArjunaJTA
     * /jta/classes/com/arjuna/ats/internal/jta/resources/arjunacore/SynchronizationImple.java#L76
     */
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 107	
        int lastIndexProcessed = 0;
        while ((lastIndexProcessed < preJcaSyncs.size())) {
            Synchronization preJcaSync = preJcaSyncs.get(lastIndexProcessed);
            preJcaSync.beforeCompletion();
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 35	
		log.trace( "Registered JTA Synchronization : beforeCompletion()" );
		synchronizationCallbackCoordinator.beforeCompletion();
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 42	

		target.beforeCompletion();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
			transactionCoordinatorOwner.beforeTransactionCompletion();
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
		owner.beforeTransactionCompletion();
/s,
org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2338	
	
/ Intermezzo

org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2338
		flushBeforeTransactionCompletion();
		actionQueue.beforeTransactionCompletion();
/cb,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	


/ Einde Intermezzo

		flushBeforeTransactionCompletion();
/s,
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2960	
		boolean flush = isTransactionFlushable() && managedFlushChecker.shouldDoManagedFlush( this );
/s,
org.hibernate.internal.SessionImpl.isTransactionFlushable() line: 2975	
		if ( currentHibernateTransaction == null ) {
			// assume it is flushable - CMT, auto-commit, etc
			return true;
		}
/n,
this	org.hibernate.internal.SessionImpl  (id=20753)	
	currentHibernateTransaction	org.hibernate.engine.transaction.internal.TransactionImpl  (id=21306)	
		transactionDriverControl	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=22127)	
			jtaTransactionAdapter	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl  (id=23521)	
				transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=20713)	
					transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=20726)	

		final TransactionStatus status = currentHibernateTransaction.getStatus();
/s,
org.hibernate.engine.transaction.internal.TransactionImpl.getStatus() line: 99	
		return transactionDriverControl.getStatus();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl.getStatus() line: 421
			return jtaTransactionAdapter.getStatus();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.getStatus() line: 90	
			return StatusTranslator.translate( transactionManager.getStatus() );
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
        return transactionManager.getStatus() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
		TransactionImple theTransaction = TransactionImple.getTransaction();
		else
			return theTransaction.getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 351	
		if (_theTransaction != null)
		{
			status = StatusConverter.convert(_theTransaction.status());
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 41	
		switch (status)		/ _theTransaction.actionStatus=ActionStatus.RUNNING 
		{
		case ActionStatus.RUNNING:
			return javax.transaction.Status.STATUS_ACTIVE;
...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.getStatus() line: 90	
			return StatusTranslator.translate( transactionManager.getStatus() );
/pd,
/s,
org.hibernate.resource.transaction.backend.jta.internal.StatusTranslator.translate(int) line: 23	
		TransactionStatus transactionStatus = null;
		switch ( status ) {
			case Status.STATUS_ACTIVE:
				transactionStatus = TransactionStatus.ACTIVE;
				break;	
...
/t,
org.hibernate.internal.SessionImpl.isTransactionFlushable() line: 2980	
		final TransactionStatus status = currentHibernateTransaction.getStatus();
/d,
		return status == TransactionStatus.ACTIVE || status == TransactionStatus.COMMITTING;
/t,
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2960	
		boolean flush = isTransactionFlushable() && managedFlushChecker.shouldDoManagedFlush( this );
/pd,
/s,
org.hibernate.jpa.internal.EntityManagerImpl$ManagedFlushCheckerImpl.shouldDoManagedFlush(org.hibernate.internal.SessionImpl) line: 262	
			return !session.isClosed()
					&& !isManualFlushMode( session.getFlushMode() );
/s,
org.hibernate.internal.SessionImpl.getFlushMode() line: 1486	
		checkTransactionSynchStatus();		/ is de RegisteredSynchronization registered with the JTA system? 
														/ Zo niet, dan moet joinJtaTransaction()	,

/ Intermezzo

/s,
org.hibernate.internal.SessionImpl.checkTransactionSynchStatus() line: 2218	
		pulseTransactionCoordinator();
/s,
org.hibernate.internal.SessionImpl.pulseTransactionCoordinator() line: 2224	
			transactionCoordinator.pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 132	
		if ( synchronizationRegistered ) {
			return;
		}
/j,
/ NU NIET:
		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
			log.trace( "JTA platform says we cannot currently resister synchronization; skipping" );
			return;
		}

		joinJtaTransaction();
	}

	/**
	 * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the
	 * RegisteredSynchronization with the JTA system
	 */
	private void joinJtaTransaction() {
/ Einde NU NIET,
	
/ Dus joinJtaTransaction() is een hibernate method, 
/ klopt, deze moet in beforeCommit flush,

/ Einde Intermezzo
/t,
org.hibernate.internal.SessionImpl.getFlushMode() line: 1487	
		checkTransactionSynchStatus();
		return flushMode;
AUTO
/t,
org.hibernate.jpa.internal.EntityManagerImpl$ManagedFlushCheckerImpl.shouldDoManagedFlush(org.hibernate.internal.SessionImpl) line: 263	
			return !session.isClosed()
					&& !isManualFlushMode( session.getFlushMode() );
/t,
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2962	
		boolean flush = isTransactionFlushable() && managedFlushChecker.shouldDoManagedFlush( this );
/d,
		try {
			if ( flush ) {
				managedFlush();
/s,
org.hibernate.internal.SessionImpl.managedFlush() line: 460	
		flush();
/s,
org.hibernate.internal.SessionImpl.flush() line: 1275	
		FlushEvent flushEvent = new FlushEvent( this );
		for ( FlushEventListener listener : listeners( EventType.FLUSH ) ) {
			listener.onFlush( flushEvent );
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 29	
		final EventSource source = event.getSession();
SessionImpl,
		final PersistenceContext persistenceContext = source.getPersistenceContext();
/ deze checks ook: checkTransactionSynchStatus()

		if ( persistenceContext.getNumberOfManagedEntities() > 0 ||	
/= persistenceContext.entityEntryContext.(getNumberOfManagedEntities()=count)
				persistenceContext.getCollectionEntries().size() > 0 ) {
/j,

				source.getEventListenerManager().flushStart();
/ niets,

				flushEverythingToExecutions( event );
/s,
	/**
	 * Coordinates the processing necessary to get things ready for executions
	 * as db calls by preping the session caches and moving the appropriate
	 * entities and collections to their respective execution queues.
	 *
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 69

		EventSource session = event.getSession();

		final PersistenceContext persistenceContext = session.getPersistenceContext();
persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=21318)	
	entitiesByKey	java.util.HashMap<K,V>  (id=22130)	
		[0]	java.util.HashMap$Node<K,V>  (id=23587)	
			key	org.hibernate.engine.spi.EntityKey  (id=23600)	
				hashCode	630	
				identifier	java.lang.Long  (id=21960)	1
				persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
			value	org.arquillian.jpa.study2.model.Category  (id=21961)	
				id	java.lang.Long  (id=21960)	
				items	org.hibernate.collection.internal.PersistentSet  (id=22888)	
					[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
						bids	java.util.HashSet<E>  (id=22898)	
						categories	java.util.HashSet<E>  (id=22899)	
							[0]	org.arquillian.jpa.study2.model.Category  (id=22915)	
								id	null	
								items	java.util.HashSet<E>  (id=22966)	
								name	"red" (id=22967)	
								version	0	
							[1]	org.arquillian.jpa.study2.model.Category  (id=21961)	
								id	java.lang.Long  (id=21960)	
								items	org.hibernate.collection.internal.PersistentSet  (id=22888)	
								name	"clothing" (id=21970)	
						id	null	
						name	"dress" (id=22900)	
						version	0	
				name	"clothing" (id=21970)	
				version	0	

		session.getInterceptor().preFlush( new LazyIterator( persistenceContext.getEntitiesByKey() ) );
/ .preFlush doet niets,
		
/ Intermezzo

org.hibernate.internal.util.collections.LazyIterator.<init>(java.util.Map) line: 24	
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 72	
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 38	
org.hibernate.internal.SessionImpl.flush() line: 1282	
org.hibernate.internal.SessionImpl.managedFlush() line: 465	
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963	
org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	
org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	


/ Einde Intermezzo	

		prepareEntityFlushes( session, persistenceContext );
/ doet niets,	
/s
	/**
	 * process cascade save/update at the start of a flush to discover
	 * any newly referenced entity that must be passed to saveOrUpdate(),
	 * and also apply orphan delete
	 */
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).prepareEntityFlushes(org.hibernate.event.spi.EventSource, org.hibernate.engine.spi.PersistenceContext) line: 136	

		for ( Map.Entry<Object,EntityEntry> me : persistenceContext.reentrantSafeEntityEntries() ) {

/ zojuist hadden we entitiesByKey, nu entityEntryContext,

persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=21318)	
	entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=22840)	
		nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=22845)	
			[0]	java.util.AbstractMap$SimpleEntry<K,V>  (id=23982)	
				key	org.arquillian.jpa.study2.model.Category  (id=21961)	
				value	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=22849)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=22883)	
						id	java.lang.Long  (id=21960)	
						loadedState	java.lang.Object[3]  (id=22870)	
						version	java.lang.Integer  (id=22871)	
					entityInstance	org.arquillian.jpa.study2.model.Category  (id=21961)	
					next	null	
					previous	null	
		reentrantSafeEntries	java.util.Map$Entry<K,V>[0]  (id=23974)		[]
		
/s,
	/**
	 * The main bugaboo with IdentityMap that warranted this class in the first place.
	 *
	 * Return an array of all the entity/EntityEntry pairs in this context.  The array is to make sure
	 * that the iterators built off of it are safe from concurrency/reentrancy
	 *
org.hibernate.engine.internal.EntityEntryContext.reentrantSafeEntityEntries() line: 312	
		if ( dirty ) {
			reentrantSafeEntries = new EntityEntryCrossRefImpl[count];
			int i = 0;
			ManagedEntity managedEntity = head;
			while ( managedEntity != null ) {
				reentrantSafeEntries[i++] = new EntityEntryCrossRefImpl(
						managedEntity.$$_hibernate_getEntityInstance(),
						managedEntity.$$_hibernate_getEntityEntry()
				);
				managedEntity = managedEntity.$$_hibernate_getNextManagedEntity();
			}
			dirty = false;
		}
		return reentrantSafeEntries;

this	org.hibernate.engine.internal.EntityEntryContext  (id=22840)	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=21318)	
		entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=22840)	
			reentrantSafeEntries	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl[1]  (id=24134)	
				[0]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=24135)	
					key	org.arquillian.jpa.study2.model.Category  (id=21961)	
					value	org.hibernate.engine.internal.MutableEntityEntry  (id=22883)	
						id	java.lang.Long  (id=21960)	
						loadedState	java.lang.Object[3]  (id=22870)	
						persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
						rowId	null	
						version	java.lang.Integer  (id=22871)	

			EntityEntry entry = (EntityEntry) me.getValue();
			Status status = entry.getStatus();
			if ( status == Status.MANAGED || status == Status.SAVING || status == Status.READ_ONLY ) {
				cascadeOnFlush( session, entry.getPersister(), me.getKey(), anything );
			}
/ niets,	
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 78	
		prepareEntityFlushes( session, persistenceContext );
/d,
		// we could move this inside if we wanted to
		// tolerate collection initializations during
		// collection dirty checking:
		prepareCollectionFlushes( persistenceContext );
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).prepareCollectionFlushes(org.hibernate.engine.spi.PersistenceContext) line: 178	

		// Initialize dirty flags for arrays + collections with composite elements
		// and reset reached, doupdate, etc.

		LOG.debug( "Dirty checking collections" );

		for ( Map.Entry<PersistentCollection,CollectionEntry> entry :
				IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {
				
this	org.hibernate.jpa.event.internal.core.JpaFlushEventListener  (id=23577)	
entry	org.hibernate.internal.util.collections.IdentityMap$IdentityMapEntry<K,V>  (id=24290)	
	key	org.hibernate.collection.internal.PersistentSet  (id=22888)	
		[0]	org.arquillian.jpa.study2.model.Item  (id=22896)		/ een dress, die in 2 Categorys valt: self ("clothing") en "red"	,		serialVersionUID	1	
			bids	java.util.HashSet<E>  (id=22898)	
			categories	java.util.HashSet<E>  (id=22899)	
				[0]	org.arquillian.jpa.study2.model.Category  (id=22915)		/ "red"
				[1]	org.arquillian.jpa.study2.model.Category  (id=21961)		/ self, "clothing"
			id	null	
			name	"dress" (id=22900)	
			version	0	
	value	org.hibernate.engine.spi.CollectionEntry  (id=24263)	
		LOG	org.jboss.logging.JBossLogManagerLogger  (id=24270)	
		currentKey	null	
		currentPersister	null	
		dorecreate	false	
		doremove	false	
		doupdate	false	
		fromMerge	false	
		ignore	false	
		loadedKey	null	
		loadedPersister	null	
		processed	false	
		reached	false	
		role	null	
		snapshot	java.util.HashMap<K,V>  (id=24275)	

			entry.getValue().preFlush( entry.getKey() );
/s,
org.hibernate.engine.spi.CollectionEntry.preFlush(org.hibernate.collection.spi.PersistentCollection) line: 175	

		if ( loadedKey == null && collection.getKey() != null ) {
/n,
/ TODO (collection.key bestaat helemaal niet),

			loadedKey = collection.getKey();
		}

		boolean nonMutableChange = collection.isDirty()
/n,
				&& getLoadedPersister() != null
				&& !getLoadedPersister().isMutable();
			

		dirty( collection );
/ doet niets, 
/ TODO
		setReached( false );
		setProcessed( false );

		setDoupdate( false );
		setDoremove( false );
		setDorecreate( false );
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 83	
		prepareCollectionFlushes( persistenceContext );
/d,
		// now, any collections that are initialized
		// inside this block do not get updated - they
		// are ignored until the next flush

		persistenceContext.setFlushing( true );
/ TODO
		try {
			int entityCount = flushEntities( event, persistenceContext );
/s,
	/**
	 * 1. detect any dirty entities
	 * 2. schedule any entity updates
	 * 3. search out any reachable collections
	 */
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEntities(org.hibernate.event.spi.FlushEvent, org.hibernate.engine.spi.PersistenceContext) line: 216
	
		final EventSource source = event.getSession();
		final Iterable<FlushEntityEventListener> flushListeners = source.getFactory().getServiceRegistry()
				.getService( EventListenerRegistry.class )
				.getEventListenerGroup( EventType.FLUSH_ENTITY )
				.listeners();

		// Among other things, updateReachables() will recursively load all
		// collections that are moving roles. This might cause entities to
		// be loaded.
		// So this needs to be safe from concurrent modification problems.
		final Map.Entry<Object,EntityEntry>[] entityEntries = persistenceContext.reentrantSafeEntityEntries();
		final int count = entityEntries.length;

		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {

			// Update the status of the object and if necessary, schedule an update

			EntityEntry entry = me.getValue();
			Status status = entry.getStatus();

			if ( status != Status.LOADING && status != Status.GONE ) {
				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
me	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=24135)	
	key	org.arquillian.jpa.study2.model.Category  (id=21961)	
	value	org.hibernate.engine.internal.MutableEntityEntry  (id=22883)	
		compressedState	22	
		id	java.lang.Long  (id=21960)	
		loadedState	java.lang.Object[3]  (id=22870)	
entry==me.value
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
listener=org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener@2a5a9ed7
/s,
	/**
	 * Flushes a single entity's state to the database, by scheduling
	 * an update action, if necessary
	 */
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).onFlushEntity(org.hibernate.event.spi.FlushEntityEvent) line: 133	
		final Object entity = event.getEntity();
		final EntityEntry entry = event.getEntityEntry();
		final EventSource session = event.getSession();
		final EntityPersister persister = entry.getPersister();
		final Status status = entry.getStatus();
		final Type[] types = persister.getPropertyTypes();
[org.hibernate.type.SetType(org.arquillian.jpa.study2.model.Category.items), org.hibernate.type.StringType@4fc47f39, org.hibernate.type.IntegerType@6b3ff754]

		final Object[] values = getValues( entity, entry, mightBeDirty, session );
values	java.lang.Object[3]  (id=24430)	
	[0]	org.hibernate.collection.internal.PersistentSet  (id=22888)	
		[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
			bids	java.util.HashSet<E>  (id=22898)	
			categories	java.util.HashSet<E>  (id=22899)	
			id	null	
			name	"dress" (id=22900)	
	[1]	"clothing" (id=21970)	
	[2]	java.lang.Integer  (id=24432)	

		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/n,
/ niets is dirty, ook de collection niet,

			// Search for collections by reachability, updating their role.
			// We don't want to touch collections reachable from a deleted object
			if ( persister.hasCollections() ) {
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s,
org.hibernate.event.internal.FlushVisitor(org.hibernate.event.internal.AbstractVisitor).processEntityPropertyValues(java.lang.Object[], org.hibernate.type.Type[]) line: 59	
		for ( int i=0; i<types.length; i++ ) {
			if ( includeEntityProperty(values, i) ) {
				processValue( i, values, types );
/s,
org.hibernate.event.internal.FlushVisitor(org.hibernate.event.internal.AbstractVisitor).processValue(int, java.lang.Object[], org.hibernate.type.Type[]) line: 65	
		processValue( values[i], types[i] );
/s,
org.hibernate.event.internal.FlushVisitor(org.hibernate.event.internal.AbstractVisitor).processValue(java.lang.Object, org.hibernate.type.Type) line: 104	
		if ( type.isCollectionType() ) {
			//even process null collections
			return processCollection( value, (CollectionType) type );
/s,
org.hibernate.event.internal.FlushVisitor.processCollection(java.lang.Object, org.hibernate.type.CollectionType) line: 42	

			Collections.processReachableCollection( coll, type, owner, getSession() );
/s,
org.hibernate.engine.internal.Collections.processReachableCollection(org.hibernate.collection.spi.PersistentCollection, org.hibernate.type.CollectionType, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 151

collection	org.hibernate.collection.internal.PersistentSet  (id=22888)	
	[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
		serialVersionUID	1	
		bids	java.util.HashSet<E>  (id=22898)	
		categories	java.util.HashSet<E>  (id=22899)	
		id	null	
		name	"dress" (id=22900)	
		version	0	
type	org.hibernate.type.SetType  (id=22875)	
	role	"org.arquillian.jpa.study2.model.Category.items" (id=24519)	
	
	collection.setOwner( entity );

		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );
ce	org.hibernate.engine.spi.CollectionEntry  (id=24263)	
	LOG	org.jboss.logging.JBossLogManagerLogger  (id=24270)	
	currentKey	null	
	currentPersister	null	
	dorecreate	false	
	doremove	false	
	doupdate	false	
	fromMerge	false	
	ignore	false	
	loadedKey	null	
	loadedPersister	null	
	processed	false	
	reached	false	
	role	null	
	snapshot	java.util.HashMap<K,V>  (id=24275)

		ce.setCurrentPersister( persister );
		//TODO: better to pass the id in as an argument?
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
	
			ce.setReached( true );
			prepareCollectionForUpdate( collection, ce, factory );
/s,
org.hibernate.engine.internal.Collections.prepareCollectionForUpdate(org.hibernate.collection.spi.PersistentCollection, org.hibernate.engine.spi.CollectionEntry, org.hibernate.engine.spi.SessionFactoryImplementor) line: 244	

		entry.setProcessed( true );

		final CollectionPersister loadedPersister = entry.getLoadedPersister();
null
		final CollectionPersister currentPersister = entry.getCurrentPersister();

			// if either its role changed, or its key changed
			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
			if ( ownerChanged ) {
/j,
				// do the work
				if ( currentPersister != null ) {
					entry.setDorecreate( true );
...
/t,
org.hibernate.event.internal.FlushVisitor(org.hibernate.event.internal.AbstractVisitor).processEntityPropertyValues(java.lang.Object[], org.hibernate.type.Type[]) line: 58	

/ volgende,
		for ( int i=0; i<types.length; i++ ) {
			if ( includeEntityProperty(values, i) ) {
				processValue( i, values, types );

/ niets meer, want de ander 2 zijn geen collections, entity of component,
...
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEntities(org.hibernate.event.spi.FlushEvent, org.hibernate.engine.spi.PersistenceContext) line: 221	

		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {

			// Update the status of the object and if necessary, schedule an update

			EntityEntry entry = me.getValue();
			Status status = entry.getStatus();

			if ( status != Status.LOADING && status != Status.GONE ) {
				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
				}
			}
		}
/d,
		source.getActionQueue().sortActions();

/ er is 1 insertion, 
source	org.hibernate.internal.SessionImpl  (id=20753)	
	actionQueue	org.hibernate.engine.spi.ActionQueue  (id=21303)	
		collectionCreations	null	
		collectionQueuedOps	null	
		collectionRemovals	null	
		collectionUpdates	null	
		deletions	null	
		insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=24609)	
			executables	java.util.ArrayList<E>  (id=24611)	
				[0]	org.hibernate.action.internal.EntityInsertAction  (id=22882)	
					entityName	"org.arquillian.jpa.study2.model.Category" (id=21963)	
					id	java.lang.Long  (id=21960)	
					instance	org.arquillian.jpa.study2.model.Category  (id=21961)	
					persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
					session	org.hibernate.internal.SessionImpl  (id=20753)	
					state	java.lang.Object[3]  (id=22870)	
						[0]	org.hibernate.collection.internal.PersistentSet  (id=22888)	
						[1]	"clothing" (id=21970)	
						[2]	java.lang.Integer  (id=22871)	
		orphanRemovals	null	
		updates	null	
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 86	
		try {
			int entityCount = flushEntities( event, persistenceContext );
/d,
			int collectionCount = flushCollections( session, persistenceContext );
/s,
	/**
	 * process any unreferenced collections and then inspect all known collections,
	 * scheduling creates/removes/updates
	 */
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushCollections(org.hibernate.event.spi.EventSource, org.hibernate.engine.spi.PersistenceContext) line: 238	

		final Map.Entry<PersistentCollection,CollectionEntry>[] entries = IdentityMap.concurrentEntries(
				(Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries()
		);
entries	java.util.Map$Entry<K,V>[1]  (id=24285)	
	[0]	org.hibernate.internal.util.collections.IdentityMap$IdentityMapEntry<K,V>  (id=24290)	
		key	org.hibernate.collection.internal.PersistentSet  (id=22888)	
			[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
				serialVersionUID	1	
				bids	java.util.HashSet<E>  (id=22898)	
				categories	java.util.HashSet<E>  (id=22899)	
				id	null	
				name	"dress" (id=22900)	
				version	0	
		value	org.hibernate.engine.spi.CollectionEntry  (id=24263)	
			LOG	org.jboss.logging.JBossLogManagerLogger  (id=24270)	
			currentKey	java.lang.Long  (id=21960)	
			currentPersister	org.hibernate.persister.collection.BasicCollectionPersister  (id=24582)	
			dorecreate	true	
			doremove	false	
			doupdate	false	
			fromMerge	false	
			ignore	false	
			loadedKey	null	
			loadedPersister	null	
			processed	true	
			reached	true	
			role	null	
			snapshot	java.util.HashMap<K,V>  (id=24275)	

		ActionQueue actionQueue = session.getActionQueue();
		for ( Map.Entry<PersistentCollection,CollectionEntry> me :
			IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {
			PersistentCollection coll = me.getKey();
			CollectionEntry ce = me.getValue();
			
coll	org.hibernate.collection.internal.PersistentSet  (id=22888)	
	[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
		serialVersionUID	1	
		bids	java.util.HashSet<E>  (id=22898)	
		categories	java.util.HashSet<E>  (id=22899)	
		id	null	
		name	"dress" (id=22900)	
		version	0	
ce	org.hibernate.engine.spi.CollectionEntry  (id=24263)	
	LOG	org.jboss.logging.JBossLogManagerLogger  (id=24270)	
	currentKey	java.lang.Long  (id=21960)	
	currentPersister	org.hibernate.persister.collection.BasicCollectionPersister  (id=24582)	
	dorecreate	true	
	doremove	false	
	doupdate	false	
	fromMerge	false	
	ignore	false	
	loadedKey	null	
	loadedPersister	null	
	processed	true	
	reached	true	
	role	null	
	snapshot	java.util.HashMap<K,V>  (id=24275)	

			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
								ce.getCurrentKey(),
								session
							)
					);
			}

			if ( ce.isDoremove() ) {
				actionQueue.addAction(
						new CollectionRemoveAction(
/n,
			if ( ce.isDoupdate() ) {
				actionQueue.addAction(
						new CollectionUpdateAction(
/n,
			// todo : I'm not sure the !wasInitialized part should really be part of this check
			if ( !coll.wasInitialized() && coll.hasQueuedOperations() ) {
				actionQueue.addAction(
						new QueuedOperationCollectionAction(
/n,

		actionQueue.sortCollectionActions();
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 88	
			int entityCount = flushEntities( event, persistenceContext );
			int collectionCount = flushCollections( session, persistenceContext );
/d,
			event.setNumberOfEntitiesProcessed( entityCount );
1
			event.setNumberOfCollectionsProcessed( collectionCount );
1
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39	
				flushEverythingToExecutions( event );
/d,
				performExecutions( source );
/s,
	/**
	 * Execute all SQL (and second-level cache updates) in a special order so that foreign-key constraints cannot
	 * be violated: <ol>
	 * <li> Inserts, in the order they were performed
	 * <li> Updates
	 * <li> Deletion of collection elements
	 * <li> Insertion of collection elements
	 * <li> Deletes, in the order they were performed
	 * </ol>
	 *
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 325
	
			session.getActionQueue().prepareActions();
/s,
org.hibernate.engine.spi.ActionQueue.prepareActions() line: 467	
		prepareActions( collectionRemovals );	/ null
		prepareActions( collectionUpdates );	/ null
		prepareActions( collectionQueuedOps );/ null
		prepareActions( collectionCreations );
this	org.hibernate.engine.spi.ActionQueue  (id=21303)	
	collectionCreations	org.hibernate.engine.spi.ExecutableList<E>  (id=24928)	
		executables	java.util.ArrayList<E>  (id=24951)	
			[0]	org.hibernate.action.internal.CollectionRecreateAction  (id=24918)	
				collection	org.hibernate.collection.internal.PersistentSet  (id=22888)	
					[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
				collectionRole	"org.arquillian.jpa.study2.model.Category.items" (id=24519)	
				key	java.lang.Long  (id=21960)	
				persister	org.hibernate.persister.collection.BasicCollectionPersister  (id=24582)	
				session	org.hibernate.internal.SessionImpl  (id=20753)	
/ doet niets, de persister heeft geen cacheAccessStrategy	,
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 337	
			session.getActionQueue().prepareActions();
/d,
			session.getActionQueue().executeActions();
/s,
org.hibernate.engine.spi.ActionQueue.executeActions() line: 453	

		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
			ExecutableList<?> l = listProvider.get( this );
			if ( l != null && !l.isEmpty() ) {
				executeActions( l );
		
this	org.hibernate.engine.spi.ActionQueue  (id=21303)	
	EXECUTABLE_LISTS_MAP	java.util.LinkedHashMap<K,V>  (id=24607)	
		[0]	java.util.LinkedHashMap$Entry<K,V>  (id=25015)	
			key	java.lang.Class<T> (org.hibernate.action.internal.OrphanRemovalAction) (id=22267)	
			value	org.hibernate.engine.spi.ActionQueue$1  (id=25026)	
		[1]	java.util.LinkedHashMap$Entry<K,V>  (id=25016)	
			key	java.lang.Class<T> (org.hibernate.action.internal.AbstractEntityInsertAction) (id=8669)	
			value	org.hibernate.engine.spi.ActionQueue$2  (id=25030)	
		[2]	java.util.LinkedHashMap$Entry<K,V>  (id=25017)	
			key	java.lang.Class<T> (org.hibernate.action.internal.EntityUpdateAction) (id=22161)	
			value	org.hibernate.engine.spi.ActionQueue$3  (id=25033)	
		[3]	java.util.LinkedHashMap$Entry<K,V>  (id=25018)	
			key	java.lang.Class<T> (org.hibernate.action.internal.QueuedOperationCollectionAction) (id=22265)	
			value	org.hibernate.engine.spi.ActionQueue$4  (id=25036)	
		[4]	java.util.LinkedHashMap$Entry<K,V>  (id=25019)	
			key	java.lang.Class<T> (org.hibernate.action.internal.CollectionRemoveAction) (id=22313)	
			value	org.hibernate.engine.spi.ActionQueue$5  (id=25039)	
		[5]	java.util.LinkedHashMap$Entry<K,V>  (id=25022)	
			key	java.lang.Class<T> (org.hibernate.action.internal.CollectionUpdateAction) (id=22165)	
			value	org.hibernate.engine.spi.ActionQueue$6  (id=25042)	
		[6]	java.util.LinkedHashMap$Entry<K,V>  (id=25023)	
			key	java.lang.Class<T> (org.hibernate.action.internal.CollectionRecreateAction) (id=8128)	
			value	org.hibernate.engine.spi.ActionQueue$7  (id=25045)	
		[7]	java.util.LinkedHashMap$Entry<K,V>  (id=25024)	
			key	java.lang.Class<T> (org.hibernate.action.internal.EntityDeleteAction) (id=22787)	
			value	org.hibernate.engine.spi.ActionQueue$8  (id=25048)	
/ 1ste,
/s,
			org.hibernate.engine.spi.ActionQueue$1.get(org.hibernate.engine.spi.ActionQueue) line: 105	
/=
		EXECUTABLE_LISTS_MAP.put(
				OrphanRemovalAction.class,
				new ListProvider<OrphanRemovalAction>() {
					ExecutableList<OrphanRemovalAction> get(ActionQueue instance) {
						return instance.orphanRemovals;	/ null
					}
/ 2de, 
/=
		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;		/ is er,
					}
/t,
org.hibernate.engine.spi.ActionQueue.executeActions() line: 455	
		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
			ExecutableList<?> l = listProvider.get( this );
/d,
this	org.hibernate.engine.spi.ActionQueue  (id=21303)	
	insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=24609)	
		executables	java.util.ArrayList<E>  (id=24611)	
			[0]	org.hibernate.action.internal.EntityInsertAction  (id=22882)	
				entityName	"org.arquillian.jpa.study2.model.Category" (id=21963)	
				id	java.lang.Long  (id=21960)	
				instance	org.arquillian.jpa.study2.model.Category  (id=21961)	
				state	java.lang.Object[3]  (id=22870)	
					[0]	org.hibernate.collection.internal.PersistentSet  (id=22888)	
						[0]	org.arquillian.jpa.study2.model.Item  (id=22896)	
							bids	java.util.HashSet<E>  (id=22898)	
							categories	java.util.HashSet<E>  (id=22899)	
							id	null	
							name	"dress" (id=22900)	
							version	0	
					[1]	"clothing" (id=21970)	
					[2]	java.lang.Integer  (id=22871)	
				version	java.lang.Integer  (id=22871)	

			if ( l != null && !l.isEmpty() ) {
				executeActions( l );
/s,
org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 580	
			for ( E e : list ) {
				try {
					e.execute();
/s,
org.hibernate.action.internal.EntityInsertAction.execute() line: 75	
		nullifyTransientReferencesIfNotAlready();
		
		final EntityPersister persister = getPersister();
		final SessionImplementor session = getSession();
		final Object instance = getInstance();
		final Serializable id = getId();

		final boolean veto = preInsert();
false
/ TODO
		// Don't need to lock the cache here, since if someone
		// else inserted the same pk first, the insert would fail

		if ( !veto ) {
/j,
			persister.insert( id, getState(), instance, session );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3386	

/ we zijn dus nu de persister,
			
		final int span = getTableSpan();
1
/= joinSpan	,
/ TODO	
		if ( entityMetamodel.isDynamicInsert() ) {
			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
			boolean[] notNull = getPropertiesToInsert( fields );
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
			}
		}
/n,
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );

this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=22137)	
		mutable	true	
		propertyInsertability	(id=25330)	
			[0]	true	
			[1]	true	
			[2]	true	
			
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
	sqlInsertStrings	java.lang.String[1]  (id=25336)	
		[0]	"insert into Category (name, version, id) values (?, ?, ?)" (id=25337)
		
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
	insertResultCheckStyles	org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle[1]  (id=25341)	
		[0]	org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle  (id=25405)	
			$VALUES	org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle[3]  (id=25409)	
			COUNT	org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle  (id=25405)	
			NONE	org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle  (id=25410)	
			PARAM	org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle  (id=25411)	
			name	"rowcount" (id=25412)	
			name	"COUNT" (id=25408)	
			ordinal	1	

				
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2841	

		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
/s,
org.hibernate.jdbc.Expectations.appropriateExpectation(org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle) line: 174	
		else if ( style == ExecuteUpdateResultCheckStyle.COUNT ) {
			return BASIC;
		}
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2862	

		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
/d,
		// we can't batch joined inserts, *especially* not if it is an identity insert;
		// nor can we batch statements where the expectation is based on an output param
		final boolean useBatch = j == 0 && expectation.canBeBatched();
true
		if ( useBatch && inserBatchKey == null ) {
			inserBatchKey = new BasicBatchKey(
					getEntityName() + "#INSERT",
					expectation
			);
		}
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=21965)	
	inserBatchKey	org.hibernate.engine.jdbc.batch.internal.BasicBatchKey  (id=25464)	
		comparison	"org.arquillian.jpa.study2.model.Category#INSERT" (id=25463)	

		final boolean callable = isInsertCallable( j );
false		
				
		try {
			// Render the SQL query
			final PreparedStatement insert;
			if ( useBatch ) {
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.getBatch(org.hibernate.engine.jdbc.batch.spi.BatchKey) line: 207	
		if ( currentBatch != null ) {
/n,
		currentBatch = batchBuilder().buildBatch( key, this );
/t,
						.getBatch( inserBatchKey )
/d,
						.getBatchStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 120	
		PreparedStatement statement = statements.get( sql );
		if ( statement == null ) {
			statement = buildBatchStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).buildBatchStatement(java.lang.String, boolean) line: 136	
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 77	
		jdbcCoordinator.executeBatch();
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.executeBatch() line: 214	
		if ( currentBatch != null ) {
			currentBatch.execute();
/ niets, want currentBatch.statements=null,
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 77	

		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.buildPreparedStatementPreparationTemplate(java.lang.String, boolean) line: 82	

		return new StatementPreparationTemplate( sql ) {					/ <-
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
		};
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 167	
				final PreparedStatement preparedStatement;
				try {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementStart();
					preparedStatement = doPrepare();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );				/ <-

/ Intermezzo

/ we kijken naar connection() apart in deze Intermezzo,

/ eerst moeten we een conn krijgen,

/ van h. komen we in jca,

/ stack trace,

org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 401
/=
   public ConnectionListener getManagedConnection(Subject subject, ConnectionRequestInfo cri)

         Transaction tx = transactionManager.getTransaction();
               if (!TxUtils.isActive(tx))
                  if (!getPool().hasConnection(subject, cri) || allowMarkedForRollbackFastFail)
/cb,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
						: connection().prepareStatement( sql );
/cb,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 78	
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).buildBatchStatement(java.lang.String, boolean) line: 136	
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 125	
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2878	
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3397	
org.hibernate.action.internal.EntityInsertAction.execute() line: 89	
org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 582	
org.hibernate.engine.spi.ActionQueue.executeActions() line: 456	
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 337	
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39	
org.hibernate.internal.SessionImpl.flush() line: 1282	
org.hibernate.internal.SessionImpl.managedFlush() line: 465	
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963	
org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	<-
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	
org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	

/we debug verder,
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).hasConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 842	
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/s,
   /**
    * Get any transaction synchronization registry associated with the pool.
    * @return The value
    */
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionSynchronizationRegistry() line: 376	
      if (getTransactionIntegration() != null)
/s,
   /**
    * Get any transaction integration associated with the pool.
    *
    * @return the transaction integration
    */
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionIntegration() line: 352	
      if (cm != null)
         return cm.getTransactionIntegration();
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getTransactionIntegration() line: 228	
      return txIntegration;
cm.org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl@5a06e3e
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionSynchronizationRegistry() line: 377	
      if (getTransactionIntegration() != null)
/d,
         return getTransactionIntegration().getTransactionSynchronizationRegistry();
/s,
org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl.getTransactionSynchronizationRegistry() line: 112	
      return tsr;
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper@6a6cc9dd

/ Intermezzo

/ REGISTEDSYNCHRONIZATION AND TRANSACTIONSYNCHRONIZATIONREGISTRYWRAPPER

/ onderaan in de stack,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116

/ net als,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper 

/////////////////////////////////////////////////////////
/ we zien dat de RegisteredSynchronization in de tsr=TransactionSynchronizationRegistryWrapper zit onder de preJcaSync	,

tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=25513)	
	delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=25518)	
		serialVersionUID	1	
		tm	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=20713)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=23107)	
		[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=25529)	
			key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20725)	
			value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=23085)	
				jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=23107)	
					[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=25529)
						key TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-12155dc1:5ce982bd:7b status: ActionStatus.ABORTING>					
						value org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList@e18e0e4					
				jcaSyncs	java.util.ArrayList<E>  (id=23108)	
					[0]	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=23155)	
				preJcaSyncs	java.util.ArrayList<E>  (id=23109)	
					[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=23144)	<-
					[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=23044)	
				tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20725)	


/ er zijn,

/**
 * The JTA {@link javax.transaction.Synchronization} Hibernate registers when needed for JTA callbacks.
 * <p/>
 * Note that we split the notion of the registered Synchronization and the processing of the Synchronization callbacks
 * mainly to account for "separation of concerns", but also so that the transaction engine does not have to hold
 * reference to the actual Synchronization that gets registered with the JTA system.
 *
 * @author Steve Ebersole
 */
package org.hibernate.resource.transaction.backend.jta.internal.synchronization;
public class RegisteredSynchronization implements Synchronization {


/**
 * Most of this implementation delegates down to the underlying transactions implementation to provide the services of the
 * TransactionSynchronizationRegistry. The one area it modifies is the registration of the interposed Synchronizations. The
 * reason this implementation needs to differ is because the JCA Synchronization and JPA Synchronizations are both specified as
 * Interposed however there are defined ordering requirements between them both.
 
/ delegate=com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple@451e1713
 *
 * The current implementation orders JCA relative to all other Synchronizations. For beforeCompletion, it would be possible to
 * restrict this to the one case where JCA is ordered before JPA, however it is possible that other interposed Synchronizations
 * would require the services of JCA and as such if the JCA is allowed to execute delistResource during beforeCompletion as
 * mandated in JCA spec the behaviour of those subsequent interactions would be broken. For afterCompletion the JCA
 * synchronizations are called last as that allows JCA to detect connection leaks from frameworks that have not closed the JCA
 * managed resources. This is described in (for example)
 * http://docs.oracle.com/javaee/5/api/javax/transaction/TransactionSynchronizationRegistry
 * .html#registerInterposedSynchronization(javax.transaction.Synchronization) where it says that during afterCompletion
 * "Resources can be closed but no transactional work can be performed with them".
 *
 * One implication of this approach is that if the underlying transactions implementation has special handling for various types
 * of Synchronization that can also implement other interfaces (i.e. if interposedSync instanceof OtherInterface) these
 * behaviours cannot take effect as the underlying implementation will never directly see the actual Synchronizations.
 */
package org.jboss.as.txn.service.internal.tsr;
public class TransactionSynchronizationRegistryWrapper implements TransactionSynchronizationRegistry {

/**
 * This interface is intended for use by system level application server
 * components such as persistence managers, resource adapters, as well as
 * EJB and Web application components. This provides the ability to
 * register synchronization objects with special ordering semantics,
 * associate resource objects with the current transaction, get the
 * transaction context of the current transaction, get current transaction
 * status, and mark the current transaction for rollback.
 *
 * This interface is implemented by the application server by a
 * stateless service object. The same object can be used by any number of
 * components with thread safety.
 *
 * <P>In standard application server environments, an instance
 * implementing this interface can be looked up by a standard name via JNDI.
 * The standard name is java:comp/TransactionSynchronizationRegistry.
 *
 * @since JTA 1.1
 */
package javax.transaction;
public interface TransactionSynchronizationRegistry {

/**
 * Implementation of the TransactionSynchronizationRegistry interface, in line with the JTA 1.1 specification.
 *
 * @author jonathan.halliday@jboss.com
 */
    // This Imple is stateless and just delegates the work down to the transaction manager.
    // It's Serilizable so it can be shoved into the app server JNDI.

    /*
     * http://java.sun.com/javaee/5/docs/api/javax/transaction/TransactionSynchronizationRegistry.html
     * http://jcp.org/aboutJava/communityprocess/maintenance/jsr907/907ChangeLog.html
     */
package com.arjuna.ats.internal.jta.transaction.arjunacore;
public class TransactionSynchronizationRegistryImple implements TransactionSynchronizationRegistry, Serializable, ObjectFactory
	

/ Einde Intermezzo

/ we gaan verder met de debug,
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).hasConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 843	
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/d,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper@6a6cc9dd
/ hier zit org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@18afebe8 in in preJcaSyncs
/ deze wordt called in beforeCompletion	.,

         if (tsr != null && tsr.getTransactionKey() != null)
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionKey() line: 86	
        return delegate.getTransactionKey();
/s,
    // Return an opaque object to represent the transaction bound to the current thread at the time this method is called.
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionKey() line: 76	
            transactionImple = (TransactionImple)tm.getTransaction();
            return transactionImple.get_uid();
0:ffffc0a87b73:-12155dc1:5ce982bd:7b
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTSRLock() line: 434	
         if (tsr != null && tsr.getTransactionKey() != null)
         {
            result = (Lock)tsr.getResource(LockKey.INSTANCE);
/s,
				return delegate.getResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 116	








/ Einde Intermezzo




					
					
					
					
					
					
					
		
            lastIndexProcessed = lastIndexProcessed + 1;
	


	
/ Einde DEBUG TX START WILDFLY

/ DEBUG TX START WILDFLY REGISTEREDSYNCHRONIZATION TRANSACTIONSYNCHRONIZATIONREGISTRYWRAPPER

jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );

/ we zijn in stack,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 146
		joinJtaTransaction();
/cb,	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 92
		pulse();
/cb,	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 28
		return new JtaTransactionCoordinatorImpl(
				this,
				owner,
				options.shouldAutoJoinTransaction()
		);
/cb,		
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 274
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(
					this.jdbcCoordinator,
					this
			);
/cb,			
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1327	
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 133	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse();
/ internalGetSession() zelf calls ook .getTransactionCoordinator().pulse()
/cb,
org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 83	
org.hibernate.jpa.internal.EntityManagerFactoryImpl.internalCreateEntityManager(javax.persistence.SynchronizationType, java.util.Map) line: 319	
org.hibernate.jpa.internal.EntityManagerFactoryImpl.createEntityManager() line: 286	
org.jboss.as.jpa.container.TransactionScopedEntityManager.createEntityManager(javax.persistence.EntityManagerFactory, java.util.Map, javax.persistence.SynchronizationType) line: 187	
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 157	
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87
        isInTx = TransactionUtil.isInTx(transactionManager);

        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/cb,	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580
            getEntityManager().persist(entity);
/cb,	
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	
		em.persist(entity);
/cb,
sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
org.jboss.invocation.InterceptorContext.proceed() line: 340	
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
            }
/cb,
org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	

/ we gaan verder debug,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158	
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/s,
 * The JTA {@link javax.transaction.Synchronization} Hibernate registers when needed for JTA callbacks.
 * <p/>
 * Note that we split the notion of the registered Synchronization and the processing of the Synchronization callbacks
 * mainly to account for "separation of concerns", but also so that the transaction engine does not have to hold
 * reference to the actual Synchronization that gets registered with the JTA system.
 *
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.<init>(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator) line: 29	
/=
	public RegisteredSynchronization(SynchronizationCallbackCoordinator synchronizationCallbackCoordinator) {
		this.synchronizationCallbackCoordinator = synchronizationCallbackCoordinator;
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl@3813e95e
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158	
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/pd,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform(org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform).registerSynchronization(javax.transaction.Synchronization) line: 126	
		getSynchronizationStrategy().registerSynchronization( synchronization );
getSynchronizationStrategy()=org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy@78fef5bc
/s,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29	
		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
				synchronization
		);
synchronizationRegistryAccess=org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1@42ca855c
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1.getSynchronizationRegistry() line: 47	
/=
    public JBossAppServerJtaPlatform(final JtaManager jtaManager) {
        this.jtaManager = jtaManager;
        this.synchronizationStrategy = new SynchronizationRegistryBasedSynchronizationStrategy(new SynchronizationRegistryAccess() {
            @Override
            public TransactionSynchronizationRegistry getSynchronizationRegistry() {
                return jtaManager.getSynchronizationRegistry();
            }
        });
    }
this	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1  (id=21878)	
	val$jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=21881)	
		transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=21120)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=21159)	
/s,
/ deze class geeft tsr en tm 
org.jboss.as.jpa.transaction.JtaManagerImpl.getSynchronizationRegistry() line: 47	
        return transactionSynchronizationRegistry;
/t,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29	
		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
				synchronization
		);
/ pd,
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 68	
	
/ Intermezzo

/ er zijn TransactionManagerImle en TransactionCoordinatorImpl	,
/ TransactionManagerImple is een arjuna ding, TransactionCoordinatorImpl is een H. ding,
/ wat is het verband?
/ TODO

package com.arjuna.ats.internal.jta.transaction.arjunacore;
public class TransactionManagerImple extends BaseTransaction implements
		javax.transaction.TransactionManager, javax.naming.spi.ObjectFactory
/ implements commit(), rollback()	,

package org.hibernate.resource.transaction.backend.jta.internal;
public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {
	public void pulse() {
		joinJtaTransaction();
/s,
	private void joinJtaTransaction() {
		if ( synchronizationRegistered ) {
			return;
		}
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) ); 
			/ registers de Synchronization in de tx (eig. ActionAction._synchs)	, en in de tsr
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
		synchronizationRegistered = true;

package org.hibernate.resource.transaction.backend.jta.internal.synchronization;
import javax.transaction.Synchronization;
public class RegisteredSynchronization implements Synchronization {



/ Einde Intermezzo

            Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
            if (jcaOrderedLastSynchronization == null) {
                JCAOrderedLastSynchronizationList toPut = new JCAOrderedLastSynchronizationList((com.arjuna.ats.jta.transaction.Transaction) tx, interposedSyncs);
                jcaOrderedLastSynchronization = interposedSyncs.putIfAbsent(tx, toPut);

this	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=21159)	
	delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=21158)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21936)	
		[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=21970)	
			key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21132)	
			value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21956)	
				jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21936)	
				jcaSyncs	java.util.ArrayList<E>  (id=21958)	
				preJcaSyncs	java.util.ArrayList<E>  (id=21959)				/ [] RegisteredSynchronization ziet er nog niet in, wel na (*)	,
				tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21132)	
	transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=21120)	

                if (jcaOrderedLastSynchronization == null) {
                    jcaOrderedLastSynchronization = toPut;
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization);		/ eerst deze nu debug,	 
jcaOrderedLastSynchronization=org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21956)
                }
            }
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync); / (*)	 / later deze debug,
/ Intermezzo

/**
 * This class was added to:
 *
 * 1. workaround an issue discussed in https://java.net/jira/browse/JTA_SPEC-4 whereby the JCA Synchronization(s) need to be
 * called after the JPA Synchronization(s). Currently the implementation orders JCA relative to all interposed Synchronizations,
 * if this is not desirable it would be possible to modify this class to store just the JPA and JCA syncs and the other syncs
 * can simply be passed to a delegate (would need the reference to this in the constructor).
 *
 * 2. During afterCompletion the JCA synchronizations should be called last as that allows JCA to detect connection leaks from
 * frameworks that have not closed the JCA managed resources. This is described in (for example)
 * http://docs.oracle.com/javaee/5/api/javax/transaction/TransactionSynchronizationRegistry
 * .html#registerInterposedSynchronization(javax.transaction.Synchronization) where it says that during afterCompletion
 * "Resources can be closed but no transactional work can be performed with them"
 */
package org.jboss.as.txn.service.internal.tsr;
public class JCAOrderedLastSynchronizationList implements Synchronization {

/ lees,
https://developer.jboss.org/thread/278823
https://issues.jboss.org/browse/JBTM-608

/ Einde Intermezzo

/ Intermezzo

this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=20447)	
		_synchs	null												/ hier komen de RegisteredSynchronizations in,
	_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=20481)	/ hier komen de EntityManagers in,

/ Einde Intermezzo	


/ dit is de delegate van de tsr, com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple
/ deze gaat de org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList register in de global tx (in ActionAction._synchs)	, 
/ in deze list komt de RegisteredSynchronization, een Synchronization die zo heet omdat hij in een SynchronizationRegistry (TODO) terecht komt WH, deze synchronizes de resources (TODO) met de global tx, 

/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.registerInterposedSynchronization(javax.transaction.Synchronization) line: 140	
            transactionImple.registerSynchronizationImple(new SynchronizationImple(synchronization, true));
synchronization=org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21956)
/s,
 * Whenever a synchronization is registered, an instance of this class
 * is used to wrap it.
 *
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.<init>(javax.transaction.Synchronization, boolean) line: 60	
		_theSynch = ptr;		/ org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList
		_theUid = new Uid();
		_isInterposed = isInterposed;
/t,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.registerSynchronizationImple(com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple) line: 386	
/=
	void registerSynchronizationImple(SynchronizationImple synchronizationImple)
	
synchronizationImple	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=22051)	
	_isInterposed	true	
	_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21956)	
		jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21936)	
				key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21132)	
				value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21956)	
		jcaSyncs	java.util.ArrayList<E>  (id=21958)	
		preJcaSyncs	java.util.ArrayList<E>  (id=21959)	
		tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21132)	
	_theUid	com.arjuna.ats.arjuna.common.Uid  (id=22052)

/ org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList is de list waar RegisteredSynchronization in komt,	

			if (_theTransaction.addSynchronization(synchronizationImple) != AddOutcome.AR_ADDED)
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).addSynchronization(com.arjuna.ats.arjuna.coordinator.SynchronizationRecord) line: 135

this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=22107)	

/SynchronizationRecord sr, het arg, is de wrapper SynchronizationImple,  met de list er in, 	

		switch (status())
		{
		// https://jira.jboss.org/jira/browse/JBTM-608
		case ActionStatus.RUNNING:
		case ActionStatus.PREPARING:
		{
		    synchronized (this)
		    {
		        if (_synchs == null)
		        {
		            // Synchronizations should be stored (or at least iterated) in their natural order
		            _synchs = new TreeSet<SynchronizationRecord>();
		        }

                // need to guard against synchs being added while we are performing beforeCompletion processing
                if (_synchs.add(sr))
                {
                    result = AddOutcome.AR_ADDED;
		return result;

/////////////////////////////////////////////
/ REGISTEDSYNCHRONIZATIONS IN THE TX (ATOMICACTION)

this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=22107)	
	_synchs	java.util.TreeSet<E>  (id=22110)	
		[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=22051)	
			_isInterposed	true	
			_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21956)	
				jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21936)	
				jcaSyncs	java.util.ArrayList<E>  (id=21958)	
				preJcaSyncs	java.util.ArrayList<E>  (id=21959)	
				tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=21132)	
			_theUid	com.arjuna.ats.arjuna.common.Uid  (id=22052)

/ dus de synchronizations zijn in de tx,
/ logisch,

//////////////////////////////////////////


	
/t,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 78	
	
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization);
                }
            }
/d,


/ Intermezzo

/ de list waarin de Synchronizations terecht komen zit op twee plaatsen, in de tx (eig. in de AtomicAction), en in de tsr,
/ TODO
/ de SessionSynchronization zit ook in de tx._txLocalResources	, 
/ TODO

this	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20731)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20747)	
		[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=21921)	
			key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
			value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21881)	
tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=20447)	
		_synchs	java.util.TreeSet<E>  (id=21898)	
			[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=21895)	
				_isInterposed	true	
				_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21881)	
					jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20747)	
					jcaSyncs	java.util.ArrayList<E>  (id=21886)	
					preJcaSyncs	java.util.ArrayList<E>  (id=21887)	
					tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
				_theUid	com.arjuna.ats.arjuna.common.Uid  (id=21896)	

this	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20731)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20747)	
		[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=22401)	
			key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
			value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21881)	
				jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20747)	
				jcaSyncs	java.util.ArrayList<E>  (id=21886)	
				preJcaSyncs	java.util.ArrayList<E>  (id=21887)	
					[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21868)	
					[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22156)	
				tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
					_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=20447)	
						_synchs	java.util.TreeSet<E>  (id=21898)	
							[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=21895)	
								_isInterposed	true	
								_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21881)	
									jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20747)	
									jcaSyncs	java.util.ArrayList<E>  (id=21886)	
									preJcaSyncs	java.util.ArrayList<E>  (id=21887)
										[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21868)	
										[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22156)										
					_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=20481)	
						[0]	java.util.HashMap$Node<K,V>  (id=22187)	
							key	"229dca60-63ec-44e3-9b87-a43ae3c8edd5.war#arquillian-jpa-study2-persistence-unit" (id=20730)	
							value	org.hibernate.jpa.internal.EntityManagerImpl  (id=21513)	
						[1]	java.util.HashMap$Node<K,V>  (id=22183)	
							key	"__TX_LISTENERS" (id=20691)	
							value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=22169)	
								[0]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22156)	


/ Einde Intermezzo

            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync); / (*)	
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.registerInterposedSynchronization(javax.transaction.Synchronization) line: 70	
	            preJcaSyncs.add(synchronization);
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 159	

		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/d,
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
		synchronizationRegistered = true;		
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl.synchronizationRegistered() line: 77	
		registrationThreadId = Thread.currentThread().getId();
236
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 162	
            entityManager = createEntityManager(emf, properties, synchronizationType);
/d,
            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 73	
        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);
/s,
    /**
     * Using the TransactionListener, we can detect Synchronization.afterCompletion() being called from a
     * background thread, while the application may still be actively using the EntityManager.
     * We need to ensure that the background thread does not close the EntityManager while the application thread
     * is actively using it.
     *
     * We know when the application thread is associated with the transaction and can defer closing the EntityManager
     * until both conditions are met:
     *
     *   1. application is disassociated from transaction
     *   2. Synchronization.afterCompletion has been called
     *
     * See discussions for more details about how we arrived at using the TransactionListener:
     *     https://developer.jboss.org/message/919807
     *     https://developer.jboss.org/thread/252572
     */
    private static class SessionSynchronization implements Synchronization, TransactionListener {
        public SessionSynchronization(EntityManager session, String scopedPuName) {
/t,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 74	
        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);
/d,
        tsr.registerInterposedSynchronization(sessionSynchronization);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 78	
        try {
            Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
            if (jcaOrderedLastSynchronization == null) {
/n,
                JCAOrderedLastSynchronizationList toPut = new JCAOrderedLastSynchronizationList((com.arjuna.ats.jta.transaction.Transaction) tx, interposedSyncs);
                jcaOrderedLastSynchronization = interposedSyncs.putIfAbsent(tx, toPut);
                if (jcaOrderedLastSynchronization == null) {
                    jcaOrderedLastSynchronization = toPut;
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization);
                }
            }
/ Einde n,
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync); / hier insert we eerder de RegisteredSynchronization
org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@a23dfb3
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.registerInterposedSynchronization(javax.transaction.Synchronization) line: 90	
				preJcaSyncs.add(synchronization);
[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@713cc996, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@a23dfb3]

/t,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 76	
        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);
        tsr.registerInterposedSynchronization(sessionSynchronization);
/d,
        try {
            getTransactionListenerRegistry(transactionManager).addListener(getTransaction(transactionManager), sessionSynchronization, eventTypes);
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).addListener(javax.transaction.Transaction, org.jboss.tm.listener.TransactionListener, java.util.EnumSet<org.jboss.tm.listener.EventType>) line: 180	
	            listeners.add(listener);
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 163	
            entityManager = createEntityManager(emf, properties, synchronizationType);
            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
/d,
            TransactionUtil.putEntityManagerInTransactionRegistry(scopedPuName, entityManager, transactionSynchronizationRegistry);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.putEntityManagerInTransactionRegistry(java.lang.String, javax.persistence.EntityManager, javax.transaction.TransactionSynchronizationRegistry) line: 127	
        tsr.putResource(scopedPuName, entityManager);
		
/ Intermezzo

/ tsr.putResource() betekent dat de resource in de tx komt! 
/ see (**) hierboven, 

/ Einde Intermezzo

/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.putResource(java.lang.Object, java.lang.Object) line: 112	
        delegate.putResource(key, value);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 100	
        TransactionImple transactionImple = getTransactionImple();
        transactionImple.putTxLocalResource(key, value);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTxLocalResource(java.lang.Object, java.lang.Object) line: 1096	
		_txLocalResources.put(key, value);
{229dca60-63ec-44e3-9b87-a43ae3c8edd5.war#arquillian-jpa-study2-persistence-unit=org.hibernate.jpa.internal.EntityManagerImpl@3f02bed7, __TX_LISTENERS=[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@a23dfb3]}

this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=20447)	
		_synchs	java.util.TreeSet<E>  (id=21898)	
			[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=21895)	
				_isInterposed	true	
				_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21881)	
					preJcaSyncs	java.util.ArrayList<E>  (id=21887)	
						[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21868)	
						[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22156)	
					tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20446)	
				_theUid	com.arjuna.ats.arjuna.common.Uid  (id=21896)	
	_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=20481)	
		[0]	java.util.HashMap$Node<K,V>  (id=22187)	
			key	"229dca60-63ec-44e3-9b87-a43ae3c8edd5.war#arquillian-jpa-study2-persistence-unit" (id=20730)	
			value	org.hibernate.jpa.internal.EntityManagerImpl  (id=21513)	
		[1]	java.util.HashMap$Node<K,V>  (id=22183)	
			key	"__TX_LISTENERS" (id=20691)	
			value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=22169)	
				[0]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22156)	
/ see bij (**) boven dat de org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList ook in de tsr zit, 
/ TODO
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 95	
        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/d,
        return entityManager;
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/ pd,
...
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
         Transaction tx = transactionManager.getTransaction();
      return super.getManagedConnection(trackByTransaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590
         return pool.getConnection(transaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 581
/ 1	.	
      // Get specific managed connection pool key
      Object key = getKey(subject, cri, separateNoTx);
false
/ 2	. 
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
SemaphoreConcurrentLinkedQueueManagedConnectionPool@722b05ed[pool=PostgreSQLDS]
/ want,
this	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=22955)	
	mcpPools	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22989)	
{false=SemaphoreConcurrentLinkedQueueManagedConnectionPool@722b05ed[pool=PostgreSQLDS]}

/ 3	.	 
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
this	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=22955)	
	cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=20173)	
		txIntegration	org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl  (id=23020)	
			tm	org.jboss.jca.core.tx.jbossts.TransactionManagerDelegator  (id=22957)	
			tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20731)	
/ 4	,
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionKey() line: 93	
/= tsr.delegate,
            transactionImple = (TransactionImple)tm.getTransaction();
            return transactionImple.get_uid();
/=
				return _theTransaction.get_uid();
/=
					objectUid = 0:ffffc0a87b73:-4efcc201:5d05ef8e:ab
/t,
/ 5	, 
      // Transaction old connections
/ old betekent WH previous,
      cl = getTransactionOldConnection(trackByTransaction, mcp);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 641	
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
      Lock lock = getTSRLock();
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTSRLock() line: 437	
         TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();

         if (tsr != null && tsr.getTransactionKey() != null)
         {
            result = (Lock)tsr.getResource(LockKey.INSTANCE);
            if (result == null)
            {
               result = initLock(tsr);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).initLock(javax.transaction.TransactionSynchronizationRegistry) line: 410	
      if (tsr.getTransactionKey() != null)
      {
         Lock lock = (Lock)tsr.getResource(LockKey.INSTANCE);
         if (lock == null)
         {
            lock = new ReentrantLock(true);
            tsr.putResource(LockKey.INSTANCE, lock);
            return lock;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 659	
      Lock lock = getTSRLock();
/d,
         lock.lockInterruptibly();
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
null
         return null;
		 
/////////////////////////////////////
/ hier zien we de rol van de tx, die mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@722b05ed[pool=PostgreSQLDS] had als key in de tx moeten zitten in _txLocalResources	,
/ Hoe komen we aan de connection, zit die niet in de pool?
/ see (***) hieronder	,
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 596	
/ 5	. 
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
null
/d,
/ 6	.
      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	

      ConnectionListener cl = mcp.getConnection(subject, cri);
/s,
/ (***)
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
            // We have a permit to get a connection. Is there one in the pool already?
            ConnectionListenerWrapper clw = null;
            do 
            {
				...
                  clw = clq.pollLast();
null
/ de pool is leeg	,
/ soms niet, 
clw	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool$ConnectionListenerWrapper  (id=22199)	
	cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22201)	
		managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22206)	
			xaConnection	org.postgresql.xa.PGXAConnection  (id=22326)	
					protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22407)	
						pgStream	org.postgresql.core.PGStream  (id=22452)	
							connection	java.net.Socket  (id=22473)	
							encoding	org.postgresql.core.Encoding  (id=22474)	
							pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=22483)	
							pg_output	java.io.BufferedOutputStream  (id=22484)	

/ TODO
            } 
            while (clq.size() > 0);
               // No, the pool was empty, so we have to make a new one.
               clw = new ConnectionListenerWrapper(createConnectionEventListener(subject, cri), true, true);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1320	

		/ Creates a new physical connection to the underlying EIS resource manager. (EIS =pg)
		/ ManagedConnectionFactory uses the security information (passed as Subject) and additional ConnectionRequestInfo
		/ (which is specific to ResourceAdapter and opaque to application server) to create this new connection.
      ManagedConnection mc = mcf.createManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 416	

            return getXAManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 484	

      XAConnection xaConnection = null;
      Properties props = getConnectionProperties(null, subject, cri);
{}
      try
      {
         final String user = props.getProperty("user");
null
         final String password = props.getProperty("password");
null


/ voorzichtig debuggen, met steps, 
         xaConnection = (user != null)
            ? getXADataSource().getXAConnection(user, password)
            : getXADataSource().getXAConnection();				<-
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXADataSource() line: 612	

this	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=21264)	
	xads	org.postgresql.xa.PGXADataSource  (id=21288)	
		databaseName	"test" (id=21290)	
		logger	null	
		password	"vi_lang17" (id=21292)	
		portNumber	0	
		properties	java.util.Properties  (id=21293)	
		serverName	"localhost" (id=21320)	
		user	"eric" (id=21321)
	xaProps	java.util.Collections$SynchronizedMap<K,V>  (id=21294)	
{DatabaseName=test, User=eric, Password=vi_lang17, ServerName=localhost}		
/ al	,
/ TODO
/t,
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection() line: 39	
        return getXAConnection(getUser(), getPassword());
getUser()="eric"
getPassword()="vi_lang17"
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection(java.lang.String, java.lang.String) line: 54	
        Connection con = super.getConnection(user, password);		<-
        return new PGXAConnection((BaseConnection) con);
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getConnection(java.lang.String, java.lang.String) line: 88	
            Connection con = DriverManager.getConnection(getUrl(), user, password);
getUrl()=jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10
/s,
java.sql.DriverManager.getConnection(java.lang.String, java.util.Properties, java.lang.Class<?>) line: 658	
        for(DriverInfo aDriver : registeredDrivers) {
[driver[className=org.h2.Driver@33da1d3c], driver[className=org.postgresql.Driver@8445bcd]]
            // If the caller does not have permission to load the driver then
            // skip it.
            if(isDriverAllowed(aDriver.driver, callerCL)) {
/ TODO
                try {
                    println("    trying " + aDriver.driver.getClass().getName());
                    Connection con = aDriver.driver.connect(url, info);
/s,
org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 234	
/=
    public java.sql.Connection connect(String url, Properties info) throws SQLException
info={user=eric, password=vi_lang17}

/ Intermezzo

org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 234	
java.sql.DriverManager.getConnection(java.lang.String, java.util.Properties, java.lang.Class<?>) line: 664	
java.sql.DriverManager.getConnection(java.lang.String, java.lang.String, java.lang.String) line: 247	
org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getConnection(java.lang.String, java.lang.String) line: 88	
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection(java.lang.String, java.lang.String) line: 54	
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection() line: 39	
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 492	
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 416	
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1320	
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 598	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94	
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
org.arquillian.jpa.study2.dao.CategoryDao.create(org.arquillian.jpa.study2.model.Category) line: 21	

/ Einde Intermezzo

        // parse URL and add more properties
        if ((props = parseURL(url, props)) == null)
props=
{disableColumnSanitiser=false, binaryTransfer=true, gsslib=auto, allowEncodingChanges=false, sspiServiceClass=POSTGRES, prepareThreshold=5, PGPORT=5432, useSpnego=false, PGHOST=localhost, loginTimeout=0, hostRecheckSeconds=10, defaultRowFetchSize=0, loadBalanceHosts=false, unknownLength=2147483647, preparedStatementCacheQueries=256, PGDBNAME=test, binaryTransferDisable=, receiveBufferSize=-1, targetServerType=any, logUnclosedConnections=false, connectTimeout=0, readOnly=false, socketTimeout=0, tcpKeepAlive=false, binaryTransferEnable=, preparedStatementCacheSizeMiB=5, loglevel=0, sendBufferSize=-1, compatible=9.4}
/ Ik zie user, password er niet bij,
/ TODO
                return makeConnection(url, props);
/s,
org.postgresql.Driver.makeConnection(java.lang.String, java.util.Properties) line: 414	
        return new org.postgresql.jdbc42.Jdbc42Connection(hostSpecs(props),
                                      user(props), database(props),
                                      props, url);
...
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 146	
        // Now make the initial connection and set up local state
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
/s,
org.postgresql.core.ConnectionFactory.openConnection(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 65	
            ConnectionFactory factory = (ConnectionFactory) version[1];
org.postgresql.core.v3.ConnectionFactoryImpl@31557070
            ProtocolConnection connection = factory.openConnectionImpl(hostSpecs, user, database, info, logger);
/s,
org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 129	
        String sslmode = PGProperty.SSL_MODE.get(info);
null
        if (sslmode==null)
        { //Fall back to the ssl property
          requireSSL = trySSL  = PGProperty.SSL.isPresent(info);
false
        } else {
/ NIET, 
          if ("disable".equals(sslmode))
          {
            requireSSL = trySSL = false;
          }
          //allow and prefer are not handled yet
          /*else if ("allow".equals(sslmode) || "prefer".equals(sslmode))
          {  
            //XXX Allow and prefer are treated the same way
            requireSSL = false;
            trySSL = true;
          }*/
          else if ("require".equals(sslmode) || "verify-ca".equals(sslmode) || "verify-full".equals(sslmode))
          {
            requireSSL = trySSL = true;
/ Einde NIET,

        PGStream newStream = null;
        try
        {
            newStream = new PGStream(hostSpec, connectTimeout);
hostSpec=localhost:5432
/s,
org.postgresql.core.PGStream.<init>(org.postgresql.util.HostSpec, int) line: 57	
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);
        changeSocket(socket);
/s,
    /**
     * Switch this stream to using a new socket. Any existing socket
     * is <em>not</em> closed; it's assumed that we are changing to
     * a new socket that delegates to the original socket (e.g. SSL).
     *
     * @param socket the new socket to change to
     * @throws IOException if something goes wrong
     */
    public void changeSocket(Socket socket) throws IOException {
        this.connection = socket;

        // Submitted by Jason Venner <jason@idiom.com>. Disable Nagle
        // as we are selective about flushing output only when we
        // really need to.
        connection.setTcpNoDelay(true);

        // Buffer sizes submitted by Sverre H Huseby <sverrehu@online.no>
        pg_input = new VisibleBufferedInputStream(connection.getInputStream(), 8192);
        pg_output = new BufferedOutputStream(connection.getOutputStream(), 8192);

/t,
org.postgresql.core.PGStream.<init>(org.postgresql.util.HostSpec, int) line: 63	
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);
        changeSocket(socket);
/d,
        setEncoding(Encoding.getJVMEncoding("US-ASCII"));
/ TODO (unicode)
/t,
org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 136	

            newStream = new PGStream(hostSpec, connectTimeout);
/d,
            // Construct and send an ssl startup packet if requested.
            if (trySSL)
/n,
                newStream = enableSSL(newStream, requireSSL, info, logger, connectTimeout);
/ NIET	,
            String[][] params = paramList.toArray(new String[][]{});
[[user, eric], [database, test], [client_encoding, UTF8], [DateStyle, ISO], [TimeZone, Europe/Berlin], [extra_float_digits, 2]]
            sendStartupPacket(newStream, params, logger);
/ stuur de params op,

/ bij debug ERR, en onbekend hoe hoger,	 maar OK is,
...
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 700	
      // Need a new one for this transaction
      // This must be done outside the tx local lock, otherwise
      // the tx timeout won't work and get connection can do a lot of other work
      // with many opportunities for deadlocks.
      // Instead we do a double check after we got the transaction to see
      // whether another thread beat us to the punch.
      ConnectionListener cl = mcp.getConnection(subject, cri);
/d,
/ Hier in debugger Enter geven , 
/ hoe ver kun je er in step, want hierboven gaat het fout,
/ TODO
cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22145)	
	managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22146)	
		xaConnection	org.postgresql.xa.PGXAConnection  (id=22371)	
			con	org.postgresql.jdbc42.Jdbc42Connection  (id=22386)	
				protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22431)	
						connection	java.net.Socket  (id=22486)	
						pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=22490)	
						pg_output	java.io.BufferedOutputStream  (id=22491)	

      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
      Lock lock = getTSRLock();
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTSRLock() line: 434	
         TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();

         if (tsr != null && tsr.getTransactionKey() != null)  /= tsr.delegate.transactionImple.get_uid();
		 
delegate=package com.arjuna.ats.internal.jta.transaction.arjunacore;
		 TransactionSynchronizationRegistryImple implements TransactionSynchronizationRegistry, Serializable, ObjectFactory

         {
            result = (Lock)tsr.getResource(LockKey.INSTANCE);
java.util.concurrent.locks.ReentrantLock@703ad266[Unlocked]
            if (result == null)
            {
               result = initLock(tsr);

/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 744	
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
      Lock lock = getTSRLock();
/d,
         lock.lockInterruptibly();

         // Check we weren't racing with another transaction
         ConnectionListener other =
            (ConnectionListener)tsr.getResource(mcp);
null
/////////////////////////////////////////////////////////////////////////////
         // This is the connection for this transaction
         cl.setTrackByTx(true);
         tsr.putResource(mcp, cl);

tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=22257)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22289)	
		[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=22580)	
			key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=22231)	
			value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22295)	
				preJcaSyncs	java.util.ArrayList<E>  (id=22298)	
				tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=22231)	
					_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=22309)	
					_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=22310)
{					
73f00951-f3fd-4f44-8ffd-cda677c6e49b.war#arquillian-jpa-study2-persistence-unit=org.hibernate.jpa.internal.EntityManagerImpl@668cfa57
,
SemaphoreConcurrentLinkedQueueManagedConnectionPool@722b05ed[pool=PostgreSQLDS]=org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@5e7050cb[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2e7a3dd7 connection handles=0 lastReturned=1560804304764 lastValidated=1560801725174 lastCheckedOut=1560804504678 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@1f97269 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@722b05ed[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@2a0ebf16[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2e7a3dd7 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=null]
,
org.jboss.jca.core.connectionmanager.transaction.LockKey@2a=java.util.concurrent.locks.ReentrantLock@703ad266[Locked by thread default task-4]
,
__TX_LISTENERS=[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@30f0a23d]
}
/ deze vallen dus onder de tx,
...
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/d,
/ Intermezzo

/ deze method zat onder ConnectionListener cl = getManagedConnection(subject, cri);	, en was de method met de 5 stappen	,

org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	

/ Einde Intermezzo

      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 552	
         if (shouldEnlist(cl.getManagedConnection()))			/ kijkt dus naar de conn,  conn instanceof LazyEnlistableManagedConnection NIET,
            cl.enlist();
      }
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 263	

         TransactionSynchronizer.lock(threadTx,
                                      getConnectionManager().getTransactionIntegration());
/s,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.lock(javax.transaction.Transaction, org.jboss.jca.core.spi.transaction.TransactionIntegration) line: 308	

                  ti.getTransactionSynchronizationRegistry().
                     registerInterposedSynchronization(record.getTransactionSynchronizer());
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 68	

/ hier weer, maar nu is de list er al,
            Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
             jcaOrderedLastSynchronization.registerInterposedSynchronization(sync);
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.registerInterposedSynchronization(javax.transaction.Synchronization) line: 92	
        if (synchronization.getClass().getName().startsWith("org.jboss.jca")) {
            ...
            jcaSyncs.add(synchronization);
			
this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22295)	
	jcaSyncs	java.util.ArrayList<E>  (id=22297)
[org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer@3e9dfb46]	
	preJcaSyncs	java.util.ArrayList<E>  (id=22298)	
[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@1892b3d0, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@30f0a23d]

/t,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.lock(javax.transaction.Transaction, org.jboss.jca.core.spi.transaction.TransactionIntegration) line: 338	
                  ti.getTransactionSynchronizationRegistry().
                     registerInterposedSynchronization(record.getTransactionSynchronizer());
/d,
      Lock lock = record.getLock();

      try
      {
         lock.lockInterruptibly();
/ TODO
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 324	
         TransactionSynchronizer.lock(threadTx,
                                      getConnectionManager().getTransactionIntegration());
/d,
            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());

         // First time through, create a transaction synchronization
         if (transactionSynchronization == null)
         {
            TransactionSynchronization synchronization = new TransactionSynchronization(threadTx, isTrackByTx());
            synchronizer.addUnenlisted(synchronization);
            transactionSynchronization = synchronization;
         }

         ourSynchronization = transactionSynchronization;
      }
      finally
      {
         TransactionSynchronizer.unlock(threadTx, getConnectionManager().getTransactionIntegration());
      }
/ TODO wat is er gebeurd in de lock?

      // Perform the enlistment(s)
      List<Synchronization> unenlisted = synchronizer.getUnenlisted();
/s,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.getUnenlisted() line: 136	
      List<Synchronization> result = unenlisted;
result	java.util.ArrayList<E>  (id=22699)	
	[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22728)	
		currentTx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=22231)	
		enlisted	false	
		wasTrackByTx	true	

      unenlisted = null;

      if (result != null)
      {
         enlistingThread = currentThread;
      }

      return result;
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 379	
      // Perform the enlistment(s)
      List<Synchronization> unenlisted = synchronizer.getUnenlisted();
/d,
      if (unenlisted != null)
      {
         try
         {
            int size = unenlisted.size();
            for (int i = 0; i < size; ++i)
            {
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 982	
            XAResource resource = getXAResource();
XAResourceWrapperImpl@2a0ebf16[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2e7a3dd7 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]
/ TxConnectionListener$TransactionSynchronization is een inner class van TxConnectionListener	, en calls TxConnectionListener.getXAResource()	,

		
/ Einde DEBUG TX START WILDFLY REGISTEREDSYNCHRONIZATION TRANSACTIONSYNCHRONIZATIONREGISTRYWRAPPER

/ REGISTEREDSYNCHRONIZATION

/ 7	. 

/ eerder zagen we,
org.hibernate.internal.SessionImpl.flush() line: 1282	
org.hibernate.internal.SessionImpl.managedFlush() line: 465	
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963	
org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	<-
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	

/ 7	. 

package org.hibernate.resource.transaction.backend.jta.internal.synchronization;
/**
 * The JTA {@link javax.transaction.Synchronization} Hibernate registers when needed for JTA callbacks.
 * <p/>
 * Note that we split the notion of the registered Synchronization and the processing of the Synchronization callbacks
 * mainly to account for "separation of concerns", but also so that the transaction engine does not have to hold
 * reference to the actual Synchronization that gets registered with the JTA system.
 *
 * @author Steve Ebersole
 */
public class RegisteredSynchronization implements Synchronization {
	private static final Logger log = logger( RegisteredSynchronization.class );

	private final SynchronizationCallbackCoordinator synchronizationCallbackCoordinator;

	public RegisteredSynchronization(SynchronizationCallbackCoordinator synchronizationCallbackCoordinator) {
		this.synchronizationCallbackCoordinator = synchronizationCallbackCoordinator;
	}

	@Override
	public void beforeCompletion() {
		log.trace( "Registered JTA Synchronization : beforeCompletion()" );

		synchronizationCallbackCoordinator.beforeCompletion();
	}
	
	@Override
	public void afterCompletion(int status) {
		log.tracef( "Registered JTA Synchronization : afterCompletion(%s)", status );

		synchronizationCallbackCoordinator.afterCompletion( status );
	}

/ 7	. 
	
/**
 * The transaction manager supports a synchronization mechanism
 * that allows the interested party to be notified before and
 * after the transaction completes. Using the registerSynchronization
 * method, the application server registers a Synchronization object
 * for the transaction currently associated with the target Transaction
 * object.
 */
public interface Synchronization {

    /**
     * The beforeCompletion method is called by the transaction manager prior
     * to the start of the two-phase transaction commit process. This call is
     * executed with the transaction context of the transaction that is being
     * committed.
     */
    public void beforeCompletion();
	
    /**
     * This method is called by the transaction
     * manager after the transaction is committed or rolled back.
     *
     * @param status The status of the transaction completion.
     */
	public void afterCompletion(int status);
	
/ 7	. 

package org.hibernate.resource.transaction.backend.jta.internal.synchronization;

/**
 * Manages funneling JTA Synchronization callbacks back into the Hibernate transaction engine.
 *
 * @author Steve Ebersole
 */
public interface SynchronizationCallbackCoordinator extends Synchronization {							/ ook !
	/**
	 * Called by the TransactionCoordinator when it registers the Synchronization with the JTA system
	 */
	public void synchronizationRegistered();

	/**
	 * Called by the TransactionCoordinator to allow the SynchronizationCallbackCoordinator to process any
	 * after-completion handling that it may have delayed due to thread affinity
	 */
	public void processAnyDelayedAfterCompletion();
}

/ 7	. 

package org.hibernate.resource.transaction.backend.jta.internal.synchronization;

/**
 * Manages callbacks from the {@link javax.transaction.Synchronization} registered by Hibernate.
 * 
 * @author Steve Ebersole
 */
public class SynchronizationCallbackCoordinatorNonTrackingImpl implements SynchronizationCallbackCoordinator {
	@Override
	public void beforeCompletion() {
		...
		target.beforeCompletion();
	}

	@Override
	public void afterCompletion(int status) {
		...
		doAfterCompletion( JtaStatusHelper.isCommitted( status ), false );
	}

	protected void doAfterCompletion(boolean successful, boolean delayed) {
		try {
			target.afterCompletion( successful, delayed );
		}
		...
	}

/ de target is de JtaTransactionCoordinatorImpl	,

/ 7	 .

package org.hibernate.resource.transaction.backend.jta.internal.synchronization;

/**
 * Extension of SynchronizationCallbackCoordinatorNonTrackingImpl that adds checking of whether a rollback comes from
 * a thread other than the application thread (thread used to register the Synchronization)
 *
 */
public class SynchronizationCallbackCoordinatorTrackingImpl extends SynchronizationCallbackCoordinatorNonTrackingImpl {

/ 7	. 

package org.hibernate.resource.transaction.backend.jta.internal;
/**
 * An implementation of TransactionCoordinator based on managing a transaction through the JTA API (either TM or UT)
 *
 * @author Steve Ebersole
 */
public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {
	@Override
	public void pulse() {
		if ( !autoJoinTransactions ) {		/ implicit joining,
			return;
		}		
		if ( synchronizationRegistered ) {
			return;
		}
		joinJtaTransaction();
	}
	
/ 7	 .

package org.hibernate.resource.transaction;
/**
 * Models the coordination of all transaction related flows.
 *
 * @author Steve Ebersole
 */
public interface TransactionCoordinator {
	/**
	 * Used by owner of the JdbcSession as a means to indicate that implicit joining should be done if needed.
	 */
	public void pulse();

/ 	7. 

package org.hibernate.resource.transaction.backend.jta.internal.synchronization;

/**
 * Defines "inflow" for JTA transactions from the perspective of Hibernate's registered JTA Synchronization
 * back into the TransactionCoordinator by means of the SynchronizationCallbackCoordinator.
 * <p/>
 * That's a mouthful :)  The way it works is like this...<ul>
 *     <li>
 *         Hibernate will register a JTA {@link javax.transaction.Synchronization} implementation
 *         ({@link RegisteredSynchronization}) which allows
 *         it to listen for completion of the JTA transaction.
 *     </li>
 *     <li>
 *         That RegisteredSynchronization is given a SynchronizationCallbackCoordinator which it uses
 *         to route the transaction completion calls back into Hibernate.  The SynchronizationCallbackCoordinator
 *         contract applies various behaviors around this process.  See the impls for details.
 *     </li>
 *     <li>
 *         The SynchronizationCallbackCoordinator is handed a SynchronizationCallbackTarget which is the specific
 *         means for it to "route the transaction completion calls back into Hibernate".  The SynchronizationCallbackTarget
 *         is most often the TransactionCoordinator impl or a direct delegate of the TransactionCoordinator impl.  In
 *         that sense, SynchronizationCallbackTarget is the contract between the SynchronizationCallbackCoordinator
 *         and the TransactionCoordinator.
 *     </li>
 * </ul>
 *
 * @author Steve Ebersole
 */
public interface SynchronizationCallbackTarget {
	/**
	 * Is the callback target still active?  Generally this is checked by the caller prior to calling
	 * {@link #beforeCompletion} or {@link #afterCompletion}
	 *
	 * @return {@code true} indicates the target is active; {@code false} indicates it is not.
	 */
	boolean isActive();

	/**
	 * Callback of before-completion.
	 *
	 * @see javax.transaction.Synchronization#beforeCompletion
	 */
	void beforeCompletion();

	/**
	 * Callback of after-completion.
	 *
	 * @param successful Was the transaction successful?
	 *
	 * @see javax.transaction.Synchronization#afterCompletion
	 */
	void afterCompletion(boolean successful, boolean delayed);
}

package org.hibernate.engine.jdbc.spi;
public interface JdbcCoordinator extends Serializable, TransactionCoordinatorOwner, JdbcResourceTransactionAccess {

	/**
	 * Retrieves the logical connection associated with this JDBC coordinator.
	 *
	 * @return The logical connection
	 */
	public LogicalConnectionImplementor getLogicalConnection();

	/**
	 * Get a batch instance.
	 *
	 * @param key The unique batch key.
	 *
	 * @return The batch
	 */
	public Batch getBatch(BatchKey key);

	/**
	 * Execute the currently managed batch (if any)
	 */
	public void executeBatch();

	/**
	 * Abort the currently managed batch (if any)
	 */
	public void abortBatch();

	/**
	 * Obtain the statement preparer associated with this JDBC coordinator.
	 *
	 * @return This coordinator's statement preparer
	 */
	public StatementPreparer getStatementPreparer();

	/**
	 * Obtain the resultset extractor associated with this JDBC coordinator.
	 *
	 * @return This coordinator's resultset extractor
	 */
	public ResultSetReturn getResultSetReturn();

	/**
	 * Callback to let us know that a flush is beginning.  We use this fact
	 * to temporarily circumvent aggressive connection releasing until after
	 * the flush cycle is complete {@link #flushEnding()}
	 */
	public void flushBeginning();

	/**
	 * Callback to let us know that a flush is ending.  We use this fact to
	 * stop circumventing aggressive releasing connections.
	 */
	public void flushEnding();

	/**
	 * Close this coordinator and release and resources.
	 *
	 * @return The {@link Connection} associated with the managed {@link #getLogicalConnection() logical connection}
	 *
	 * @see org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor#close
	 */
	public Connection close();

	/**
	 * Signals the end of transaction.
	 * <p/>
	 * Intended for use from the transaction coordinator, after local transaction completion.  Used to conditionally
	 * release the JDBC connection aggressively if the configured release mode indicates.
	 */
	public void afterTransaction();

	/**
	 * Used to signify that a statement has completed execution which may
	 * indicate that this logical connection need to perform an
	 * aggressive release of its physical connection.
	 */
	public void afterStatementExecution();



/ Einde REGISTEREDSYNCHRONIZATION


/ MEERDERE DATASOURCES

$ vi src/main/java/repository/LanguageDao.java

package repository;

import java.util.List;

import javax.annotation.PostConstruct;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import domain.Language;

/**
 * DAO for Language
 */
@Stateless
public class LanguageDao {
	@PersistenceContext(unitName = "arquillian-forge4-persistence-unit")
	private EntityManager em;
	
	@PersistenceContext(unitName="arquillian-forge4-persistence-unit-1")
	private EntityManager em1;

	public void create(Language entity) {
		em.persist(entity);
	}

	public void deleteById(Long id) {
		Language entity = em.find(Language.class, id);
		if (entity != null) {
			em.remove(entity);
		}
	}

	public Language findById(Long id) {
		return em.find(Language.class, id);
	}

	public Language update(Language entity) {
		return em.merge(entity);
	}

	public List<Language> listAll(Integer startPosition, Integer maxResult) {
		TypedQuery<Language> findAllQuery = em.createQuery(
				"SELECT DISTINCT l FROM Language l ORDER BY l.id",
				Language.class);
		if (startPosition != null) {
			findAllQuery.setFirstResult(startPosition);
		}
		if (maxResult != null) {
			findAllQuery.setMaxResults(maxResult);
		}
		return findAllQuery.getResultList();
	}
	
	// self,
	
//	@PostConstruct
//	public void inserts() {
//		Language l=new Language();
//		l.setName("Java");
//		em.persist(l); 
//		l=new Language();
//		l.setName("Java");
//		em1.persist(l);
//		l=new Language();
//		l.setName("Go");
//		em.persist(l);
//		l=new Language();
//		l.setName("Go");
//		em1.persist(l);
//		l=new Language();
//		l.setName("C++");
//		em.persist(l);
//		l=new Language();
//		l.setName("C++");
//		em1.persist(l);
//	}
	
	public void insertInTx() {
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
		l=new Language();
		l.setName("Java");
		em1.persist(l);
		l=new Language();
		l.setName("Go");
		em.persist(l);
		l=new Language();
		l.setName("Go");
		em1.persist(l);
		l=new Language();
		l.setName("C++");
		em.persist(l);
		l=new Language();
		l.setName("C++");
		em1.persist(l);
	}
	
	public List<Language>findLanguages(){
		Query q=em.createQuery(
				"select l "	// let op space achteraan	,
				+ "from Language l"
				);
		List<Language>ls=q.getResultList();
		return ls;
	}
	public List<Object[]>findLanguagesNatively(){
		Query q=em.createNativeQuery(
				"select id,name,version "
				+ "from language ");
		List<Object[]>ls=q.getResultList();
		return ls;
	}
	public List<Language>findLanguagesNatively2(){
		Query q=em.createNativeQuery(
				"select id,name,version "
				+ "from language",
				Language.class);
		List<Language>ls=q.getResultList();
		return ls;
	}
}

$ vi src/main/resources/META-INF/persistence.xml

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
<persistence-unit name="arquillian-forge4-persistence-unit" transaction-type="JTA">
  <description>Forge Persistence Unit</description>
    <provider>org.hibernate.ejb.HibernatePersistence</provider>
    <jta-data-source>java:jboss/datasources/PostgreSQLDS</jta-data-source>
    <exclude-unlisted-classes>false</exclude-unlisted-classes>
    <properties>
   <!-- 
    	<property name="hibernate.hbm2ddl.auto" value="create"/>
    -->
      <property name="hibernate.show_sql" value="true"/>
      <property name="hibernate.format_sql" value="true"/>
      <property name="hibernate.transaction.flush_before_completion" value="true"/>
      <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
    </properties>
  </persistence-unit>
  
  <persistence-unit name="arquillian-forge4-persistence-unit-1" transaction-type="JTA">
    <description>Forge Persistence Unit</description>
    <provider>org.hibernate.ejb.HibernatePersistence</provider>
    <jta-data-source>java:jboss/datasources/RemoteExampleDS</jta-data-source>
    <exclude-unlisted-classes>false</exclude-unlisted-classes>
    <properties>
    
    <!-- 
      <property name="hibernate.hbm2ddl.auto" value="create"/>
      -->
     
      <property name="hibernate.show_sql" value="true"/>
      <property name="hibernate.format_sql" value="true"/>
      <property name="hibernate.transaction.flush_before_completion" value="true"/>
      <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
    </properties>
  </persistence-unit>
</persistence>




/ Einde MEERDERE DATASOURCES


/ JDBC

/ lees,
https://docs.oracle.com/javase/tutorial/jdbc/basics/processingsqlstatements.html

    Statement stmt = null;
    String query = "select COF_NAME, SUP_ID, PRICE, " +
                   "SALES, TOTAL " +
                   "from " + dbName + ".COFFEES";
    try {
        stmt = con.createStatement();
        ResultSet rs = stmt.executeQuery(query);
        while (rs.next()) {
            String coffeeName = rs.getString("COF_NAME");

A Statement is an interface that represents a SQL statement. You execute Statement objects, and they generate ResultSet objects, which is a table of data representing a database result set. You need a Connection object to create a Statement object.			
Statement: Used to implement simple SQL statements with no parameters.
PreparedStatement: (Extends Statement.) Used for precompiling SQL statements that might contain input parameters. See Using Prepared Statements for more information.
CallableStatement: (Extends PreparedStatement.) Used to execute stored procedures that may contain both input and output parameters. See Stored Procedures for more information.


/ Einde JDBC

/ H2

C:\Users\ervelden\bin\for_wildfly>type h2_client1.bat
@echo off
set DIR=C:\Users\ervelden\bin\wildfly-10.1.0.Final
java -classpath %DIR%\modules\system\layers\base\com\h2database\h2\main\h2-1.3.173.jar org.h2.tools.Shell -url jdbc:h2:tcp://localhost/~/h2/test -user sa -password sa

C:\Users\ervelden\bin\for_wildfly> dir \Users\ervelden\h2
25-05-2019  20:02         1.081.344 test.h2.db
25-05-2019  20:02               104 test.lock.db

/ het is nu 27-5, en we zien 25-5	,  
/ 25-5 is de datum waarop we de h2 server hebben start, niet de datum waarop we voor het laatst bijv. een insert hebben gedaan,

/ we hebben C:\Users\ervelden\bin\for_wildfly\h2 moved naar \Users\ervelden\temp	,





/ Einde H2

/ POSTGRES

/ lees,
https://www.postgresql.org/docs/9.4/protocol.html

/ FE/BE in driver code is Frontend/Backend protocol	,

Table of Contents
49.1. Overview
49.1.1. Messaging Overview
49.1.2. Extended Query Overview
49.1.3. Formats and Format Codes
49.2. Message Flow
49.2.1. Start-up
49.2.2. Simple Query
49.2.3. Extended Query
49.2.4. Function Call
49.2.5. COPY Operations
49.2.6. Asynchronous Operations
49.2.7. Canceling Requests in Progress
49.2.8. Termination
49.2.9. SSL Session Encryption
49.3. Streaming Replication Protocol
49.4. Message Data Types
49.5. Message Formats
49.6. Error and Notice Message Fields
49.7. Summary of Changes since Protocol 2.0

/ lees,
https://www.postgresql.org/docs/9.6/protocol-overview.html

Within normal operation, SQL commands can be executed through either of two sub-protocols. In the "simple query" protocol, the frontend just sends a textual query string, which is parsed and immediately executed by the backend. In the "extended query" protocol, processing of queries is separated into multiple steps: parsing, binding of parameter values, and execution. This offers flexibility and performance benefits, at the cost of extra complexity.


/ 13	. 

/ lees,
https://www.postgresql.org/docs/9.6/protocol-overview.html

/ select, update, insert zijn statements,
/ order by, where	, join zijn clauses	,


/ 13	. 

/ lees,
https://blog.hackeriet.no/Simple-and-Extended-postgresql-queries/

Extended protocol
The extended protocol is a bit more complex, but in return you get better type safety and less exposure to sql injections.

The sending of queries is split into five steps

Parse
Describe
Bind
Execute
Sync

/ 13	. 

/ het is 
\c db user
/ we zijn in db test als eric	,
test=> \c - postgres
Password for user postgres: vi_lang17
You are now connected to database "test" as user "postgres".

test=> \c - eric

test=> \dnS+
                                     List of schemas
        Name        |  Owner   |  Access privileges   |           Description
--------------------+----------+----------------------+----------------------------------
 information_schema | postgres | postgres=UC/postgres+|
                    |          | =U/postgres          |
 pg_catalog         | postgres | postgres=UC/postgres+| system catalog schema
                    |          | =U/postgres          |
 pg_temp_1          | postgres |                      |
 pg_temp_4          | postgres |                      |
 pg_toast           | postgres |                      | reserved schema for TOAST tables
 pg_toast_temp_1    | postgres |                      |
 pg_toast_temp_4    | postgres |                      |
 public             | postgres | postgres=UC/postgres+| standard public schema
                    |          | =UC/postgres         |
 sch1               | postgres | postgres=UC/postgres+|
                    |          | =C/postgres          |
 sch2               | postgres |                      |
(10 rows)

/ Dus information_schema, pg_catalog zijn schemas in de test db,

test=> select*from pg_catalog.pg_type;
/ of,
test=> select*from pg_type;
test=> \dt pg_catalog.

test=> \d pg_catalog.
/ doet \d op alle tables in pg_catalog !






/ Einde POSTGRES 

/ WILDFLY 

/ 7	. 

/ beter, na enlistResource, b in 
SequenceStructure$1 [line: 96] - buildCallback(SessionImplementor)	

/ we hebben ook b in ,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeQuery() line: 350	


/ inmiddels niet meer,
/ we hebben na enlistResource , b set in 
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 173

/ Hier stop hij meteen al als je wildfly start, 
/s,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 173	
org.postgresql.jdbc42.Jdbc42Statement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 615	
org.postgresql.jdbc42.Jdbc42Statement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(java.lang.String, int) line: 451	
org.postgresql.jdbc42.Jdbc42Statement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeQuery(java.lang.String) line: 331	
org.postgresql.jdbc42.Jdbc42DatabaseMetaData(org.postgresql.jdbc2.AbstractJdbc2DatabaseMetaData).getTypeInfo() line: 3977	
            sql = "SELECT t.typname,t.oid FROM pg_catalog.pg_type t"
            	+ " JOIN pg_catalog.pg_namespace n ON (t.typnamespace = n.oid) "
            	+ " WHERE n.nspname != 'pg_toast'";
				
/ we doen in psql	,
test=> SELECT t.typname,t.oid FROM pg_catalog.pg_type t;
                typname                |  oid
---------------------------------------+-------
 bool                                  |    16
 bytea                                 |    17
 char                                  |    18
 name                                  |    19
 int8                                  |    20
...

/ de oid property moet je zelf geven, komt niet mee met *	,

select oid,*
from pg_type;
oid            | 20
typname        | int8
typnamespace   | 11
typowner       | 10
typlen         | 8
typbyval       | t
...

/ Ga als die queries na bij start wildfly,
/ TODO

/ Einde WILDFLY








/ See DEBUG CHAMELEON TEST IN WILDFLY
/ See JBOSS LOGGING

/ 7	. 

/ eclipse:
C:\Users\ervelden\eclipse\jbosstools-jee-oxygen\eclipse>
/ workspace:
/C:/Users/ervelden/eclipse/workspace-jbosstools-jee-oxygen

C:\Users\ervelden\eclipse\workspace-jbosstools-jee-oxygen>forge

/ als je in een project bent , zie je andere commands beschikbaar	,

[workspace-jbosstools-jee-oxygen]$ project-new --named arquillian-forge4 --type jar --stack JAVA_EE_7	/ je kunt ook --type wildfly-swarm
***SUCCESS*** Project named 'arquillian-forge4' has been created.
***SUCCESS*** Stack 'Java EE 7' installed in project
[arquillian-forge4]$														/ geef TAB 
Display all 142 possibilities? (y or n)
about                                          java-new-annotation
addon-add-dependency                           java-new-class
addon-build-and-install                        java-new-enum
addon-install                                  java-new-enum-const
addon-install-from-catalog                     java-new-exception
addon-install-from-git                         java-new-field
addon-list                                     java-new-interface
addon-new-ui-command                           java-new-method
addon-remove                                   java-new-package
addon-search                                   java-set-default-formatter
addon-test-setup                               javaee-setup
addon-update                                   jdbc-add-dependency
addon-watch-start                              jms-setup
alias                                          jpa-generate-daos-from-entities
archetype-add                                  jpa-new-embeddable
archetype-list                                 jpa-new-entity
archetype-remove                               jpa-new-entity-listener
arquillian-add                                 jpa-new-field
arquillian-setup                               jpa-new-mapped-superclass
build                                          jpa-setup
cat                                            jstl-setup
cd                                             jta-setup
cdi-add-injection-point                        less
cdi-add-observer-method                        ls
cdi-new-annotation-literal                     man
cdi-new-bean                                   mdb-add-activation-config-property
cdi-new-decorator                              mdb-remove-activation-config-property
cdi-new-extension                              mkdir
cdi-new-interceptor                            more
cdi-new-interceptor-binding                    mv
cdi-new-qualifier                              open
cdi-new-scope                                  project-add-dependencies
cdi-new-stereotype                             project-add-managed-dependencies
cdi-setup                                      project-add-repository
clear                                          project-has-dependencies
command-list                                   project-has-managed-dependencies
config-clear                                   project-list-facets
config-list                                    project-list-stacks
config-set                                     project-new
connection-create-profile                      project-remove-dependencies
connection-remove-profile                      project-remove-managed-dependencies
constraint-add                                 project-remove-repository
constraint-new-annotation                      project-set-compiler-version
constraint-new-group                           pwd
constraint-new-payload                         rest-generate-endpoints-from-entities
constraint-setup                               rest-new-cross-origin-resource-sharing-filter
cp                                             rest-new-endpoint
date                                           rest-setup
echo                                           rm
edit                                           run
ejb-new-bean                                   scaffold-generate
ejb-set-class-transaction-attribute            scaffold-setup
ejb-set-method-transaction-attribute           service-register-as-serviceloader
ejb-setup                                      servlet-new-filter
exit                                           servlet-new-servlet
export                                         servlet-setup
faces-new-bean                                 soap-new-service
faces-new-converter                            soap-setup
faces-new-validator                            system-property-get
faces-new-validator-method                     system-property-set
faces-setup                                    testing-setup
forge-update                                   touch
git-clone                                      track-changes
git-setup                                      transaction-start
grep                                           unalias
java-add-annotation                            version
java-add-enum-const                            wait
java-format-sources                            websocket-new-server-endpoint
java-generate-equals-and-hashcode              websocket-setup
java-generate-getters-and-setters              wildfly-swarm-list-fractions
java-generate-serialversionuid                 wildfly-swarm-setup
[arquillian-forge4]$ cd ..													/ we gaan weer even terug	,
[workspace-jbosstools-jee-oxygen]$
about                         cat                           export                        project-new
addon-build-and-install       cd                            forge-update                  pwd
addon-install                 clear                         git-clone                     rm
addon-install-from-catalog    command-list                  grep                          run
addon-install-from-git        config-clear                  java-format-sources           system-property-get
addon-list                    config-list                   java-set-default-formatter    system-property-set
addon-remove                  config-set                    less                          touch
addon-search                  connection-create-profile     ls                            track-changes
addon-update                  connection-remove-profile     man                           transaction-start
addon-watch-start             cp                            mkdir                         unalias
alias                         date                          more                          version
archetype-add                 echo                          mv                            wait
archetype-list                edit                          open                          wildfly-swarm-list-fractions
archetype-remove              exit                          project-list-stacks
[workspace-jbosstools-jee-oxygen]$ cd arquillian-forge4
[arquillian-forge4]$ cdi-new-bean
--alternative     --implements      --qualifier       --target-package
--extends         --named           --scoped          --with-named
[arquillian-forge4]$ cdi-new-bean
--alternative     --implements      --qualifier       --target-package
--extends         --named           --scoped          --with-named
[arquillian-forge4]$ cdi-new-bean sc
--alternative     --implements      --qualifier       --target-package
--extends         --named           --scoped          --with-named
[arquillian-forge4]$ cdi-new-bean scp
--alternative     --implements      --qualifier       --target-package
--extends         --named           --scoped          --with-named

[workspace-jbosstools-jee-oxygen]$ cd arquillian-forge4
[arquillian-forge4]$ cdi-new-bean --scoped
APPLICATION  CONVERSATION  CUSTOM  DEPENDENT  REQUEST  SESSION
[arquillian-forge4]$ arquillian-setup
--arquillian-version  --standalone  --test-framework
[arquillian-forge4]$ arquillian-setup
--arquillian-version  --standalone  --test-framework
[arquillian-forge4]$ arquillian-setup
--arquillian-version  --standalone  --test-framework
[arquillian-forge4]$ arquillian-setup --test-framework
junit  testng
[arquillian-forge4]$ arquillian-setup --test-framework junit --
--arquillian-version  --container-adapter  --standalone  --test-framework-version
[arquillian-forge4]$ arquillian-setup --test-framework junit --container-adapter
droidium-container-depchain  jboss-eap-embedded-7         payara-remote                weld-ee-embedded-1.1
glassfish-embedded           jboss-eap-managed-7          tomcat-embedded-6            weld-se-embedded-1
glassfish-managed            jboss-eap-remote-7           tomcat-embedded-7            weld-se-embedded-1.1
glassfish-remote             jetty-embedded-6.1           tomcat-managed               wildfly-domain-managed
jboss-as-domain-managed-7    jetty-embedded-7             tomcat-managed-5.5           wildfly-domain-remote
jboss-as-domain-remote-7     openejb-embedded-3.1         tomcat-remote                wildfly-embedded
jboss-as-embedded-7          openejb-embedded-4           tomee-embedded               wildfly-managed
jboss-as-managed-7           openshift-express            tomee-remote                 wildfly-remote
jboss-as-remote-7            openwebbeans-embedded-1      was-embedded-8               wls-remote-10.3
jboss-eap-domain-managed-7   payara-embedded              was-remote-7
jboss-eap-domain-remote-7    payara-managed               was-remote-8
[arquillian-forge4]$ arquillian-setup --test-framework junit --container-adapter
droidium-container-depchain  jboss-eap-embedded-7         payara-remote                weld-ee-embedded-1.1
glassfish-embedded           jboss-eap-managed-7          tomcat-embedded-6            weld-se-embedded-1
glassfish-managed            jboss-eap-remote-7           tomcat-embedded-7            weld-se-embedded-1.1
glassfish-remote             jetty-embedded-6.1           tomcat-managed               wildfly-domain-managed
jboss-as-domain-managed-7    jetty-embedded-7             tomcat-managed-5.5           wildfly-domain-remote
jboss-as-domain-remote-7     openejb-embedded-3.1         tomcat-remote                wildfly-embedded
jboss-as-embedded-7          openejb-embedded-4           tomee-embedded               wildfly-managed
jboss-as-managed-7           openshift-express            tomee-remote                 wildfly-remote
jboss-as-remote-7            openwebbeans-embedded-1      was-embedded-8               wls-remote-10.3
jboss-eap-domain-managed-7   payara-embedded              was-remote-7
jboss-eap-domain-remote-7    payara-managed               was-remote-8
[arquillian-forge4]$ arquillian-setup --test-framework junit --container-adapter wildfly-remote
***SUCCESS*** Arquillian setup complete
***SUCCESS*** Installed Arquillian Universe 1.1.13.0
***SUCCESS*** Installed junit
***SUCCESS*** Installed Arquillian Container WildFly Remote
***SUCCESS*** Installed Arquillian Container WildFly Remote dependencies
[arquillian-forge4]$

/ import in eclipse,

$ vi src/test/resources/arquillian.xml

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<arquillian xmlns="http://jboss.org/schema/arquillian" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
  <container default="true" qualifier="arquillian-wildfly-remote">
    <configuration>
      <property name="chameleonTarget">${chameleon.target}</property>
    </configuration>
  </container>
</arquillian>
/ OK	,

[persistence.xml]$ jpa-setup --db-type POSTGRES --data-source-name java:jboss/datasources/PostgreSQLDS

$ vi src/main/resources/persistence.xml

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
  <persistence-unit name="arquillian-forge4-persistence-unit" transaction-type="JTA">
    <description>Forge Persistence Unit</description>
    <provider>org.hibernate.ejb.HibernatePersistence</provider>
    <jta-data-source>java:jboss/datasources/PostgreSQLDS</jta-data-source>
    <exclude-unlisted-classes>false</exclude-unlisted-classes>
    <properties>
      <property name="hibernate.hbm2ddl.auto" value="create-drop"/>
      <property name="hibernate.show_sql" value="true"/>
      <property name="hibernate.format_sql" value="true"/>
      <property name="hibernate.transaction.flush_before_completion" value="true"/>
      <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
    </properties>
  </persistence-unit>
</persistence>

[persistence.xml]$ jpa-new-entity --named Language --target-package domain
[Language.java]$ jpa-new-field --named name --
--column-name     --lob             --not-nullable    --target-entity   --type
--length          --not-insertable  --not-updatable   --transient
/ --type String is de default,

[arquillian-forge4]$ jpa-generate-daos-from-entities --targets domain.Language --
--generator  --package-name  --persistence-unit
[arquillian-forge4]$ jpa-generate-daos-from-entities --targets domain.Language --package-name repository
***SUCCESS*** Dao created
/ we hebben nu maar 1 pu	, dus we hoeven niet --persistence-unit	, en --generator is default JPA_ENTITY, dus die hoeft ook niet,

$ vi src/main/java/repository/LanguageDao.java

@Stateless
public class LanguageDao {
	@PersistenceContext(unitName = "arquillian-forge4-persistence-unit")
	private EntityManager em;
...
	// self,
	@PostConstruct
	public void inserts() {
		Language l=new Language();
		l.setName("Java");
		em.persist(l);
		l=new Language();
		l.setName("Go");
		em.persist(l);
		l=new Language();
		l.setName("C++");
		em.persist(l);
	}
	public List<Language>findLanguages(){
		Query q=em.createQuery(
				"select l "								// let op space achteraan	,
				+ "from Language l"
				);
		List<Language>ls=q.getResultList();
		return ls;
	}
}


/ we maken een tweede ds,
[LanguageDao.java]$ jpa-setup --db-type H2 --data-source-name java:jboss/datasources/RemoteExampleDS
***SUCCESS*** Persistence (JPA) is installed.

/ 13	. 

/ we doen eerst zonder --enable-jpa,
[LanguageTest.java]$ arquillian-create-test --targets repository.LanguageDao
***SUCCESS*** Created test class repository.LanguageDaoTest

$ vi src/test/java/repository/LanguageDaoTest.java

package repository;

import repository.LanguageDao;

import javax.inject.Inject;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;
import static org.hamcrest.core.Is.*;

@RunWith(Arquillian.class)
public class LanguageDaoTest {

	@Inject
	private LanguageDao languageDao;

	@Deployment
	public static JavaArchive createDeployment() {
		return ShrinkWrap.create(JavaArchive.class).addClass(LanguageDao.class)
				.addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
	}

	@Test
	public void should_be_deployed() {
		Assert.assertNotNull(languageDao);
	}
}
/ we zien geen persistence.xml,

/ we doen vervolgens	,
[LanguageDaoTest.java]$ arquillian-create-test --targets repository.LanguageDao --enable-jpa
***SUCCESS*** Created test class repository.LanguageDaoTest

$ vi src/test/java/repository/LanguageDaoTest.java

package repository;

import repository.LanguageDao;

import javax.inject.Inject;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;
import static org.hamcrest.core.Is.*;

@RunWith(Arquillian.class)
public class LanguageDaoTest {

	@Inject
	private LanguageDao languageDao;

	@Deployment
	public static JavaArchive createDeployment() {
		return ShrinkWrap
				.create(JavaArchive.class)
				.addClass(LanguageDao.class)
				.addAsManifestResource("META-INF/persistence.xml",
						"persistence.xml")
				.addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
	}

	@Test
	public void should_be_deployed() {
		Assert.assertNotNull(languageDao);
	}
}
/ nu zien we persistence.xml,

/ we doen,
		return ShrinkWrap
				.create(JavaArchive.class)
				.addClass(LanguageDao.class)
				.addClass(Language.class)										<-
				.addAsManifestResource("META-INF/persistence.xml",
						"persistence.xml")
						
/ we hadden al wildfly start,


/ we doen in forge,	
[LanguageDaoTest.java]$ build test

[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building arquillian-forge4 1.0.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ arquillian-forge4 ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ arquillian-forge4 ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to C:\Users\ervelden\eclipse\workspace-jbosstools-jee-oxygen\arquillian-forge4\target\classes
[WARNING] /C:/Users/ervelden/eclipse/workspace-jbosstools-jee-oxygen/arquillian-forge4/src/main/java/repository/LanguageDao.java
: C:\Users\ervelden\eclipse\workspace-jbosstools-jee-oxygen\arquillian-forge4\src\main\java\repository\LanguageDao.java uses unc
hecked or unsafe operations.
[WARNING] /C:/Users/ervelden/eclipse/workspace-jbosstools-jee-oxygen/arquillian-forge4/src/main/java/repository/LanguageDao.java
: Recompile with -Xlint:unchecked for details.
[INFO]
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ arquillian-forge4 ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ arquillian-forge4 ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to C:\Users\ervelden\eclipse\workspace-jbosstools-jee-oxygen\arquillian-forge4\target\test-class
es
[INFO]
[INFO] --- maven-surefire-plugin:2.14.1:test (default-test) @ arquillian-forge4 ---
[INFO] Surefire report directory: C:\Users\ervelden\eclipse\workspace-jbosstools-jee-oxygen\arquillian-forge4\target\surefire-re
ports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running domain.LanguageTest
mrt 09, 2018 8:12:42 AM org.xnio.Xnio <clinit>
INFO: XNIO version 3.3.4.Final
mrt 09, 2018 8:12:42 AM org.xnio.nio.NioXnio <clinit>
INFO: XNIO NIO Implementation Version 3.3.4.Final
mrt 09, 2018 8:12:43 AM org.jboss.remoting3.EndpointImpl <clinit>
INFO: JBoss Remoting version 4.0.18.Final
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.954 sec
Running repository.LanguageDaoTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.689 sec

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 9.241 s
[INFO] Finished at: 2018-03-09T08:12:46+01:00
[INFO] Final Memory: 49M/272M
[INFO] ------------------------------------------------------------------------
***SUCCESS*** Build Success

/ we zien in wildfly,

08:12:44,116 INFO  [org.jboss.as.repository] (management-handler-thread - 13) WFLYDR0001: Content added at location C:\Users\erv
elden\bin\wildfly-10.1.0.Final\standalone\data\content\de\a28cf7908051937ff33fea974ae536dc6a6304\content
08:12:44,116 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-2) WFLYSRV0027: Starting deployment of "test.war" (run
time-name: "test.war")
08:12:44,256 INFO  [org.jboss.weld.deployer] (MSC service thread 1-4) WFLYWELD0003: Processing weld deployment test.war
08:12:44,428 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 84) WFLYUT0021: Registered web context: /test
08:12:44,459 INFO  [org.jboss.as.server] (management-handler-thread - 13) WFLYSRV0010: Deployed "test.war" (runtime-name : "test
.war")
08:12:44,693 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 84) WFLYUT0022: Unregistered web context: /tes
t
08:12:44,740 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-4) WFLYSRV0028: Stopped deployment test.war (runtime-n
ame: test.war) in 41ms
08:12:44,756 WARN  [org.jboss.as.controller] (management-handler-thread - 14) WFLYCTL0357: Notification of type deployment-undep
loyed is not described for the resource at the address []
08:12:44,771 INFO  [org.jboss.as.repository] (management-handler-thread - 14) WFLYDR0002: Content removed from location C:\Users
\ervelden\bin\wildfly-10.1.0.Final\standalone\data\content\de\a28cf7908051937ff33fea974ae536dc6a6304\content
08:12:44,771 INFO  [org.jboss.as.server] (management-handler-thread - 14) WFLYSRV0009: Undeployed "test.war" (runtime-name: "tes
t.war")
08:12:45,273 INFO  [org.jboss.as.repository] (management-handler-thread - 15) WFLYDR0001: Content added at location C:\Users\erv
elden\bin\wildfly-10.1.0.Final\standalone\data\content\f3\b164f0742409893fa4f905becea972eb5b4953\content
08:12:45,273 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-6) WFLYSRV0027: Starting deployment of "test.war" (run
time-name: "test.war")
08:12:45,383 INFO  [org.jboss.as.jpa] (MSC service thread 1-5) WFLYJPA0002: Read persistence.xml for arquillian-forge4-persisten
ce-unit
08:12:45,383 INFO  [org.jboss.as.jpa] (MSC service thread 1-5) WFLYJPA0002: Read persistence.xml for arquillian-forge4-persisten
ce-unit-1
08:12:45,398 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 82) WFLYJPA0010: Starting Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:12:45,398 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 85) WFLYJPA0010: Starting Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:12:45,398 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 82) HHH000204: Processing Persisten
ceUnitInfo [
        name: arquillian-forge4-persistence-unit-1
        ...]
08:12:45,398 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 85) HHH000204: Processing Persisten
ceUnitInfo [
        name: arquillian-forge4-persistence-unit
        ...]
08:12:45,414 INFO  [org.jboss.weld.deployer] (MSC service thread 1-3) WFLYWELD0003: Processing weld deployment test.war
08:12:45,414 WARN  [org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl] (ServerService Thread Pool -- 82) HHH000059
: Defining hibernate.transaction.flush_before_completion=true ignored in HEM
08:12:45,414 WARN  [org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl] (ServerService Thread Pool -- 85) HHH000059
: Defining hibernate.transaction.flush_before_completion=true ignored in HEM
08:12:45,429 INFO  [org.jboss.as.ejb3.deployment] (MSC service thread 1-3) WFLYEJB0473: JNDI bindings for session bean named 'La
nguageDao' in deployment unit 'deployment "test.war"' are as follows:

        java:global/test/LanguageDao!repository.LanguageDao
        java:app/test/LanguageDao!repository.LanguageDao
        java:module/LanguageDao!repository.LanguageDao
        java:global/test/LanguageDao
        java:app/test/LanguageDao
        java:module/LanguageDao

08:12:45,507 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 82) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:12:45,507 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 85) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:12:45,523 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 85) HHH000400: Using dialect: org.hibernate.dia
lect.H2Dialect
08:12:45,523 WARN  [org.hibernate.dialect.H2Dialect] (ServerService Thread Pool -- 85) HHH000431: Unable to determine H2 databas
e version, certain features may not work
08:12:45,601 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 85) Envers integration e
nabled? : true
08:12:45,617 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 85) HHH000227: Running hbm2ddl schema
 export
08:12:45,617 INFO  [stdout] (ServerService Thread Pool -- 85) Hibernate:
08:12:45,617 INFO  [stdout] (ServerService Thread Pool -- 85)     drop table Language if exists
08:12:45,617 INFO  [stdout] (ServerService Thread Pool -- 85) Hibernate:
08:12:45,617 INFO  [stdout] (ServerService Thread Pool -- 85)     drop sequence if exists hibernate_sequence
08:12:45,617 INFO  [stdout] (ServerService Thread Pool -- 85) Hibernate:
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)     create sequence hibernate_sequence start with 1 increment by 1

08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85) Hibernate:
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)     create table Language (
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)         id bigint not null,
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)         name varchar(255),
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)         version integer,
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)         primary key (id)
08:12:45,632 INFO  [stdout] (ServerService Thread Pool -- 85)     )
08:12:45,648 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 85) HHH000230: Schema export complete

08:12:45,866 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 82) HHH000400: Using dialect: org.hibernate.dia
lect.PostgreSQLDialect
08:12:46,023 INFO  [org.hibernate.engine.jdbc.env.internal.LobCreatorBuilderImpl] (ServerService Thread Pool -- 82) HHH000424: D
isabling contextual LOB creation as createClob() method threw error : java.lang.reflect.InvocationTargetException
08:12:46,039 INFO  [org.hibernate.type.BasicTypeRegistry] (ServerService Thread Pool -- 82) HHH000270: Type registration [java.u
til.UUID] overrides previous : org.hibernate.type.UUIDBinaryType@55822d89
08:12:46,039 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 82) Envers integration e
nabled? : true
08:12:46,054 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 82) HHH000227: Running hbm2ddl schema
 export
08:12:46,054 INFO  [stdout] (ServerService Thread Pool -- 82) Hibernate:
08:12:46,054 INFO  [stdout] (ServerService Thread Pool -- 82)     drop table if exists Language cascade
08:12:46,070 INFO  [stdout] (ServerService Thread Pool -- 82) Hibernate:
08:12:46,070 INFO  [stdout] (ServerService Thread Pool -- 82)     drop sequence hibernate_sequence
08:12:46,070 INFO  [stdout] (ServerService Thread Pool -- 82) Hibernate:
08:12:46,070 INFO  [stdout] (ServerService Thread Pool -- 82)     create sequence hibernate_sequence start 1 increment 1
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82) Hibernate:
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82)     create table Language (
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82)         id int8 not null,
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82)         name varchar(255),
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82)         version int4,
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82)         primary key (id)
08:12:46,086 INFO  [stdout] (ServerService Thread Pool -- 82)     )
08:12:46,117 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 82) HHH000230: Schema export complete

08:12:46,226 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 85) WFLYUT0021: Registered web context: /test
08:12:46,242 INFO  [org.jboss.as.server] (management-handler-thread - 15) WFLYSRV0010: Deployed "test.war" (runtime-name : "test
.war")
08:12:46,366 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 85) WFLYUT0022: Unregistered web context: /tes
t
08:12:46,382 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 85) WFLYJPA0011: Stopping Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:12:46,382 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 84) WFLYJPA0011: Stopping Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:12:46,382 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 85) HHH000227: Running hbm2ddl schema
 export
08:12:46,382 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 84) HHH000227: Running hbm2ddl schema
 export
08:12:46,382 INFO  [stdout] (ServerService Thread Pool -- 85) Hibernate:
08:12:46,382 INFO  [stdout] (ServerService Thread Pool -- 85)     drop table Language if exists
08:12:46,382 INFO  [stdout] (ServerService Thread Pool -- 84) Hibernate:
08:12:46,382 INFO  [stdout] (ServerService Thread Pool -- 84)     drop table if exists Language cascade
08:12:46,398 INFO  [stdout] (ServerService Thread Pool -- 85) Hibernate:
08:12:46,398 INFO  [stdout] (ServerService Thread Pool -- 85)     drop sequence if exists hibernate_sequence
08:12:46,398 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 85) HHH000230: Schema export complete

08:12:46,398 INFO  [stdout] (ServerService Thread Pool -- 84) Hibernate:
08:12:46,398 INFO  [stdout] (ServerService Thread Pool -- 84)     drop sequence hibernate_sequence
08:12:46,413 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 85) WFLYJPA0011: Stopping Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:12:46,413 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 84) HHH000230: Schema export complete

08:12:46,413 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 84) WFLYJPA0011: Stopping Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:12:46,444 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-4) WFLYSRV0028: Stopped deployment test.war (runtime-n
ame: test.war) in 75ms
08:12:46,460 WARN  [org.jboss.as.controller] (management-handler-thread - 13) WFLYCTL0357: Notification of type deployment-undep
loyed is not described for the resource at the address []
08:12:46,476 INFO  [org.jboss.as.repository] (management-handler-thread - 13) WFLYDR0002: Content removed from location C:\Users
\ervelden\bin\wildfly-10.1.0.Final\standalone\data\content\f3\b164f0742409893fa4f905becea972eb5b4953\content
08:12:46,476 INFO  [org.jboss.as.server] (management-handler-thread - 13) WFLYSRV0009: Undeployed "test.war" (runtime-name: "tes
t.war")

/ 13	. 

/ we maken een test,

$ vi src/test/java/repository/LanguageDaoTest.java

	@Test
	public void listLanguages() {
		List<Language>ls=languageDao.findLanguages();
		assertEquals(3, ls.size());
	}
	
/ 1313	. 

/ we hadden geen space achter "select l" in LanguageDao	, 
/ daarom stack trace	, 

[LanguageDaoTest.java]$ build test

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running domain.LanguageTest
mrt 09, 2018 8:21:55 AM org.xnio.Xnio <clinit>
INFO: XNIO version 3.3.4.Final
mrt 09, 2018 8:21:56 AM org.xnio.nio.NioXnio <clinit>
INFO: XNIO NIO Implementation Version 3.3.4.Final
mrt 09, 2018 8:21:56 AM org.jboss.remoting3.EndpointImpl <clinit>
INFO: JBoss Remoting version 4.0.18.Final
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.513 sec
Running repository.LanguageDaoTest
Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 1.749 sec <<< FAILURE!
listLanguages(repository.LanguageDaoTest)  Time elapsed: 0.484 sec  <<< ERROR!
javax.ejb.EJBException: java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: unexpected toke
n: Language near line 1, column 14 [select lfrom Language l]
        at org.hibernate.hql.internal.ast.QuerySyntaxException.convert(QuerySyntaxException.java:74)
        at org.hibernate.hql.internal.ast.ErrorCounter.throwQueryException(ErrorCounter.java:91)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.parse(QueryTranslatorImpl.java:288)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:187)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:142)
        at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:115)
        at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:76)
        at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:150)
        at org.hibernate.internal.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:302)
        at org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:240)
        at org.hibernate.internal.SessionImpl.createQuery(SessionImpl.java:1894)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:291)
        at org.jboss.as.jpa.container.AbstractEntityManager.createQuery(AbstractEntityManager.java:445)
        at repository.LanguageDao.findLanguages(LanguageDao.java:67)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(ManagedReferenceMethodInterceptor.java:
52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(Jsr299BindingsInterceptor.java:82)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(Jsr299BindingsInterceptor.java:93)
        at org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(UserInterceptorFactory.java:63)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(ExecutionTimeInterceptor.jav
a:43)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(SBInvocationInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor.aroundInvoke(AbstractEJBRequestScopeActivationInterce
ptor.java:64)
        at org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(EjbRequestScopeActivationInterceptor.jav
a:83)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(ConcurrentContextInterceptor.java:45)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InitialInterceptor.processInvocation(InitialInterceptor.java:21)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(ComponentDispatcherIntercepto
r.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(PooledInstanceInterceptor.java:51)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:275)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.required(CMTTxInterceptor.java:327)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(CMTTxInterceptor.java:239)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(CurrentInvocationConte
xtInterceptor.java:41)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(WaitTimeInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(SecurityContextInterceptor.java:100)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(StartupAwaitInterceptor.java:22)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.ja
va:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:67)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java
:54)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:636)
        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:198)
        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)
        at repository.LanguageDao$$$view3.findLanguages(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(Reflections.java:433)
        at org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler.invoke(EnterpriseBeanProxyMethodHandler.java:128)
        at org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance.invoke(EnterpriseTargetBeanInstance.java:56)
        at org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(InjectionPointPropagatingEnter
priseTargetBeanInstance.java:67)
        at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:100)
        at repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.findLanguages(Unknown Source)
        at repository.LanguageDaoTest.listLanguages(LanguageDaoTest.java:47)


Results :

Tests in error:
  LanguageDaoTest.listLanguages:47 ╗ EJB java.lang.IllegalArgumentException: org...

Tests run: 3, Failures: 0, Errors: 1, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.846 s
[INFO] Finished at: 2018-03-09T08:21:59+01:00
[INFO] Final Memory: 49M/297M
[INFO] ------------------------------------------------------------------------
[SEVERE] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.14.1:test (default-test) on project arquillian-
forge4: There are test failures.
[SEVERE]
[SEVERE] Please refer to C:\Users\ervelden\eclipse\workspace-jbosstools-jee-oxygen\arquillian-forge4\target\surefire-reports for
 the individual test results.
[SEVERE] -> [Help 1]
[SEVERE]
[SEVERE] To see the full stack trace of the errors, re-run Maven with the -e switch.
[SEVERE] Re-run Maven using the -X switch to enable full debug logging.
[SEVERE]
[SEVERE] For more information about the errors and possible solutions, please read the following articles:
[SEVERE] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
***ERROR*** Error while executing 'Build'
***INFO*** (type "export VERBOSE=true" to enable stack traces)
***ERROR*** Build failed.

/ in wildfly zien we,

08:21:56,835 INFO  [org.jboss.as.repository] (management-handler-thread - 17) WFLYDR0001: Content added at location C:\Users\erv
elden\bin\wildfly-10.1.0.Final\standalone\data\content\6a\9dba50a2450c849002a9c7a45c96b87bb7242f\content
08:21:56,835 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-8) WFLYSRV0027: Starting deployment of "test.war" (run
time-name: "test.war")
08:21:57,055 INFO  [org.jboss.weld.deployer] (MSC service thread 1-6) WFLYWELD0003: Processing weld deployment test.war
08:21:57,211 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 88) WFLYUT0021: Registered web context: /test
08:21:57,226 INFO  [org.jboss.as.server] (management-handler-thread - 17) WFLYSRV0010: Deployed "test.war" (runtime-name : "test
.war")
08:21:57,492 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 88) WFLYUT0022: Unregistered web context: /tes
t
08:21:57,538 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-8) WFLYSRV0028: Stopped deployment test.war (runtime-n
ame: test.war) in 50ms
08:21:57,570 WARN  [org.jboss.as.controller] (management-handler-thread - 18) WFLYCTL0357: Notification of type deployment-undep
loyed is not described for the resource at the address []
08:21:57,570 INFO  [org.jboss.as.repository] (management-handler-thread - 18) WFLYDR0002: Content removed from location C:\Users
\ervelden\bin\wildfly-10.1.0.Final\standalone\data\content\6a\9dba50a2450c849002a9c7a45c96b87bb7242f\content
08:21:57,570 INFO  [org.jboss.as.server] (management-handler-thread - 18) WFLYSRV0009: Undeployed "test.war" (runtime-name: "tes
t.war")
08:21:58,195 INFO  [org.jboss.as.repository] (management-handler-thread - 19) WFLYDR0001: Content added at location C:\Users\erv
elden\bin\wildfly-10.1.0.Final\standalone\data\content\4c\32b08b68a92cbc9dfbcb1e2e9991e9f2f3ac1f\content
08:21:58,210 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-5) WFLYSRV0027: Starting deployment of "test.war" (run
time-name: "test.war")
08:21:58,304 INFO  [org.jboss.as.jpa] (MSC service thread 1-8) WFLYJPA0002: Read persistence.xml for arquillian-forge4-persisten
ce-unit
08:21:58,304 INFO  [org.jboss.as.jpa] (MSC service thread 1-8) WFLYJPA0002: Read persistence.xml for arquillian-forge4-persisten
ce-unit-1
08:21:58,319 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 87) WFLYJPA0010: Starting Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:21:58,319 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 87) HHH000204: Processing Persisten
ceUnitInfo [
        name: arquillian-forge4-persistence-unit-1
        ...]
08:21:58,319 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 90) WFLYJPA0010: Starting Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:21:58,319 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 90) HHH000204: Processing Persisten
ceUnitInfo [
        name: arquillian-forge4-persistence-unit
        ...]
08:21:58,335 WARN  [org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl] (ServerService Thread Pool -- 87) HHH000059
: Defining hibernate.transaction.flush_before_completion=true ignored in HEM
08:21:58,335 WARN  [org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl] (ServerService Thread Pool -- 90) HHH000059
: Defining hibernate.transaction.flush_before_completion=true ignored in HEM
08:21:58,335 INFO  [org.jboss.weld.deployer] (MSC service thread 1-2) WFLYWELD0003: Processing weld deployment test.war
08:21:58,351 INFO  [org.jboss.as.ejb3.deployment] (MSC service thread 1-2) WFLYEJB0473: JNDI bindings for session bean named 'La
nguageDao' in deployment unit 'deployment "test.war"' are as follows:

        java:global/test/LanguageDao!repository.LanguageDao
        java:app/test/LanguageDao!repository.LanguageDao
        java:module/LanguageDao!repository.LanguageDao
        java:global/test/LanguageDao
        java:app/test/LanguageDao
        java:module/LanguageDao

08:21:58,382 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 87) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:21:58,382 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 90) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:21:58,382 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 87) HHH000400: Using dialect: org.hibernate.dia
lect.PostgreSQLDialect
08:21:58,382 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 90) HHH000400: Using dialect: org.hibernate.dia
lect.H2Dialect
08:21:58,382 WARN  [org.hibernate.dialect.H2Dialect] (ServerService Thread Pool -- 90) HHH000431: Unable to determine H2 databas
e version, certain features may not work
08:21:58,397 INFO  [org.hibernate.engine.jdbc.env.internal.LobCreatorBuilderImpl] (ServerService Thread Pool -- 87) HHH000424: D
isabling contextual LOB creation as createClob() method threw error : java.lang.reflect.InvocationTargetException
08:21:58,397 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 90) Envers integration e
nabled? : true
08:21:58,397 INFO  [org.hibernate.type.BasicTypeRegistry] (ServerService Thread Pool -- 87) HHH000270: Type registration [java.u
til.UUID] overrides previous : org.hibernate.type.UUIDBinaryType@55822d89
08:21:58,413 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 87) Envers integration e
nabled? : true
08:21:58,429 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 87) HHH000227: Running hbm2ddl schema
 export
08:21:58,429 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 90) HHH000227: Running hbm2ddl schema
 export
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 87) Hibernate:
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 87)     drop table if exists Language cascade
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 90) Hibernate:
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 90)     drop table Language if exists
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 87) Hibernate:
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 87)     drop sequence hibernate_sequence
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 90) Hibernate:
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 90)     drop sequence if exists hibernate_sequence
08:21:58,444 ERROR [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 87) HHH000389: Unsuccessful: drop seq
uence hibernate_sequence
08:21:58,444 ERROR [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 87) ERROR: sequence "hibernate_sequen
ce" does not exist
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 90) Hibernate:
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 90)     create sequence hibernate_sequence start with 1 increment by 1

08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 87) Hibernate:
08:21:58,444 INFO  [stdout] (ServerService Thread Pool -- 87)     create sequence hibernate_sequence start 1 increment 1
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90) Hibernate:
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90)     create table Language (
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90)         id bigint not null,
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90)         name varchar(255),
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90)         version integer,
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90)         primary key (id)
08:21:58,460 INFO  [stdout] (ServerService Thread Pool -- 90)     )
08:21:58,460 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 90) HHH000230: Schema export complete

08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87) Hibernate:
08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87)     create table Language (
08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87)         id int8 not null,
08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87)         name varchar(255),
08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87)         version int4,
08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87)         primary key (id)
08:21:58,475 INFO  [stdout] (ServerService Thread Pool -- 87)     )
08:21:58,491 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 87) HHH000230: Schema export complete

08:21:58,616 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 89) WFLYUT0021: Registered web context: /test
08:21:58,631 INFO  [org.jboss.as.server] (management-handler-thread - 19) WFLYSRV0010: Deployed "test.war" (runtime-name : "test
.war")
08:21:58,865 INFO  [stdout] (default task-19) Hibernate:
08:21:58,865 INFO  [stdout] (default task-19)     select
08:21:58,865 INFO  [stdout] (default task-19)         nextval ('hibernate_sequence')
08:21:58,912 INFO  [stdout] (default task-19) Hibernate:
08:21:58,912 INFO  [stdout] (default task-19)     select
08:21:58,912 INFO  [stdout] (default task-19)         nextval ('hibernate_sequence')
08:21:58,912 INFO  [stdout] (default task-19) Hibernate:
08:21:58,912 INFO  [stdout] (default task-19)     select
08:21:58,912 INFO  [stdout] (default task-19)         nextval ('hibernate_sequence')
08:21:58,944 INFO  [stdout] (default task-19) Hibernate:
08:21:58,944 INFO  [stdout] (default task-19)     insert
08:21:58,944 INFO  [stdout] (default task-19)     into
08:21:58,944 INFO  [stdout] (default task-19)         Language
08:21:58,944 INFO  [stdout] (default task-19)         (name, version, id)
08:21:58,944 INFO  [stdout] (default task-19)     values
08:21:58,944 INFO  [stdout] (default task-19)         (?, ?, ?)
08:21:58,960 INFO  [stdout] (default task-19) Hibernate:
08:21:58,960 INFO  [stdout] (default task-19)     insert
08:21:58,960 INFO  [stdout] (default task-19)     into
08:21:58,960 INFO  [stdout] (default task-19)         Language
08:21:58,960 INFO  [stdout] (default task-19)         (name, version, id)
08:21:58,960 INFO  [stdout] (default task-19)     values
08:21:58,960 INFO  [stdout] (default task-19)         (?, ?, ?)
08:21:58,960 INFO  [stdout] (default task-19) Hibernate:
08:21:58,960 INFO  [stdout] (default task-19)     insert
08:21:58,960 INFO  [stdout] (default task-19)     into
08:21:58,960 INFO  [stdout] (default task-19)         Language
08:21:58,960 INFO  [stdout] (default task-19)         (name, version, id)
08:21:58,960 INFO  [stdout] (default task-19)     values
08:21:58,960 INFO  [stdout] (default task-19)         (?, ?, ?)
08:21:58,976 INFO  [org.hibernate.hql.internal.QueryTranslatorFactoryInitiator] (default task-19) HHH000397: Using ASTQueryTrans
latorFactory
08:21:59,038 ERROR [org.hibernate.hql.internal.ast.ErrorCounter] (default task-19) line 1:14: unexpected token: Language
08:21:59,038 ERROR [org.hibernate.hql.internal.ast.ErrorCounter] (default task-19) line 1:14: unexpected token: Language: line 1
:14: unexpected token: Language
        at org.hibernate.hql.internal.antlr.HqlBaseParser.aliasedExpression(HqlBaseParser.java:2365)
        at org.hibernate.hql.internal.antlr.HqlBaseParser.selectedPropertiesList(HqlBaseParser.java:1372)
        at org.hibernate.hql.internal.antlr.HqlBaseParser.selectClause(HqlBaseParser.java:1282)
        at org.hibernate.hql.internal.antlr.HqlBaseParser.selectFrom(HqlBaseParser.java:1022)
        at org.hibernate.hql.internal.antlr.HqlBaseParser.queryRule(HqlBaseParser.java:730)
        at org.hibernate.hql.internal.antlr.HqlBaseParser.selectStatement(HqlBaseParser.java:323)
        at org.hibernate.hql.internal.antlr.HqlBaseParser.statement(HqlBaseParser.java:186)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.parse(QueryTranslatorImpl.java:279)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:187)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:142)
        at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:115)
        at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:76)
        at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:150)
        at org.hibernate.internal.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:302)
        at org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:240)
        at org.hibernate.internal.SessionImpl.createQuery(SessionImpl.java:1894)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:291)
        at org.jboss.as.jpa.container.AbstractEntityManager.createQuery(AbstractEntityManager.java:445)
        at repository.LanguageDao.findLanguages(LanguageDao.java:67)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(ManagedReferenceMethodInterceptor.java:
52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(Jsr299BindingsInterceptor.java:82)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(Jsr299BindingsInterceptor.java:93)
        at org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(UserInterceptorFactory.java:63)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(ExecutionTimeInterceptor.jav
a:43)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(SBInvocationInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor.aroundInvoke(AbstractEJBRequestScopeActivationInterce
ptor.java:64)
        at org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(EjbRequestScopeActivationInterceptor.jav
a:83)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(ConcurrentContextInterceptor.java:45)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InitialInterceptor.processInvocation(InitialInterceptor.java:21)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(ComponentDispatcherIntercepto
r.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(PooledInstanceInterceptor.java:51)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:275)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.required(CMTTxInterceptor.java:327)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(CMTTxInterceptor.java:239)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(CurrentInvocationConte
xtInterceptor.java:41)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(WaitTimeInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(SecurityContextInterceptor.java:100)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(StartupAwaitInterceptor.java:22)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.ja
va:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:67)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java
:54)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:636)
        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:198)
        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)
        at repository.LanguageDao$$$view3.findLanguages(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(Reflections.java:433)
        at org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler.invoke(EnterpriseBeanProxyMethodHandler.java:128)
        at org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance.invoke(EnterpriseTargetBeanInstance.java:56)
        at org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(InjectionPointPropagatingEnter
priseTargetBeanInstance.java:67)
        at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:100)
        at repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.findLanguages(Unknown Source)
        at repository.LanguageDaoTest.listLanguages(LanguageDaoTest.java:47)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
        at org.jboss.arquillian.junit.Arquillian$8$1.invoke(Arquillian.java:379)
        at org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(LocalTestExecuter.java:60)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:114)
        at org.jboss.arquillian.core.impl.EventImpl.fire(EventImpl.java:67)
        at org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(ContainerTestExecuter.java:38)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:92)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(EventTestRunnerAdaptor.java:136)
        at org.jboss.arquillian.junit.Arquillian$8.evaluate(Arquillian.java:372)
        at org.jboss.arquillian.junit.Arquillian$4.evaluate(Arquillian.java:246)
        at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:431)
        at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:55)
        at org.jboss.arquillian.junit.Arquillian$5.evaluate(Arquillian.java:260)
        at org.jboss.arquillian.junit.Arquillian$7$1.invoke(Arquillian.java:324)
        at org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(BeforeLifecycleEventExecuter.java:
35)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:92)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:114)
        at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(EventTestRunnerAdaptor.java:159)
        at org.jboss.arquillian.junit.Arquillian$7.evaluate(Arquillian.java:317)
        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.jboss.arquillian.junit.Arquillian$2.evaluate(Arquillian.java:205)
        at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:431)
        at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:55)
        at org.jboss.arquillian.junit.Arquillian$3.evaluate(Arquillian.java:219)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.jboss.arquillian.junit.Arquillian.run(Arquillian.java:167)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.jboss.arquillian.junit.container.JUnitTestRunner.execute(JUnitTestRunner.java:66)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(ServletTestRunner.java:170)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(ServletTestRunner.java:135)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(ServletTestRunner.java:98)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
        at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85)
        at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
        at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
        at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHan
dler.java:78)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler
.java:131)
        at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler
.java:57)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
        at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityCon
straintHandler.java:64)
        at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)
        at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandl
er.java:77)
        at io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(NotificationReceiverHandler.java:50)
        at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociat
ionHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135)
        at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48
)
        at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104)
        at io.undertow.server.Connectors.executeRootHandler(Connectors.java:202)
        at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:805)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)

08:21:59,100 ERROR [org.jboss.as.ejb3.invocation] (default task-19) WFLYEJB0034: EJB Invocation failed on component LanguageDao
for method public java.util.List repository.LanguageDao.findLanguages(): javax.ejb.EJBException: java.lang.IllegalArgumentExcept
ion: org.hibernate.hql.internal.ast.QuerySyntaxException: unexpected token: Language near line 1, column 14 [select lfrom Langua
ge l]
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.handleExceptionInOurTx(CMTTxInterceptor.java:187)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:277)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.required(CMTTxInterceptor.java:327)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(CMTTxInterceptor.java:239)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(CurrentInvocationConte
xtInterceptor.java:41)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(WaitTimeInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(SecurityContextInterceptor.java:100)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(StartupAwaitInterceptor.java:22)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.ja
va:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:67)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java
:54)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:636)
        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)
        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:198)
        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)
        at repository.LanguageDao$$$view3.findLanguages(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(Reflections.java:433)
        at org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler.invoke(EnterpriseBeanProxyMethodHandler.java:128)
        at org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance.invoke(EnterpriseTargetBeanInstance.java:56)
        at org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(InjectionPointPropagatingEnter
priseTargetBeanInstance.java:67)
        at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:100)
        at repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.findLanguages(Unknown Source)
        at repository.LanguageDaoTest.listLanguages(LanguageDaoTest.java:47)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
        at org.jboss.arquillian.junit.Arquillian$8$1.invoke(Arquillian.java:379)
        at org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(LocalTestExecuter.java:60)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:114)
        at org.jboss.arquillian.core.impl.EventImpl.fire(EventImpl.java:67)
        at org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(ContainerTestExecuter.java:38)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:92)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(EventTestRunnerAdaptor.java:136)
        at org.jboss.arquillian.junit.Arquillian$8.evaluate(Arquillian.java:372)
        at org.jboss.arquillian.junit.Arquillian$4.evaluate(Arquillian.java:246)
        at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:431)
        at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:55)
        at org.jboss.arquillian.junit.Arquillian$5.evaluate(Arquillian.java:260)
        at org.jboss.arquillian.junit.Arquillian$7$1.invoke(Arquillian.java:324)
        at org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(BeforeLifecycleEventExecuter.java:
35)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:85)
        at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:92)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:96)
        at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:92)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:143)
        at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:114)
        at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(EventTestRunnerAdaptor.java:159)
        at org.jboss.arquillian.junit.Arquillian$7.evaluate(Arquillian.java:317)
        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.jboss.arquillian.junit.Arquillian$2.evaluate(Arquillian.java:205)
        at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:431)
        at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:55)
        at org.jboss.arquillian.junit.Arquillian$3.evaluate(Arquillian.java:219)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.jboss.arquillian.junit.Arquillian.run(Arquillian.java:167)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.jboss.arquillian.junit.container.JUnitTestRunner.execute(JUnitTestRunner.java:66)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(ServletTestRunner.java:170)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(ServletTestRunner.java:135)
        at org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(ServletTestRunner.java:98)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
        at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85)
        at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
        at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
        at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHan
dler.java:78)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler
.java:131)
        at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler
.java:57)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
        at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityCon
straintHandler.java:64)
        at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)
        at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandl
er.java:77)
        at io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(NotificationReceiverHandler.java:50)
        at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociat
ionHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135)
        at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48
)
        at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(LegacyThreadSetupActionWrapper.java:44)
        at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104)
        at io.undertow.server.Connectors.executeRootHandler(Connectors.java:202)
        at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:805)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: unexpected token: Language n
ear line 1, column 14 [select lfrom Language l]
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1679)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1602)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1608)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:294)
        at org.jboss.as.jpa.container.AbstractEntityManager.createQuery(AbstractEntityManager.java:445)
        at repository.LanguageDao.findLanguages(LanguageDao.java:67)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(ManagedReferenceMethodInterceptor.java:
52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(Jsr299BindingsInterceptor.java:82)
        at org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(Jsr299BindingsInterceptor.java:93)
        at org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(UserInterceptorFactory.java:63)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(ExecutionTimeInterceptor.jav
a:43)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(SBInvocationInterceptor.java:47)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InterceptorContext$Invocation.proceed(InterceptorContext.java:437)
        at org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor.aroundInvoke(AbstractEJBRequestScopeActivationInterce
ptor.java:64)
        at org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(EjbRequestScopeActivationInterceptor.jav
a:83)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(ConcurrentContextInterceptor.java:45)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.InitialInterceptor.processInvocation(InitialInterceptor.java:21)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)
        at org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(ComponentDispatcherIntercepto
r.java:52)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(PooledInstanceInterceptor.java:51)
        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(CMTTxInterceptor.java:275)
        ... 195 more
Caused by: org.hibernate.hql.internal.ast.QuerySyntaxException: unexpected token: Language near line 1, column 14 [select lfrom
Language l]
        at org.hibernate.hql.internal.ast.QuerySyntaxException.convert(QuerySyntaxException.java:74)
        at org.hibernate.hql.internal.ast.ErrorCounter.throwQueryException(ErrorCounter.java:91)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.parse(QueryTranslatorImpl.java:288)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:187)
        at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:142)
        at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:115)
        at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:76)
        at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:150)
        at org.hibernate.internal.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:302)
        at org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:240)
        at org.hibernate.internal.SessionImpl.createQuery(SessionImpl.java:1894)
        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:291)
        ... 226 more

08:21:59,256 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 90) WFLYUT0022: Unregistered web context: /tes
t
08:21:59,256 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 92) WFLYJPA0011: Stopping Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:21:59,256 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 92) HHH000227: Running hbm2ddl schema
 export
08:21:59,256 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 94) WFLYJPA0011: Stopping Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:21:59,272 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 94) HHH000227: Running hbm2ddl schema
 export
08:21:59,272 INFO  [stdout] (ServerService Thread Pool -- 92) Hibernate:
08:21:59,272 INFO  [stdout] (ServerService Thread Pool -- 92)     drop table Language if exists
08:21:59,272 INFO  [stdout] (ServerService Thread Pool -- 94) Hibernate:
08:21:59,272 INFO  [stdout] (ServerService Thread Pool -- 94)     drop table if exists Language cascade
08:21:59,272 INFO  [stdout] (ServerService Thread Pool -- 92) Hibernate:
08:21:59,272 INFO  [stdout] (ServerService Thread Pool -- 92)     drop sequence if exists hibernate_sequence
08:21:59,288 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 92) HHH000230: Schema export complete

08:21:59,288 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 92) WFLYJPA0011: Stopping Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:21:59,288 INFO  [stdout] (ServerService Thread Pool -- 94) Hibernate:
08:21:59,288 INFO  [stdout] (ServerService Thread Pool -- 94)     drop sequence hibernate_sequence
08:21:59,288 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 94) HHH000230: Schema export complete

08:21:59,288 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 94) WFLYJPA0011: Stopping Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:21:59,319 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-1) WFLYSRV0028: Stopped deployment test.war (runtime-n
ame: test.war) in 68ms
08:21:59,350 WARN  [org.jboss.as.controller] (management-handler-thread - 17) WFLYCTL0357: Notification of type deployment-undep
loyed is not described for the resource at the address []
08:21:59,350 INFO  [org.jboss.as.repository] (management-handler-thread - 17) WFLYDR0002: Content removed from location C:\Users
\ervelden\bin\wildfly-10.1.0.Final\standalone\data\content\4c\32b08b68a92cbc9dfbcb1e2e9991e9f2f3ac1f\content
08:21:59,350 INFO  [org.jboss.as.server] (management-handler-thread - 17) WFLYSRV0009: Undeployed "test.war" (runtime-name: "tes
t.war")

/ 1313	. 

/ In LanguageDao hebben we de fout verbeterd	,
	public List<Language>findLanguages(){
		Query q=em.createQuery(
				"select l "	// let op space achteraan	,
				+ "from Language l"
				);
		List<Language>ls=q.getResultList();
		return ls;
	}
	
[LanguageDaoTest.java]$ build test
/ OK

/ in wildfly,

08:40:45,556 INFO  [org.jboss.as.repository] (management-handler-thread - 21) WFLYDR0001: Content added at location C:\Users\erv
elden\bin\wildfly-10.1.0.Final\standalone\data\content\4d\e7bf3dd743ffe11f14aaa07788a55a84c1762a\content
08:40:45,572 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-5) WFLYSRV0027: Starting deployment of "test.war" (run
time-name: "test.war")
08:40:45,697 INFO  [org.jboss.weld.deployer] (MSC service thread 1-2) WFLYWELD0003: Processing weld deployment test.war
08:40:45,822 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 96) WFLYUT0021: Registered web context: /test
08:40:45,853 INFO  [org.jboss.as.server] (management-handler-thread - 21) WFLYSRV0010: Deployed "test.war" (runtime-name : "test
.war")
08:40:46,075 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 96) WFLYUT0022: Unregistered web context: /tes
t
08:40:46,106 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-8) WFLYSRV0028: Stopped deployment test.war (runtime-n
ame: test.war) in 32ms
08:40:46,122 WARN  [org.jboss.as.controller] (management-handler-thread - 22) WFLYCTL0357: Notification of type deployment-undep
loyed is not described for the resource at the address []
08:40:46,122 INFO  [org.jboss.as.repository] (management-handler-thread - 22) WFLYDR0002: Content removed from location C:\Users
\ervelden\bin\wildfly-10.1.0.Final\standalone\data\content\4d\e7bf3dd743ffe11f14aaa07788a55a84c1762a\content
08:40:46,122 INFO  [org.jboss.as.server] (management-handler-thread - 22) WFLYSRV0009: Undeployed "test.war" (runtime-name: "tes
t.war")
08:40:46,637 INFO  [org.jboss.as.repository] (management-handler-thread - 23) WFLYDR0001: Content added at location C:\Users\erv
elden\bin\wildfly-10.1.0.Final\standalone\data\content\22\1457d87c87b78bf8314f373514e70e8fdc1ba4\content
08:40:46,637 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-5) WFLYSRV0027: Starting deployment of "test.war" (run
time-name: "test.war")
08:40:46,746 INFO  [org.jboss.as.jpa] (MSC service thread 1-3) WFLYJPA0002: Read persistence.xml for arquillian-forge4-persisten
ce-unit
08:40:46,746 INFO  [org.jboss.as.jpa] (MSC service thread 1-3) WFLYJPA0002: Read persistence.xml for arquillian-forge4-persisten
ce-unit-1
08:40:46,762 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 97) WFLYJPA0010: Starting Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:40:46,762 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 99) WFLYJPA0010: Starting Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:40:46,762 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 97) HHH000204: Processing Persisten
ceUnitInfo [
        name: arquillian-forge4-persistence-unit-1
        ...]
08:40:46,762 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 99) HHH000204: Processing Persisten
ceUnitInfo [
        name: arquillian-forge4-persistence-unit
        ...]
08:40:46,762 INFO  [org.jboss.weld.deployer] (MSC service thread 1-3) WFLYWELD0003: Processing weld deployment test.war
08:40:46,762 WARN  [org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl] (ServerService Thread Pool -- 99) HHH000059
: Defining hibernate.transaction.flush_before_completion=true ignored in HEM
08:40:46,762 WARN  [org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl] (ServerService Thread Pool -- 97) HHH000059
: Defining hibernate.transaction.flush_before_completion=true ignored in HEM
08:40:46,777 INFO  [org.jboss.as.ejb3.deployment] (MSC service thread 1-3) WFLYEJB0473: JNDI bindings for session bean named 'La
nguageDao' in deployment unit 'deployment "test.war"' are as follows:

        java:global/test/LanguageDao!repository.LanguageDao
        java:app/test/LanguageDao!repository.LanguageDao
        java:module/LanguageDao!repository.LanguageDao
        java:global/test/LanguageDao
        java:app/test/LanguageDao
        java:module/LanguageDao

08:40:46,808 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 99) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:40:46,808 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 97) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:40:46,808 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 99) HHH000400: Using dialect: org.hibernate.dia
lect.PostgreSQLDialect
08:40:46,808 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 97) HHH000400: Using dialect: org.hibernate.dia
lect.H2Dialect
08:40:46,808 WARN  [org.hibernate.dialect.H2Dialect] (ServerService Thread Pool -- 97) HHH000431: Unable to determine H2 databas
e version, certain features may not work
08:40:46,824 INFO  [org.hibernate.engine.jdbc.env.internal.LobCreatorBuilderImpl] (ServerService Thread Pool -- 99) HHH000424: D
isabling contextual LOB creation as createClob() method threw error : java.lang.reflect.InvocationTargetException
08:40:46,824 INFO  [org.hibernate.type.BasicTypeRegistry] (ServerService Thread Pool -- 99) HHH000270: Type registration [java.u
til.UUID] overrides previous : org.hibernate.type.UUIDBinaryType@55822d89
08:40:46,840 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 99) Envers integration e
nabled? : true
08:40:46,840 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 97) Envers integration e
nabled? : true
08:40:46,855 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 99) HHH000227: Running hbm2ddl schema
 export
08:40:46,855 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 97) HHH000227: Running hbm2ddl schema
 export
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 99) Hibernate:
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 99)     drop table if exists Language cascade
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 97) Hibernate:
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 97)     drop table Language if exists
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 99) Hibernate:
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 99)     drop sequence hibernate_sequence
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 97) Hibernate:
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 97)     drop sequence if exists hibernate_sequence
08:40:46,871 ERROR [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 99) HHH000389: Unsuccessful: drop seq
uence hibernate_sequence
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 97) Hibernate:
08:40:46,871 ERROR [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 99) ERROR: sequence "hibernate_sequen
ce" does not exist
08:40:46,871 INFO  [stdout] (ServerService Thread Pool -- 97)     create sequence hibernate_sequence start with 1 increment by 1

08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 99) Hibernate:
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 99)     create sequence hibernate_sequence start 1 increment 1
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97) Hibernate:
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97)     create table Language (
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97)         id bigint not null,
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97)         name varchar(255),
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97)         version integer,
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97)         primary key (id)
08:40:46,886 INFO  [stdout] (ServerService Thread Pool -- 97)     )
08:40:46,886 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 97) HHH000230: Schema export complete

08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99) Hibernate:
08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99)     create table Language (
08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99)         id int8 not null,
08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99)         name varchar(255),
08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99)         version int4,
08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99)         primary key (id)
08:40:46,902 INFO  [stdout] (ServerService Thread Pool -- 99)     )
08:40:46,918 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 99) HHH000230: Schema export complete

08:40:47,000 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 96) WFLYUT0021: Registered web context: /test
08:40:47,015 INFO  [org.jboss.as.server] (management-handler-thread - 23) WFLYSRV0010: Deployed "test.war" (runtime-name : "test
.war")
08:40:47,124 INFO  [stdout] (default task-28) Hibernate:
08:40:47,124 INFO  [stdout] (default task-28)     select
08:40:47,124 INFO  [stdout] (default task-28)         nextval ('hibernate_sequence')
08:40:47,124 INFO  [stdout] (default task-28) Hibernate:
08:40:47,124 INFO  [stdout] (default task-28)     select
08:40:47,124 INFO  [stdout] (default task-28)         nextval ('hibernate_sequence')
08:40:47,140 INFO  [stdout] (default task-28) Hibernate:
08:40:47,140 INFO  [stdout] (default task-28)     select
08:40:47,140 INFO  [stdout] (default task-28)         nextval ('hibernate_sequence')
08:40:47,140 INFO  [stdout] (default task-28) Hibernate:
08:40:47,140 INFO  [stdout] (default task-28)     insert
08:40:47,140 INFO  [stdout] (default task-28)     into
08:40:47,140 INFO  [stdout] (default task-28)         Language
08:40:47,140 INFO  [stdout] (default task-28)         (name, version, id)
08:40:47,140 INFO  [stdout] (default task-28)     values
08:40:47,156 INFO  [stdout] (default task-28)         (?, ?, ?)
08:40:47,156 INFO  [stdout] (default task-28) Hibernate:
08:40:47,156 INFO  [stdout] (default task-28)     insert
08:40:47,156 INFO  [stdout] (default task-28)     into
08:40:47,156 INFO  [stdout] (default task-28)         Language
08:40:47,156 INFO  [stdout] (default task-28)         (name, version, id)
08:40:47,156 INFO  [stdout] (default task-28)     values
08:40:47,156 INFO  [stdout] (default task-28)         (?, ?, ?)
08:40:47,156 INFO  [stdout] (default task-28) Hibernate:
08:40:47,156 INFO  [stdout] (default task-28)     insert
08:40:47,156 INFO  [stdout] (default task-28)     into
08:40:47,156 INFO  [stdout] (default task-28)         Language
08:40:47,156 INFO  [stdout] (default task-28)         (name, version, id)
08:40:47,156 INFO  [stdout] (default task-28)     values
08:40:47,156 INFO  [stdout] (default task-28)         (?, ?, ?)
08:40:47,171 INFO  [org.hibernate.hql.internal.QueryTranslatorFactoryInitiator] (default task-28) HHH000397: Using ASTQueryTrans
latorFactory
08:40:47,218 INFO  [stdout] (default task-28) Hibernate:
08:40:47,218 INFO  [stdout] (default task-28)     select
08:40:47,234 INFO  [stdout] (default task-28)         language0_.id as id1_0_,
08:40:47,234 INFO  [stdout] (default task-28)         language0_.name as name2_0_,
08:40:47,234 INFO  [stdout] (default task-28)         language0_.version as version3_0_
08:40:47,234 INFO  [stdout] (default task-28)     from
08:40:47,234 INFO  [stdout] (default task-28)         Language language0_
08:40:47,249 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 96) WFLYUT0022: Unregistered web context: /tes
t
08:40:47,249 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 97) WFLYJPA0011: Stopping Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:40:47,249 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 96) WFLYJPA0011: Stopping Persistence Unit (phase 2 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:40:47,249 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 97) HHH000227: Running hbm2ddl schema
 export
08:40:47,249 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 96) HHH000227: Running hbm2ddl schema
 export
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 97) Hibernate:
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 97)     drop table if exists Language cascade
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 96) Hibernate:
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 96)     drop table Language if exists
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 96) Hibernate:
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 96)     drop sequence if exists hibernate_sequence
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 97) Hibernate:
08:40:47,265 INFO  [stdout] (ServerService Thread Pool -- 97)     drop sequence hibernate_sequence
08:40:47,265 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 96) HHH000230: Schema export complete

08:40:47,265 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 96) WFLYJPA0011: Stopping Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit-1'
08:40:47,265 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 97) HHH000230: Schema export complete

08:40:47,265 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 97) WFLYJPA0011: Stopping Persistence Unit (phase 1 of 2) Se
rvice 'test.war#arquillian-forge4-persistence-unit'
08:40:47,296 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-8) WFLYSRV0028: Stopped deployment test.war (runtime-n
ame: test.war) in 46ms
08:40:47,312 WARN  [org.jboss.as.controller] (management-handler-thread - 21) WFLYCTL0357: Notification of type deployment-undep
loyed is not described for the resource at the address []
08:40:47,312 INFO  [org.jboss.as.repository] (management-handler-thread - 21) WFLYDR0002: Content removed from location C:\Users
\ervelden\bin\wildfly-10.1.0.Final\standalone\data\content\22\1457d87c87b78bf8314f373514e70e8fdc1ba4\content
08:40:47,312 INFO  [org.jboss.as.server] (management-handler-thread - 21) WFLYSRV0009: Undeployed "test.war" (runtime-name: "tes
t.war")

/ 13	. 

/ JBOSS LOGGING

/ google	,
hibernate logging show parameter values


/ lees	,
https://developer.jboss.org/thread/173915
->
https://docs.jboss.org/author/display/AS71/JPA+Reference+Guide#JPAReferenceGuide-UsingtheHibernate4JPApersistenceprovider
https://docs.jboss.org/author/display/WFLY/JPA+Reference+Guide#JPAReferenceGuide-Troubleshooting

/ 2019	, 
/ lees,
https://docs.jboss.org/author/display/WFLY/JPA+Reference+Guide
/ bij Troubleshooting,
/ WH bestond com.arjuna met level WARN al, en maken we org.jboss.as.jpa met level TRACE,
/ ook moeten we WH jboss.jdbc.spy op level TRACE en add spy="true" op de datasource,

/ 2019
Redhat login
ericjvandervelden@gmail.com
vlWalnoot27



/ we doen in jboss-cli.bat,

/ pas console handler aan:

[standalone@localhost:9990 /] /subsystem=logging/console-handler=CONSOLE:update-properties(level=TRACE)
{"outcome" => "success"}

/ maak een nieuwe logger:

/ google: jboss-cli add logger
/ lees,
http://www.mastertheboss.com/jboss-server/jboss-script/cli-recipe-create-a-logger-with-as7


[standalone@localhost:9990 /] /subsystem=logging/logger=org.jboss.as.jpa:add
{"outcome" => "success"}
[standalone@localhost:9990 /] /subsystem=logging/logger=org.jboss.as.jpa:write-attribute(
name=  value=
[standalone@localhost:9990 /] /subsystem=logging/logger=org.jboss.as.jpa:write-attribute(name=level,value=TRACE)
{"outcome" => "success"}
[standalone@localhost:9990 /] reload

[standalone@localhost:9990 /] /subsystem=logging:read-resource(recursive=true)
{
    "outcome" => "success",
    "result" => {
        "add-logging-api-dependencies" => true,
        "use-deployment-logging-config" => true,
        "async-handler" => undefined,
        "console-handler" => {"CONSOLE" => {
            "autoflush" => true,
            "enabled" => true,
            "encoding" => undefined,
            "filter" => undefined,
            "filter-spec" => undefined,
            "formatter" => "%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n",
            "level" => "TRACE",											<-
            "name" => "CONSOLE",
            "named-formatter" => "COLOR-PATTERN",
            "target" => "System.out"
        }},
        "custom-formatter" => undefined,
        "custom-handler" => undefined,
        "file-handler" => undefined,
        "log-file" => undefined,
        "logger" => {
            ...
            "org.jboss.as.jpa" => {
                "category" => "org.jboss.as.jpa",
                "filter" => undefined,
                "filter-spec" => undefined,
                "handlers" => undefined,
                "level" => "TRACE",
                "use-parent-handlers" => true
            }
        },
        "logging-profile" => undefined,
        "pattern-formatter" => {
            "PATTERN" => {
                "color-map" => undefined,
                "pattern" => "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n"
            },
            "COLOR-PATTERN" => {
                "color-map" => undefined,
                "pattern" => "%K{level}%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n"
            }
        },
        "periodic-rotating-file-handler" => {"FILE" => {
            "append" => true,
            "autoflush" => true,
            "enabled" => true,
            "encoding" => undefined,
            "file" => {
                "relative-to" => "jboss.server.log.dir",
                "path" => "server.log"
            },
            "filter" => undefined,
            "filter-spec" => undefined,
            "formatter" => "%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n",
            "level" => "ALL",
            "name" => "FILE",
            "named-formatter" => "PATTERN",
            "suffix" => ".yyyy-MM-dd"
        }},
        "periodic-size-rotating-file-handler" => undefined,
        "root-logger" => {"ROOT" => {
            "filter" => undefined,
            "filter-spec" => undefined,
            "handlers" => [
                "CONSOLE",
                "FILE"
            ],
            "level" => "INFO"
        }},
        "size-rotating-file-handler" => undefined,
        "syslog-handler" => undefined
    }
}
[standalone@localhost:9990 /] /subsystem=logging/root-logger=ROOT:change-root-log-level(level=TRACE)
{"outcome" => "success"}
[disconnected /] connect
[standalone@localhost:9990 /] reload
/ OK,
/ Dit gaat dus anders als bij console-handler=CONSOLE:update-properties(level=TRACE)
/ we hebben weer teruggezet op INFO: teveel logging van scanner ...
/ TODO

/ jdbc logging,

[standalone@localhost:9990 /] /subsystem=logging/logger=jboss.jdbc.spy:add
{"outcome" => "success"}
[standalone@localhost:9990 /] /subsystem=logging/logger=jboss.jdbc.spy:
add                         map-clear                   read-children-names         remove-handler
add-handler                 map-get                     read-children-resources     unassign-handler
assign-handler              map-put                     read-children-types         undefine-attribute
change-log-level            map-remove                  read-operation-description  whoami
list-add                    query                       read-operation-names        write-attribute
list-clear                  read-attribute              read-resource
list-get                    read-attribute-group        read-resource-description
list-remove                 read-attribute-group-names  remove
[standalone@localhost:9990 /] /subsystem=logging/logger=jboss.jdbc.spy:write-attribute(
name=  value=
[standalone@localhost:9990 /] /subsystem=logging/logger=jboss.jdbc.spy:write-attribute(name=
filter  filter-spec  handlers  level  use-parent-handlers
[standalone@localhost:9990 /] /subsystem=logging/logger=jboss.jdbc.spy:write-attribute(name=level,value=
ALL  CONFIG  DEBUG  ERROR  FATAL  FINE  FINER  FINEST  INFO  OFF  SEVERE  TRACE  WARN  WARNING
[standalone@localhost:9990 /] /subsystem=logging/logger=jboss.jdbc.spy:write-attribute(name=level,value=TRACE)
{"outcome" => "success"}

[standalone@localhost:9990 /] /subsystem=datasources/
data-source  jdbc-driver  xa-data-source
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=
PostgreSQLDS  RemoteExampleDS
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=PostgreSQLDS:
add                                  list-remove                          read-children-types
disable                              map-clear                            read-operation-description
dump-queued-threads-in-pool          map-get                              read-operation-names
enable                               map-put                              read-resource
flush-all-connection-in-pool         map-remove                           read-resource-description
flush-gracefully-connection-in-pool  query                                remove
flush-idle-connection-in-pool        read-attribute                       test-connection-in-pool
flush-invalid-connection-in-pool     read-attribute-group                 undefine-attribute
list-add                             read-attribute-group-names           whoami
list-clear                           read-children-names                  write-attribute
list-get                             read-children-resources
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=PostgreSQLDS:write-attribute(
name=  value=
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=RemoteExampleDS:write-attribute(name=
allocation-retry                     jndi-name                            set-tx-query-timeout
allocation-retry-wait-millis         max-pool-size                        share-prepared-statements
allow-multiple-users                 mcp                                  spy
background-validation                min-pool-size                        stale-connection-checker-class-name
background-validation-millis         new-connection-sql                   stale-connection-checker-properties
blocking-timeout-wait-millis         no-recovery                          statistics-enabled
capacity-decrementer-class           no-tx-separate-pool                  track-statements
capacity-decrementer-properties      pad-xid                              tracking
capacity-incrementer-class           password                             transaction-isolation
capacity-incrementer-properties      pool-fair                            url-delimiter
check-valid-connection-sql           pool-prefill                         url-property
connectable                          pool-use-strict-min                  url-selector-strategy-class-name
connection-listener-class            prepared-statements-cache-size       use-ccm
connection-listener-property         query-timeout                        use-fast-fail
driver-name                          reauth-plugin-class-name             use-java-context
enabled                              reauth-plugin-properties             use-try-lock
enlistment-trace                     recovery-password                    user-name
exception-sorter-class-name          recovery-plugin-class-name           valid-connection-checker-class-name
exception-sorter-properties          recovery-plugin-properties           valid-connection-checker-properties
flush-strategy                       recovery-security-domain             validate-on-match
idle-timeout-minutes                 recovery-username                    wrap-xa-resource
initial-pool-size                    same-rm-override                     xa-datasource-class
interleaving                         security-domain                      xa-resource-timeout
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=PostgreSQLDS:write-attribute(name=s
same-rm-override                     share-prepared-statements            stale-connection-checker-properties
security-domain                      spy                                  statistics-enabled
set-tx-query-timeout                 stale-connection-checker-class-name
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=PostgreSQLDS:write-attribute(name=spy,value=
false  true
[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=PostgreSQLDS:write-attribute(name=spy,value=true)
{
    "outcome" => "success",
    "response-headers" => {
        "operation-requires-reload" => true,
        "process-state" => "reload-required"
    }
}
[standalone@localhost:9990 /] re
read-attribute  read-operation  reload
[standalone@localhost:9990 /] reload
[standalone@localhost:9990 /]
/ OK
/ we zien nu JDBC , de gen postgres acties 	, en de values,

[standalone@localhost:9990 /] /subsystem=logging:read-resource(recursive=true)
{
    "outcome" => "success",
    "result" => {
        "add-logging-api-dependencies" => true,
        "use-deployment-logging-config" => true,
        "async-handler" => undefined,
        "console-handler" => {"CONSOLE" => {
            "autoflush" => true,
            "enabled" => true,
            "encoding" => undefined,
            "filter" => undefined,
            "filter-spec" => undefined,
            "formatter" => "%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n",
            "level" => "TRACE",
            "name" => "CONSOLE",                                          <-
            "named-formatter" => "COLOR-PATTERN",
            "target" => "System.out"
        }},
        "custom-formatter" => undefined,
        "custom-handler" => undefined,
        "file-handler" => undefined,
        "log-file" => undefined,
        "logger" => {
			...
            "org.jboss.as.jpa" => {
                "category" => "org.jboss.as.jpa",
                "filter" => undefined,
                "filter-spec" => undefined,
                "handlers" => undefined,
                "level" => "DEBUG",
                "use-parent-handlers" => true
            },
            "jboss.jdbc.spy" => {
                "category" => "jboss.jdbc.spy",
                "filter" => undefined,
                "filter-spec" => undefined,
                "handlers" => undefined,
                "level" => "TRACE",
                "use-parent-handlers" => true
            }
        },
		
[standalone@localhost:9990 /] /subsystem=datasources:read-resource(recursive=true)
{
    "outcome" => "success",
    "result" => {
            "PostgreSQLDS" => {
                "spy" => true,	

/ we doen hetzelfde voor h2:

[standalone@localhost:9990 /] /subsystem=datasources/xa-data-source=RemoteExampleDS:write-attribute(name=spy,value=true)
{
    "outcome" => "success",
    "response-headers" => {
        "operation-requires-reload" => true,
        "process-state" => "reload-required"
    }
}
[standalone@localhost:9990 /] reload
[standalone@localhost:9990 /]

/ we lazen ook 	,
/ google: hibernate logging show parameter values
https://www.mkyong.com/hibernate/how-to-display-hibernate-sql-parameter-values-log4j/
# Log JDBC bind parameter runtime arguments
log4j.logger.org.hibernate.type=trace
-> 
http://www.mkyong.com/hibernate/how-to-configure-log4j-in-hibernate-project/


/ in forge
% build test

/we zien in wildfly,

21:21:07,129 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 69) HHH000227: Running hbm2ddl schema export
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] getAutoCommit()
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] createStatement()
21:21:07,139 INFO  [stdout] (ServerService Thread Pool -- 69) Hibernate:
21:21:07,139 INFO  [stdout] (ServerService Thread Pool -- 69)     drop table if exists Language cascade
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    drop table if exists Language cascade)
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] getWarnings()
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
21:21:07,139 INFO  [stdout] (ServerService Thread Pool -- 69) Hibernate:
21:21:07,139 INFO  [stdout] (ServerService Thread Pool -- 69)     drop sequence hibernate_sequence
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    drop sequence hibernate_sequence)
21:21:07,139 ERROR [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 69) HHH000389: Unsuccessful: drop sequence hibernate_sequence
21:21:07,139 ERROR [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 69) ERROR: sequence "hibernate_sequence" does not exist
21:21:07,139 INFO  [stdout] (ServerService Thread Pool -- 69) Hibernate:
21:21:07,139 INFO  [stdout] (ServerService Thread Pool -- 69)     create sequence hibernate_sequence start 1 increment 1
21:21:07,139 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    create sequence hibernate_sequence start 1 increment 1)
21:21:07,149 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] getWarnings()
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69) Hibernate:
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)     create table Language (
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         id int8 not null,
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         name varchar(255),
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         version int4,
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         primary key (id)
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)     )
21:21:07,149 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    create table Language (
        id int8 not null,
        name varchar(255),
        version int4,
        primary key (id)
    ))
21:21:07,169 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] getWarnings()
21:21:07,169 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] close()
21:21:07,169 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
21:21:07,169 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
21:21:07,169 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
21:21:07,169 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Connection] close()
21:21:07,169 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 69) HHH000230: Schema export complete
21:21:07,229 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 69) WFLYUT0021: Registered web context: /test
21:21:07,249 INFO  [org.jboss.as.server] (management-handler-thread - 7) WFLYSRV0010: Deployed "test.war" (runtime-name : "test.war")
21:21:07,339 DEBUG [org.jboss.as.jpa] (default task-5) created new TransactionScopedEntityManager for unit name=test.war#arquillian-forge4-persistence-unit
21:21:07,339 DEBUG [org.jboss.as.jpa] (default task-5) default task-5:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: created entity manager session TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-31b1d953:5aa2b1f6:498 status: ActionStatus.RUNNING >
21:21:07,339 INFO  [stdout] (default task-5) Hibernate:
21:21:07,339 INFO  [stdout] (default task-5)     select
21:21:07,339 INFO  [stdout] (default task-5)         nextval ('hibernate_sequence')
21:21:07,339 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
21:21:07,339 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select nextval ('hibernate_sequence'))
21:21:07,339 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
21:21:07,339 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
21:21:07,339 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(1)
21:21:07,339 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] close()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] isClosed()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] close()

21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69) Hibernate:
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)     create table Language (
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         id int8 not null,
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         name varchar(255),
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         version int4,
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)         primary key (id)
21:21:07,149 INFO  [stdout] (ServerService Thread Pool -- 69)     )
21:21:07,149 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 69) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    create table Language (
        id int8 not null,
        name varchar(255),
        version int4,
        primary key (id)
    ))
/ dit is door de entity,
$ vi Language.java

@Entity
public class Language implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", updatable = false, nullable = false)
	private Long id;
	@Version
	@Column(name = "version")
	private int version;

	@Column
	private String name;




21:21:07,349 INFO  [stdout] (default task-5) Hibernate:
21:21:07,349 INFO  [stdout] (default task-5)     select
21:21:07,349 INFO  [stdout] (default task-5)         nextval ('hibernate_sequence')
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select nextval ('hibernate_sequence'))
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
21:21:07,349 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(1)
/ 3 keer	,
/ TODO in postgres: select nextval('hibernate_sequence')

07,369 INFO  [stdout] (default task-5) Hibernate:
07,369 INFO  [stdout] (default task-5)     insert
07,369 INFO  [stdout] (default task-5)     into
07,369 INFO  [stdout] (default task-5)         Language
07,369 INFO  [stdout] (default task-5)         (name, version, id)
07,369 INFO  [stdout] (default task-5)     values
07,369 INFO  [stdout] (default task-5)         (?, ?, ?)
07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(insert into Language (name, version, id) values (?, ?, ?))
/ 3 keer
21:21:07,359 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, Java)
21:21:07,359 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)
21:21:07,359 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 1)
21:21:07,359 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeUpdate()

07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, Go)
07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)
07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 2)	

21:21:07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, C++)
21:21:07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)
21:21:07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 3)
21:21:07,369 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeUpdate()

/ er zijn 3 van deze	, met Java, Go	, en C++	, 
/ Dit is em.persist, en we zien ook dat in HQL ? leidt tot een prepareStatement in PostgreSQL	,
/ door,
		Language l=new Language();
		l.setName("Java");
		em.persist(l);
		l=new Language();
		l.setName("Go");
		em.persist(l);
		l=new Language();
		l.setName("C++");
		em.persist(l);
	}


21:21:07,379 INFO  [stdout] (default task-5) Hibernate:
21:21:07,379 INFO  [stdout] (default task-5)     select
21:21:07,379 INFO  [stdout] (default task-5)         language0_.id as id1_0_,
21:21:07,379 INFO  [stdout] (default task-5)         language0_.name as name2_0_,
21:21:07,379 INFO  [stdout] (default task-5)         language0_.version as version3_0_
21:21:07,379 INFO  [stdout] (default task-5)     from
21:21:07,379 INFO  [stdout] (default task-5)         Language language0_
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select language0_.id as id1_0_, language0_.name as name2_0_, language0_.version as version3_0_ from Language language0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
21:21:07,379 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] close()
/ Dit is van,
		Query q=em.createQuery(
				"select l "	// let op space achteraan	,
				+ "from Language l"
				);
		List<Language>ls=q.getResultList();


/ lees over create-drop, create, update, validate	,
https://stackoverflow.com/questions/438146/hibernate-hbm2ddl-auto-possible-values-and-what-they-do

/ 13	 .

/ in postgres maken we de ddl zelf	, en h2 zeggen we 'create' ipv 'create-drop'	,
/ 'create' betekent dat voordat hij begint eerst drop doet	, 'create-drop' drops aan het einde	, 
/ dus je kunt met 'create' steeds je tests opnieuw doen.

/ 'create' is altijd beter, want dan kun je kijken na afloop naar de tables	,

/ native queries staat los van of we zelf de ddl doen, als je hibernate de ddl laat doen, moet je wel weten hoe de table eruit is komen te zien,

/ de ddl wordt in alle pu's gedaan	, dus in postgres en h2, 	
/ de inserts worden alleen in postgres gedaan, want de test calls alleen mths van die dao die de postgres pu heeft,	


/ we doen zelf,
$ psql -Ueric test
create sequence hibernate_sequence start 1 increment 1
create table language (			
	id int8 not null,			-- bigint
	name varchar(255),
	version int4,				-- integer
	primary key (id)
)


/ table names zijn niet case sensitive in postgres, of h2,


$ vi persistence.xml

<persistence-unit name="arquillian-forge4-persistence-unit" transaction-type="JTA">
    <properties>
    <!-- 
    <property name="hibernate.hbm2ddl.auto" value="create-drop"/>
    -->
  </persistence-unit>
  <persistence-unit name="arquillian-forge4-persistence-unit-1" transaction-type="JTA">
    <properties>
      <property name="hibernate.hbm2ddl.auto" value="create"/>


/ we zien dat het goed gaat,

test=> \d+ language
                               Table "public.language"
 Column  |          Type          | Modifiers | Storage  | Stats target | Description
---------+------------------------+-----------+----------+--------------+-------------
 id      | bigint                 | not null  | plain    |              |
 name    | character varying(255) |           | extended |              |
 version | integer                |           | plain    |              |
Indexes:
    "language_pkey" PRIMARY KEY, btree (id)
	
sql> show columns from language;
FIELD   | TYPE         | NULL | KEY | DEFAULT
ID      | BIGINT(19)   | NO   | PRI | NULL
NAME    | VARCHAR(255) | YES  |     | NULL
VERSION | INTEGER(10)  | YES  |     | NULL
(3 rows, 40 ms)

/ we zien in de logs, dat alleen voor RemoteExampleDS (h2) de ddls worden gedaan:

10:25:20,279 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 115) HHH000204: Processing PersistenceUnitInfo [
        name: arquillian-forge4-persistence-unit
        ...]
10:25:20,279 INFO  [org.hibernate.jpa.internal.util.LogHelper] (ServerService Thread Pool -- 114) HHH000204: Processing PersistenceUnitInfo [
        name: arquillian-forge4-persistence-unit-1
        ...]

10:25:20,329 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 114) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Service 'test.war#arquillian-forge4-persistence-unit'
10:25:20,329 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 114) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
10:25:20,329 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 114) java:jboss/datasources/PostgreSQLDS [Connection] getMetaData()
10:25:20,329 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 114) HHH000400: Using dialect: org.hibernate.dialect.PostgreSQLDialect
//////////////////////////////////
/ Doet niets voor deze pu,

10:25:20,329 INFO  [org.jboss.as.jpa] (ServerService Thread Pool -- 115) WFLYJPA0010: Starting Persistence Unit (phase 2 of 2) Service 'test.war#arquillian-forge4-persistence-unit-1'
10:25:20,329 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [DataSource] getConnection()
10:25:20,329 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] getMetaData()
10:25:20,329 INFO  [org.hibernate.dialect.Dialect] (ServerService Thread Pool -- 115) HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
10:25:20,329 WARN  [org.hibernate.dialect.H2Dialect] (ServerService Thread Pool -- 115) HHH000431: Unable to determine H2 database version, certain features may not work
10:25:20,339 INFO  [org.hibernate.engine.jdbc.env.internal.LobCreatorBuilderImpl] (ServerService Thread Pool -- 114) HHH000424: Disabling contextual LOB creation as createClob() method threw error : java.lang.reflect.InvocationTargetException
10:25:20,339 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 114) java:jboss/datasources/PostgreSQLDS [Connection] close()
10:25:20,339 INFO  [org.hibernate.type.BasicTypeRegistry] (ServerService Thread Pool -- 114) HHH000270: Type registration [java.util.UUID] overrides previous : org.hibernate.type.UUIDBinaryType@225ccfe5
10:25:20,339 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] close()
10:25:20,339 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 114) Envers integration enabled? : true
10:25:20,339 INFO  [org.hibernate.envers.boot.internal.EnversServiceImpl] (ServerService Thread Pool -- 115) Envers integration enabled? : true
10:25:20,349 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 115) HHH000227: Running hbm2ddl schema export
10:25:20,349 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [DataSource] getConnection()
10:25:20,349 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] getAutoCommit()
10:25:20,349 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] createStatement()
10:25:20,349 INFO  [stdout] (ServerService Thread Pool -- 115) Hibernate:
10:25:20,349 INFO  [stdout] (ServerService Thread Pool -- 115)     drop table Language if exists
10:25:20,349 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    drop table Language if exists)
10:25:20,349 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] getWarnings()
10:25:20,349 INFO  [stdout] (ServerService Thread Pool -- 115) Hibernate:
10:25:20,349 INFO  [stdout] (ServerService Thread Pool -- 115)     drop sequence if exists hibernate_sequence
10:25:20,349 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    drop sequence if exists hibernate_sequence)
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] getWarnings()
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115) Hibernate:
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)     create sequence hibernate_sequence start with 1 increment by 1
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    create sequence hibernate_sequence start with 1 increment by 1)
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] getWarnings()
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115) Hibernate:
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)     create table Language (
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)         id bigint not null,
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)         name varchar(255),
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)         version integer,
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)         primary key (id)
10:25:20,359 INFO  [stdout] (ServerService Thread Pool -- 115)     )
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    create table Language (
        id bigint not null,
        name varchar(255),
        version integer,
        primary key (id)
    ))
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] getWarnings()
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Statement] close()
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] isClosed()
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] getWarnings()
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] clearWarnings()
10:25:20,359 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 115) java:jboss/datasources/RemoteExampleDS [Connection] close()
10:25:20,359 INFO  [org.hibernate.tool.hbm2ddl.SchemaExport] (ServerService Thread Pool -- 115) HHH000230: Schema export complete
/////////////////
/ voor h2 wel	,


10:25:20,439 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 115) WFLYUT0021: Registered web context: /test
10:25:20,456 INFO  [org.jboss.as.server] (management-handler-thread - 26) WFLYSRV0010: Deployed "test.war" (runtime-name : "test.war")

/////////////////////////////////////////
/ Nu alleen voor postgres pu de tests:

10:25:20,549 DEBUG [org.jboss.as.jpa] (default task-48) created new TransactionScopedEntityManager for unit name=test.war#arquillian-forge4-persistence-unit
10:25:20,549 DEBUG [org.jboss.as.jpa] (default task-48) default task-48:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: created entity manager session TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-31b1d953:5aa2b1f6:964 status: ActionStatus.RUNNING >
10:25:20,549 INFO  [stdout] (default task-48) Hibernate:
10:25:20,549 INFO  [stdout] (default task-48)     select
10:25:20,549 INFO  [stdout] (default task-48)         nextval ('hibernate_sequence')
10:25:20,549 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select nextval ('hibernate_sequence'))
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(1)
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] close()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] isClosed()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] close()
10:25:20,559 DEBUG [org.jboss.as.jpa] (default task-48) default task-48:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: reuse entity manager session already in tx TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-31b1d953:5aa2b1f6:964 status: ActionStatus.RUNNING >
10:25:20,559 INFO  [stdout] (default task-48) Hibernate:
10:25:20,559 INFO  [stdout] (default task-48)     select
10:25:20,559 INFO  [stdout] (default task-48)         nextval ('hibernate_sequence')
10:25:20,559 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select nextval ('hibernate_sequence'))
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(1)
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] close()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] isClosed()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] close()
10:25:20,569 DEBUG [org.jboss.as.jpa] (default task-48) default task-48:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: reuse entity manager session already in tx TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-31b1d953:5aa2b1f6:964 status: ActionStatus.RUNNING >
10:25:20,569 INFO  [stdout] (default task-48) Hibernate:
10:25:20,569 INFO  [stdout] (default task-48)     select
10:25:20,569 INFO  [stdout] (default task-48)         nextval ('hibernate_sequence')
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select nextval ('hibernate_sequence'))
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(1)
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] close()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] isClosed()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,569 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] close()
10:25:20,579 INFO  [stdout] (default task-48) Hibernate:
10:25:20,579 INFO  [stdout] (default task-48)     insert
10:25:20,579 INFO  [stdout] (default task-48)     into
10:25:20,579 INFO  [stdout] (default task-48)         Language
10:25:20,579 INFO  [stdout] (default task-48)         (name, version, id)
10:25:20,579 INFO  [stdout] (default task-48)     values
10:25:20,579 INFO  [stdout] (default task-48)         (?, ?, ?)
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(insert into Language (name, version, id) values (?, ?, ?))
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, Java)
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 16)
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeUpdate()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,579 INFO  [stdout] (default task-48) Hibernate:
10:25:20,579 INFO  [stdout] (default task-48)     insert
10:25:20,579 INFO  [stdout] (default task-48)     into
10:25:20,579 INFO  [stdout] (default task-48)         Language
10:25:20,579 INFO  [stdout] (default task-48)         (name, version, id)
10:25:20,579 INFO  [stdout] (default task-48)     values
10:25:20,579 INFO  [stdout] (default task-48)         (?, ?, ?)
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(insert into Language (name, version, id) values (?, ?, ?))
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, Go)
10:25:20,579 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 17)
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeUpdate()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,589 INFO  [stdout] (default task-48) Hibernate:
10:25:20,589 INFO  [stdout] (default task-48)     insert
10:25:20,589 INFO  [stdout] (default task-48)     into
10:25:20,589 INFO  [stdout] (default task-48)         Language
10:25:20,589 INFO  [stdout] (default task-48)         (name, version, id)
10:25:20,589 INFO  [stdout] (default task-48)     values
10:25:20,589 INFO  [stdout] (default task-48)         (?, ?, ?)
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(insert into Language (name, version, id) values (?, ?, ?))
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, C++)
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 18)
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeUpdate()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
10:25:20,589 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] close()
10:25:20,589 DEBUG [org.jboss.as.jpa] (default task-48) default task-48:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: closing entity managersession
10:25:20,589 DEBUG [org.jboss.as.jpa] (default task-48) default task-48:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: created entity manager session TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-31b1d953:5aa2b1f6:963 status: ActionStatus.RUNNING >
10:25:20,589 INFO  [org.hibernate.hql.internal.QueryTranslatorFactoryInitiator] (default task-48) HHH000397: Using ASTQueryTranslatorFactory
10:25:20,599 INFO  [stdout] (default task-48) Hibernate:
10:25:20,599 INFO  [stdout] (default task-48)     select
10:25:20,599 INFO  [stdout] (default task-48)         language0_.id as id1_0_,
10:25:20,599 INFO  [stdout] (default task-48)         language0_.name as name2_0_,
10:25:20,599 INFO  [stdout] (default task-48)         language0_.version as version3_0_
10:25:20,599 INFO  [stdout] (default task-48)     from
10:25:20,599 INFO  [stdout] (default task-48)         Language language0_
10:25:20,599 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
10:25:20,599 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select language0_.id as id1_0_, language0_.name as name2_0_, language0_.version as version3_0_ from Language language0_)
10:25:20,599 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
10:25:20,599 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
10:25:20,599 DEBUG [jboss.jdbc.spy] (default task-48) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
	
/ in postgres,
test=> select * from language;
 id | name | version
----+------+---------
 16 | Java |       0
 17 | Go   |       0
 18 | C++  |       0
(3 rows)

/ in h2, 
sql> select *from language;
ID | NAME | VERSION
(0 rows, 10 ms)

/ 13	. 

/ native query,

/ 13	. 

/ google: 
https://stackoverflow.com/questions/4362876/how-to-view-the-sql-queries-issued-by-jpa

[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.SQL:add
{"outcome" => "success"}
[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.SQL:write-attribute(
name=  value=
[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.SQL:write-attribute(name=level,value=DEBUG)
{"outcome" => "success"}
[standalone@localhost:9990 /] reload

[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.type:add
{"outcome" => "success"}
[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.type:write-attribute(name=level,value=TRACE)
{"outcome" => "success"}
[standalone@localhost:9990 /] reload

/ we hebben nu in persistence config en hier	, we zien ze allebei in de log,

/ we zien org.hibernate.SQL en stdout beide	de query geven, en ook org.hibernate.spy,
/ we zien ook org.hibernate.spy en org.hibernate.type beide de args geven	,

16:27:23,791 DEBUG [org.hibernate.SQL] (default task-5)
    insert
    into
        Language
        (name, version, id)
    values
        (?, ?, ?)
16:27:23,792 INFO  [stdout] (default task-5) Hibernate:
16:27:23,792 INFO  [stdout] (default task-5)     insert
16:27:23,793 INFO  [stdout] (default task-5)     into
16:27:23,793 INFO  [stdout] (default task-5)         Language
16:27:23,798 INFO  [stdout] (default task-5)         (name, version, id)
16:27:23,799 INFO  [stdout] (default task-5)     values
16:27:23,799 INFO  [stdout] (default task-5)         (?, ?, ?)
16:27:23,800 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(insert into Language (name, version, id) values (?, ?, ?))

16:27:23,801 TRACE [org.hibernate.type.descriptor.sql.BasicBinder] (default task-5) binding parameter [1] as [VARCHAR] - [Go]
16:27:23,802 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setString(1, Go)

16:27:23,802 TRACE [org.hibernate.type.descriptor.sql.BasicBinder] (default task-5) binding parameter [2] as [INTEGER] - [0]
16:27:23,803 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setInt(2, 0)

16:27:23,804 TRACE [org.hibernate.type.descriptor.sql.BasicBinder] (default task-5) binding parameter [3] as [BIGINT] - [83]
16:27:23,804 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] setLong(3, 83)

16:27:23,806 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeUpdate()
16:27:23,807 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
16:27:23,807 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
16:27:23,808 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
16:27:23,809 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()

16:27:23,835 DEBUG [org.jboss.as.jpa] (default task-5) default task-5:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: closing entity managersession
16:27:23,836 DEBUG [org.jboss.as.jpa] (default task-5) default task-5:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: created entity manager session Tran
16:27:23,837 INFO  [org.hibernate.hql.internal.QueryTranslatorFactoryInitiator] (default task-5) HHH000397: Using ASTQueryTranslatorFactory
16:27:23,840 DEBUG [org.hibernate.SQL] (default task-5)
    select
        language0_.id as id1_0_,
        language0_.name as name2_0_,
        language0_.version as version3_0_
    from
        Language language0_
16:27:23,842 INFO  [stdout] (default task-5) Hibernate:
16:27:23,843 INFO  [stdout] (default task-5)     select
16:27:23,844 INFO  [stdout] (default task-5)         language0_.id as id1_0_,
16:27:23,845 INFO  [stdout] (default task-5)         language0_.name as name2_0_,
16:27:23,848 INFO  [stdout] (default task-5)         language0_.version as version3_0_
16:27:23,848 INFO  [stdout] (default task-5)     from
16:27:23,849 INFO  [stdout] (default task-5)         Language language0_
16:27:23,850 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
16:27:23,851 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select language0_.id as id1_0_, language0_.name as name2_0_, langu
16:27:23,851 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
16:27:23,853 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:27:23,854 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
16:27:23,854 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:27:23,855 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-5) extracted value ([id1_0_] : [BIGINT]) - [82]
16:27:23,856 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
16:27:23,856 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:27:23,857 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-5) extracted value ([name2_0_] : [VARCHAR]) - [Java]
16:27:23,858 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
16:27:23,859 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:27:23,864 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-5) extracted value ([version3_0_] : [INTEGER]) - [0]
16:27:23,865 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:27:23,866 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
16:27:23,867 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:27:23,868 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-5) extracted value ([id1_0_] : [BIGINT]) - [83]
16:27:23,869 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
16:27:23,869 DEBUG [jboss.jdbc.spy] (default task-5) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:27:23,870 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-5) extracted value ([name2_0_] : [VARCHAR]) - [Go]

/ 13	. 

/ native of niet, alleen org.hibernate.type laat bij een select de extracted value zien	,

/ eerst de native query,

16:53:25,054 DEBUG [org.hibernate.SQL] (default task-74)
    select
        *
    from
        language
16:53:25,055 INFO  [stdout] (default task-74) Hibernate:
16:53:25,055 INFO  [stdout] (default task-74)     select
16:53:25,055 INFO  [stdout] (default task-74)         *
16:53:25,055 INFO  [stdout] (default task-74)     from
16:53:25,055 INFO  [stdout] (default task-74)         language
16:53:25,056 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
16:53:25,056 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select * from language )
16:53:25,056 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
16:53:25,057 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getMetaData()
16:53:25,057 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,058 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getBigDecimal(id)
16:53:25,058 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,058 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([id] : [NUMERIC]) - [103]
16:53:25,058 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name)
16:53:25,059 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,059 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([name] : [VARCHAR]) - [Java]
16:53:25,059 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version)
16:53:25,059 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,059 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([version] : [INTEGER]) - [0]
16:53:25,059 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,059 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getBigDecimal(id)
16:53:25,060 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,060 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([id] : [NUMERIC]) - [104]
16:53:25,064 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name)
16:53:25,065 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,065 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([name] : [VARCHAR]) - [Go]
16:53:25,065 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version)
16:53:25,065 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,066 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([version] : [INTEGER]) - [0]
16:53:25,066 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,066 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getBigDecimal(id)
16:53:25,066 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,066 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([id] : [NUMERIC]) - [105]
16:53:25,066 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name)
16:53:25,066 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,067 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([name] : [VARCHAR]) - [C++]
16:53:25,067 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version)
16:53:25,067 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,067 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-74) extracted value ([version] : [INTEGER]) - [0]
16:53:25,067 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,067 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [ResultSet] close()
16:53:25,067 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [PreparedStatement] isClosed()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getMaxRows()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [PreparedStatement] getQueryTimeout()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [PreparedStatement] close()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [Connection] isClosed()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [Connection] getWarnings()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [Connection] clearWarnings()
16:53:25,068 DEBUG [jboss.jdbc.spy] (default task-74) java:jboss/datasources/PostgreSQLDS [Connection] close()
16:53:25,069 DEBUG [org.jboss.as.jpa] (default task-74) default task-74:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: closing entity manager
16:53:25,070 INFO  [stdout] (default task-74) 103,Java,0                 / deze print we zelf in de test,
16:53:25,070 INFO  [stdout] (default task-74) 104,Go,0
16:53:25,070 INFO  [stdout] (default task-74) 105,C++,0

/ de hql query,

16:53:25,100 DEBUG [org.jboss.as.jpa] (default task-78) default task-78:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: created entity manager
16:53:25,100 INFO  [org.hibernate.hql.internal.QueryTranslatorFactoryInitiator] (default task-78) HHH000397: Using ASTQueryTranslatorFactory
16:53:25,102 DEBUG [org.hibernate.SQL] (default task-78)
    select
        language0_.id as id1_0_,
        language0_.name as name2_0_,
        language0_.version as version3_0_
    from
        Language language0_
16:53:25,103 INFO  [stdout] (default task-78) Hibernate:
16:53:25,103 INFO  [stdout] (default task-78)     select
16:53:25,103 INFO  [stdout] (default task-78)         language0_.id as id1_0_,
16:53:25,103 INFO  [stdout] (default task-78)         language0_.name as name2_0_,
16:53:25,103 INFO  [stdout] (default task-78)         language0_.version as version3_0_
16:53:25,103 INFO  [stdout] (default task-78)     from
16:53:25,103 INFO  [stdout] (default task-78)         Language language0_
16:53:25,103 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()
16:53:25,104 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [Connection] prepareStatement(select language0_.id as id1_0_, language0_.name as nam
16:53:25,104 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [PreparedStatement] executeQuery()
16:53:25,105 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,105 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
16:53:25,105 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,105 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([id1_0_] : [BIGINT]) - [103]
16:53:25,105 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
16:53:25,105 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,105 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([name2_0_] : [VARCHAR]) - [Java]
16:53:25,106 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
16:53:25,106 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,106 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([version3_0_] : [INTEGER]) - [0]
16:53:25,106 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,106 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
16:53:25,106 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,106 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([id1_0_] : [BIGINT]) - [104]
16:53:25,107 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
16:53:25,107 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,107 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([name2_0_] : [VARCHAR]) - [Go]
16:53:25,107 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
16:53:25,107 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,107 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([version3_0_] : [INTEGER]) - [0]
16:53:25,107 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] next()
16:53:25,108 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getLong(id1_0_)
16:53:25,108 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,108 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([id1_0_] : [BIGINT]) - [105]
16:53:25,108 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getString(name2_0_)
16:53:25,108 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,108 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([name2_0_] : [VARCHAR]) - [C++]
16:53:25,109 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] getInt(version3_0_)
16:53:25,109 DEBUG [jboss.jdbc.spy] (default task-78) java:jboss/datasources/PostgreSQLDS [ResultSet] wasNull()
16:53:25,109 TRACE [org.hibernate.type.descriptor.sql.BasicExtractor] (default task-78) extracted value ([version3_0_] : [INTEGER]) - [0]

/ 13	. 

/ we kunnen native query,

		Query q=em.createNativeQuery(
				"select id,name,version "
				+ "from language ");
				
/ of,
		Query q=em.createNativeQuery(
				"select * "
				+ "from language ");
				
/ Als je * use, dan moet je in de test wel de volgorde weten, want we doen	,

		List<Object[]>ls=languageDao.findLanguagesNatively();
		
		for(Object[]objs:ls) {
			int id=((BigInteger)objs[0]).intValue();
			String name=(String)objs[1];
			int version=(Integer)objs[2];
			
/ 13	. 

/ waarom bij Object[] BigInteger en bij Language Long?
/ TODO

$ vi LanguageDaoTest.java

	@Test
	public void testLanguagesNatively() {
		
		List<Object[]>ls=languageDao.findLanguagesNatively();
		
		for(Object[]objs:ls) {
			long id=((BigInteger)objs[0]).longValue();
			String name=(String)objs[1];
			int version=(Integer)objs[2];
			System.out.println("LanguageDao.testLanguagesNatively: "+id+","+name+","+version);
			assertEquals(0, version);
		}
		
	}
	@Test
	public void testLanguagesNatively2() {
		List<Language>ls=languageDao.findLanguagesNatively2();
		for(Language l:ls) {
			long id=l.getId();
			String name=l.getName();
			int version=l.getVersion();
			System.out.println("LanguageDao.testLanguagesNatively2: "+id+","+name+","+version);
			assertEquals(0, version);
		
		}
	}
	
/ Dit zijn de tables gen in postgres en h2,
 
17:21:37,454 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 86) java:jboss/datasources/PostgreSQLDS [Statement] getWarnings()
17:21:37,454 DEBUG [org.hibernate.SQL] (ServerService Thread Pool -- 86)
    create table Language (
        id int8 not null,
        name varchar(255),
        version int4,
        primary key (id)
    )
17:21:37,121 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 85) java:jboss/datasources/RemoteExampleDS [Statement]
    create table Language (
        id bigint not null,
        name varchar(255),
        version integer,
        primary key (id)
    ))	

/ 13	 

/ lees,
https://vladmihalcea.com/how-to-resolve-the-hibernate-global-database-schema-and-catalog-for-native-sql-queries/

/ 13	. 

<property name="hibernate.hbm2ddl.auto" value="create"/> in de pu doet vooraf, aan het begin:

/ in H2:

07:01:54,424 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 131) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    drop table Language if exists)
07:01:54,424 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 131) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    drop sequence if exists hibernate_sequence)
07:01:54,439 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 131) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    create sequence hibernate_sequence start with 1 increment by 1)
07:01:54,439 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 131) java:jboss/datasources/RemoteExampleDS [Statement] executeUpdate(
    create table Language (
        id bigint not null,
        name varchar(255),
        version integer,
        primary key (id)
    ))

/ in PostgreSQL:

07:01:54,754 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 134) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    drop sequence hibernate_sequence)
07:01:54,769 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 134) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    create sequence hibernate_sequence start 1 increment 1)
07:01:54,769 DEBUG [jboss.jdbc.spy] (ServerService Thread Pool -- 134) java:jboss/datasources/PostgreSQLDS [Statement] executeUpdate(
    create table Language (
        id int8 not null,
        name varchar(255),
        version int4,
        primary key (id)
    ))

    
/ in H2:

sql> select*
...> from information_schema.sequences;
SEQUENCE_CATALOG | SEQUENCE_SCHEMA | SEQUENCE_NAME      | CURRENT_VALUE | INCREMENT | IS_GENERATED | REMARKS | CACHE | ID
TEST             | PUBLIC          | HIBERNATE_SEQUENCE | 3             | 1         | FALSE        |         | 32    | 14
(1 row, 16 ms)

sql> autocommit
Usage: autocommit [true|false]
Autocommit is now true
/ Zo ga je na of je autocommit bent of niet,






/ 13	. 

/ we zagen dat met <property name="hibernate.hbm2ddl.auto" value="create"/> in de pu er 3 languages in de tabel languages kwamen	, 
/ maar zonder deze property 6	, 
/ Dit zien we niet meer	,

/ als we in H2 en in Postgres de sequences en tabellen zelf maken,

sql> drop table language if exists;
/ OK
sql> drop table if exists Language;
/ Kan ook,
sql> drop sequence if exists hibernate sequence;
sql> create sequence hibernate_sequence start with 1 increment by 1;
/ OK,
sql> create sequence hibernate_sequence2 start 1 increment  1;
/ kan ook,
create table language(
	id bigint not null,
	name varchar(255),
	version integer,
	primary key(id)
)

$ psql -Ueric test
create sequence hibernate_sequence start 1 increment 1
create table language (			
	id int8 not null,			-- bigint
	name varchar(255),
	version int4,				-- integer
	primary key (id)
)

/ 13	. 

/ we hadden de b's voor debug chameleon,

Basket [line: 37] - placeOrder()	
BasketTest [line: 23] - createJar()	
BasketTest [line: 42] - testPlaceOrder()	
ChameleonConfiguration [line: 47] - validate()	
ChameleonContainer [line: 76] - init(ChameleonConfiguration, ContainerDef)	
ChameleonContainer [line: 107] - setup(ContainerConfiguration)	
ChameleonExtension [line: 28] - register(ExtensionBuilder)	
ContainerDefImpl [line: 52] - ContainerDefImpl(String, Node, Node)	
ContainerLoader [line: 37] - load(InputStream, File)	
DefaultArtifactResolver [line: 246] - resolveArtifacts(RepositorySystemSession, Collection<? extends ArtifactRequest>)	
DefaultArtifactResolver [line: 419] - resolve(RepositorySystemSession, Collection<? extends ArtifactRequest>)	
DefaultArtifactResolver [line: 424] - resolve(RepositorySystemSession, Collection<? extends ArtifactRequest>)	
DefaultArtifactResolver [line: 431] - resolve(RepositorySystemSession, Collection<? extends ArtifactRequest>)	
DefaultArtifactResolver [line: 447] - resolve(RepositorySystemSession, Collection<? extends ArtifactRequest>)	
DefaultDependencyCollector [line: 254] - collectDependencies(RepositorySystemSession, CollectRequest)	
DefaultRepositorySystem [line: 392] - updateNodesWithResolvedArtifacts(List<ArtifactResult>)	
GameDao [line: 45] - clear()	
GameDao [line: 57] - inserts()	
GameDao [line: 69] - selectPg()	
GameDao [line: 74] - selectH2()	
GreeterTest [line: 34] - shouldCreateGreeting()	
HelloWorldAppClient [line: 23] - sayHello()	
InitiateContainer [line: 37] - setup(EventContext<SetupContainer>)	
InitiateContainer [line: 49] - initiateChameleon(SetupContainer)	
LanguageDao [line: 59] - inserts()	
Loader [line: 51] - loadContainers(ClassLoader, InputStream)	
ManagerImpl [line: 433] - createExtensions(Collection<Class<?>>)	
MavenRepositorySystem [line: 121] - resolveDependencies(RepositorySystemSession, MavenWorkingSession, CollectRequest, MavenResolutionFilter[])	
MyService [line: 28] - init()	
MyService [line: 40] - setName(String)	
MyServiceTest [line: 28] - createDeployment()	
MyServiceTest [line: 33] - should_be_deployed()	
MyServiceTest [line: 61] - testStateless()	
MyServiceTest [line: 66] - testStateless()	
MyServiceTest [line: 67] - testStateless()	
MyServiceTest [line: 76] - testStateful()	
MyServiceTest [line: 80] - testStateful()	
MySfService [line: 21] - ini()	
MySfService [line: 25] - init()	
MySfService [line: 42] - setName(String)	
MyTest [line: 40] - init()	
PatternTest [line: 41] - test()	
Resolver [line: 36] - resolve(File, MavenDependency[])	
TargetController [line: 53] - TargetController(ContainerAdapter, Injector, File)	
TargetController [line: 74] - setup(ContainerConfiguration)	
TargetController [line: 85] - start()	
TargetController [line: 129] - deploy(Descriptor)	
TargetController [line: 146] - deployment(Callable<T>)	
TargetController [line: 179] - resolveClasspathDependencies(ContainerAdapter, File)	
Utils [line: 58] - toMavenDependencies(String[], String[])	
XAManagedConnection [line: 330] - prepare(Xid)	
XAManagedConnection [line: 338] - XAManagedConnection	
XAManagedConnection [line: 346] - rollback(Xid)	
XAManagedConnection [line: 354] - forget(Xid)	


///////////////////
/ DEBUG CHAMELEON TEST IN WILDFLY

/ 7	. 


/ lees,
http://blog.codeleak.pl/2017/06/remote-debugging-wildfly-application-in.html
agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n
/ TODO (suspend=n)
/ en management	, 
/ TODO

/ we maken in eclipse 2 Debug configs, Remote Java Application	, beide op arquillian-forge4,

Name: aquillian-forge4-remote
Project: aquillian-forge4
Host: localhost
Port: 5005

Name: aquillian-forge4-remote-wildfly
Project: aquillian-forge4
Host: localhost
Port: 8787

/ De eerste debugs chameleon, dit is in een aparte VM, niet die van wildfly,
/ we moeten eerst de Run config arquillian-forge4-clean-test-debuggable exec, die $ mvn -Dmaven.surefire.debug clean test doet,

/ de 2de debugs wildfly, dus de test 	, en we moeten eerst  op de command line:
$ standalone.bat --debug
/ daarna in eclipse: 
aquillian-forge4-remote-wildfly
/ daarna in forge:
$ build test

/ 7	. 

/ als we debug onder 8787	, zien we 
Edit source lookup path
org.jboss.as.jpa.container.TransactionScopedEntityManager@35df874

/ in wildfly zien de de jars:

C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir /s *jpa*.jar

 Directory of C:\Users\ervelden\bin\wildfly-10.1.0.Final\modules\system\layers\base\javax\persistence\api\main

18-08-2016  18:12           113.371 hibernate-jpa-2.1-api-1.0.0.Final.jar
               1 File(s)        113.371 bytes

 Directory of C:\Users\ervelden\bin\wildfly-10.1.0.Final\modules\system\layers\base\org\apache\openjpa\main

18-08-2016  18:12             6.684 jipijapa-openjpa-10.1.0.Final.jar
               1 File(s)          6.684 bytes

 Directory of C:\Users\ervelden\bin\wildfly-10.1.0.Final\modules\system\layers\base\org\jboss\as\jpa\main

18-08-2016  18:12           258.476 wildfly-jpa-10.1.0.Final.jar

/ het is de laatste	, 
/ we download apart	,
/ TODO 

C:\Users\ervelden\java\wildfly-source-jars>dir
 Directory of C:\Users\ervelden\java\wildfly-source-jars

16-03-2018  08:34    <DIR>          .
16-03-2018  08:34    <DIR>          ..
16-03-2018  08:30           189.079 wildfly-jpa-10.1.0.Final-sources.jar

/ 13	. 

/ lees,
https://stackoverflow.com/questions/2059431/get-source-jars-from-maven-repository
/ als je een pom.xml hebt, kun je doen	, 
mvn dependency:sources

/ 13	. 

/ misschien komt het omdat we remote debug, want vaak zien we dat eclipse het zelf doet	,
/ Kunnen we in eclipse de test ook rechtstreeks debug? 
/ TODO

/ 13	. 

/ we add source jars,
C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\system\layers\base\org\hibernate\main\hibernate-core-5.0.10.Final.jar | findstr SessionImpl

/ we hebben nu,
C:\Users\ervelden\java\wildfly-source-jars>dir
16-03-2018  11:26         4.030.796 hibernate-core-5.0.10.Final-sources.jar
16-03-2018  11:11           321.097 hibernate-entitymanager-5.0.10.Final-sources.jar
16-03-2018  08:30           189.079 wildfly-jpa-10.1.0.Final-sources.jar

/ 13	. 

/ Tijdens debug zien we steeds exception, 
/ we zien,
$ jboss-cli.bat -c
[standalone@localhost:9990 /] /subsystem=transactions:read-resource(recursive=true)
{
    "outcome" => "success",
    "result" => {
        "default-timeout" => 300,
		
[standalone@localhost:9990 /] /subsystem=transactions:write-attribute(name=default-timeout,value=86400)
[standalone@localhost:9990 /] reload

/ Ik weet niet of dit helpt	, 
/ we zagen de ERRs	,
org.hibernate.HibernateException: Transaction was rolled back in a different thread!	
HHH000451: Transaction afterCompletion called by a background thread; delaying afterCompletion processing until the original thread can handle it.
/ lees,
https://stackoverflow.com/questions/28992996/multithreading-transactions-hanging-during-persisting-entity-to-postgresql-via-w
/ met Mihalcea	,


/ 13	. 

/s,
repository.LanguageDao.inserts() line: 61
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
/s,		
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580
            transactionIsRequired();
            getEntityManager().persist(entity);
/s,			
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
        isInTx = TransactionUtil.isInTx(transactionManager);

        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 162	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
        if (entityManager == null) {
            entityManager = createEntityManager(emf, properties, synchronizationType);
            if (ROOT_LOGGER.isDebugEnabled()) {
/n,
/ TODO LOG
                ROOT_LOGGER.debugf("%s: created entity manager session %s", TransactionUtil.getEntityManagerDetails(entityManager, scopedPuName),
                        TransactionUtil.getTransaction(transactionManager).toString());
            }
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/pd,
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
			internalGetSession().persist( entity );
/s,
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 135	
		if ( session == null ) {
/n,
this	org.hibernate.jpa.internal.EntityManagerImpl  (id=543)	
	session	org.hibernate.internal.SessionImpl  (id=544)	
		persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=645)	
			collectionEntries	org.hibernate.internal.util.collections.IdentityMap<K,V>  (id=665)	
			collectionsByKey	java.util.HashMap<K,V>  (id=668)	
			entitiesByKey	java.util.HashMap<K,V>  (id=671)	
			entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=675)	
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
			internalGetSession().persist( entity );
/pd,
/s,
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
		firePersist( new PersistEvent( entityName, object, this ) );
/s,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
			listener.onPersist( event );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
		onPersist( event, new IdentityHashMap( 10 ) );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 69	
		else {
			entity = object;
entity	domain.Language  (id=797)	
		else {
			entityName = source.bestGuessEntityName( entity );
			event.setEntityName( entityName );
		}
event	org.hibernate.event.spi.PersistEvent  (id=802)	
	entityName	"domain.Language" (id=3433)	
	object	domain.Language  (id=797)	
	session	org.hibernate.internal.SessionImpl  (id=801)	

			final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
source	org.hibernate.internal.SessionImpl  (id=801)	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=3491)	
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntry(java.lang.Object) line: 433	
		return entityEntryContext.getEntityEntry( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		// locate a ManagedEntity for the entity, but only if it is associated with the same PersistenceContext.
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
null
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 99	
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
/d,
null
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).getEntityState(java.lang.Object, java.lang.String, org.hibernate.engine.spi.EntityEntry, org.hibernate.engine.spi.SessionImplementor) line: 510	

		final boolean traceEnabled = LOG.isTraceEnabled();
/ TODO LOG
		if ( entry != null ) { // the object is persistent
/n,
		// the object is transient or detached

		// the entity is not associated with the session, so
		// try interceptor and unsaved-value

		if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source ) ) {
/s,

	
		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
		isUnsaved = persister.isTransient( entity, session );
		...
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/d,
			case TRANSIENT: {
				entityIsTransient( event, createCache );
				break;
			}
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 183	
		LOG.trace( "Saving transient instance" );
/d,

/ Intermezzo

/ bekijk	,
https://www.thoughts-on-java.org/hibernate-logging-guide/
https://logging.apache.org/log4j/2.x/manual/customloglevels.html

 WARN < INFO < DEBUG < TRACE < ALL

[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.jpa:add
{"outcome" => "success"}
[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate.jpa:write-attribute(name=level,value=TRACE)
{"outcome" => "success"}
[standalone@localhost:9990 /] reload

[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate:add
{"outcome" => "success"}
[standalone@localhost:9990 /] /subsystem=logging/logger=org.hibernate:write-attribute(name=level,value=TRACE)
{"outcome" => "success"}
[standalone@localhost:9990 /] reload

/ org.hibernate.SQL, org.hibernate.type zijn packages	, 
/ deze zie je en de sub packages,

/ in jboss-cli.sh -c zien we 
[standalone@localhost:9990 /] /subsystem=logging/logger=
com.arjuna           org.hibernate.SQL    org.jboss.as.config  sun.rmi
jboss.jdbc.spy       org.hibernate.type   org.jboss.as.jpa

/ we zien in wildfly's console,

17:24:49,297 DEBUG [org.hibernate.SQL] (ServerService Thread Pool -- 59) ...
17:24:49,202 DEBUG [org.hibernate.type.BasicTypeRegistry] (ServerService Thread Pool -- 59) Adding type registration java.time.ZonedDateTime -> org.hibernate.type.ZonedDateTimeType@2df7bf71
17:24:49,262 TRACE [org.hibernate.type.TypeFactory] (ServerService Thread Pool -- 59) Scoping types to session factory org.hibernate.internal.SessionFactoryImpl@a566992



/ Einde Intermezzo

		final Object entity = source.getPersistenceContext().unproxy( event.getObject() );
entity	domain.Language  (id=427)	


/ Intermezzo

org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1152	
		try {
			internalGetSession().persist( entity );
		}
		catch ( RuntimeException e ) {
e=org.hibernate.HibernateException: Transaction was rolled back in a different thread!

/ in wildfly's console zien we:

17:46:42,397 ERROR [org.jboss.as.ejb3.invocation] (default task-70) WFLYEJB0034: EJB Invocation failed on component LanguageDao for method public java.util.List repository.LanguageDao.findLanguagesNatively2(): javax.ejb.EJBTransactionRolledbackException: Transaction rolled back

Caused by: javax.transaction.RollbackException: WFLYEJB0447: Transaction 'TransactionImple < ac, BasicAction: 0:ffff0ac70302:6347ed11:5aab6cff:bf8 status: ActionStatus.ABORTED >' was already rolled back
        at org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(CMTTxInterceptor.java:98)
...
17:51:45,155 WARN  [com.arjuna.ats.arjuna] (Transaction Reaper Worker 1) ARJUNA012108: CheckedAction::check - atomic action 0:ffff0ac70302:6347ed11:5aab6cff:c74 aborting with 1 threads active!
17:51:45,155 WARN  [org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl] (Transaction Reaper Worker 1) HHH000451: Transaction afterCompletion called by a background thread; delaying afterCompletion processing until the original thread can handle it. [status=4]
17:51:45,155 WARN  [com.arjuna.ats.arjuna] (Transaction Reaper Worker 1) ARJUNA012121: TransactionReaper::doCancellations worker Thread[Transaction Reaper Worker 1,5,main] successfully canceled TX 0:ffff0ac70302:6347ed11:5aab6cff:c74

/ Einde Intermezzo

		if ( createCache.put( entity, entity ) == null ) {
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 66	
		callbackRegistry.preCreate( entity );
/ TODO
		return super.saveWithGeneratedId( entity, entityName, anything, source, requiresImmediateIdAccess );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 100	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
/s,
org.hibernate.internal.SessionImpl.getEntityPersister(java.lang.String, java.lang.Object) line: 1529	
			try {
				return factory.getEntityPersister( entityName ).getSubclassEntityPersister( object, getFactory() );
entityName=domain.Language
/s,
org.hibernate.internal.SessionFactoryImpl.getEntityPersister(java.lang.String) line: 779	
		EntityPersister result = entityPersisters.get( entityName );
		
/ entityPersisters={domain.Language=SingleTableEntityPersister(domain.Language)}
/ is er al,
		return result;
/t,
org.hibernate.internal.SessionImpl.getEntityPersister(java.lang.String, java.lang.Object) line: 1529	
			try {
				return factory.getEntityPersister( entityName ).getSubclassEntityPersister( object, getFactory() );
SingleTableEntityPersister(domain.Language)
/ subclass entity persister= de entity persister,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
/d,
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/s,
		return entityMetamodel.getIdentifierProperty().getIdentifierGenerator();
/t,
/s,
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/s,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
		IntegralDataTypeHolder value = callback.getNextValue();
/s,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94	
	public AccessCallback buildCallback(final SessionImplementor session) {		
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {											/ hier waren we net,
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;												/ nu zijn we hier,
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
this$0.sql=call next value for hibernate_sequence
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
							value.initialize( rs, 1 );
BasicHolder[java.lang.Long[43]]
							if ( LOG.isDebugEnabled() ) {
								LOG.debugf( "Sequence value obtained: %s", value.makeValue() );
							return value;
						finally {
							try {
								session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
					finally {
						session.getJdbcCoordinator().getResourceRegistry().release( st );
						session.getJdbcCoordinator().afterStatementExecution();
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 102	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/d,
		else {
			// TODO: define toString()s for generators
			if ( LOG.isDebugEnabled() ) {
				LOG.debugf(
						"Generated identifier: %s, using strategy: %s",
						persister.getIdentifierType().toLoggableString( generatedId, source.getFactory() ),
						persister.getIdentifierGenerator().getClass().getName()
				);
			}

			return performSave( entity, generatedId, persister, false, anything, source, true );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 152	
		if ( LOG.isTraceEnabled() ) {
			LOG.tracev( "Saving {0}", MessageHelper.infoString( persister, id, source.getFactory() ) );
		}
		if ( !useIdentityColumn ) {
			key = source.generateEntityKey( id, persister );
EntityKey[domain.Language#43]
			Object old = source.getPersistenceContext().getEntity( key );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntity(org.hibernate.engine.spi.EntityKey) line: 393	
		return entitiesByKey.get( key );
entitiesByKey={EntityKey[domain.Language#42]=Language name: Java}
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 152	
			Object old = source.getPersistenceContext().getEntity( key );
			if ( old != null ) {
/n,
			persister.setIdentifier( entity, id, source );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).setIdentifier(java.lang.Object, java.io.Serializable, org.hibernate.engine.spi.SessionImplementor) line: 260	
		else if ( idSetter != null ) {
			idSetter.set( entity, id, getFactory() );
target	domain.Language  (id=560)	
	serialVersionUID	1	
	id	java.lang.Long  (id=717)	 43		/ WAS: id null 
	name	"Go" (id=563)	
	version	0	
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 178	
			persister.setIdentifier( entity, id, source );
/d,
		return performSaveOrReplicate(
				entity,
				key,
				persister,
				useIdentityColumn,
				anything,
				source,
				requiresImmediateIdAccess
		);
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 227	
/ BREAKPOINT
		// Put a placeholder in entries, so we don't recurse back and try to save() the
		// same object again. QUESTION: should this be done before onSave() is called?
		// likewise, should it be done before onUpdate()?
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 509	
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/s,
org.hibernate.engine.internal.MutableEntityEntryFactory.createEntityEntry(org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean, org.hibernate.engine.spi.PersistenceContext) line: 48	
		return new MutableEntityEntry(
				status,
				loadedState,
				rowId,
				id,
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched,
				persistenceContext
		);
/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 542	
			e = ( (ImmutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/d,
		entityEntryContext.addEntityEntry( entity, e );
/s,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 77	

		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		if ( ManagedEntity.class.isInstance( entity ) ) {
/n,
		else {
			return nonEnhancedEntityXref != null
					? nonEnhancedEntityXref.get( entity )	/ null, want entity = Language Go	, zit er niet in,
					: null;
			
/ 			
this	org.hibernate.engine.internal.EntityEntryContext  (id=786)	
	head	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=944)	
			id	java.lang.Long  (id=949)	
		entityInstance	domain.Language  (id=549)
	nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=805)		/ TODO
		size	1	
		table	java.lang.Object[64]  (id=829)	
			[52]	domain.Language  (id=549)	
				entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=944)	
				entityInstance	domain.Language  (id=549)	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=561)	
		collectionEntries	org.hibernate.internal.util.collections.IdentityMap<K,V>  (id=797)	{}
		collectionsByKey	java.util.HashMap<K,V>  (id=799)		{}
		entitiesByKey	java.util.HashMap<K,V>  (id=728)	
			size	1	
			table	java.util.HashMap$Node<K,V>[8]  (id=1111)	
				[7]	java.util.HashMap$Node<K,V>  (id=1117)	
					hash	671	
					key	org.hibernate.engine.spi.EntityKey  (id=1119)	EntityKey[domain.Language#42]
					next	null	
					value	domain.Language  (id=549)	Language name: Java
		entitiesByUniqueKey	java.util.HashMap<K,V>  (id=800)			{}
		entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=786)
	tail	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)	
	
/ head==tail, want er is er maar 1	,
		

/ de Language Java die er al is zit in de entitiesByKey en in entityEntryContext
/ TODO

/t,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 92	
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
null
		final boolean alreadyAssociated = managedEntity != null;
		if ( !alreadyAssociated ) {
			else {
				if ( nonEnhancedEntityXref == null ) 
/n,
					nonEnhancedEntityXref = new IdentityHashMap<Object, ManagedEntity>();
				}
				managedEntity = new ManagedEntityImpl( entity );
				nonEnhancedEntityXref.put( entity, managedEntity );
				
		// associate the EntityEntry with the entity
		managedEntity.$$_hibernate_setEntityEntry( entityEntry );
/=
			this.entityEntry = entityEntry;

		else {
			tail.$$_hibernate_setNextManagedEntity( managedEntity );
			managedEntity.$$_hibernate_setPreviousManagedEntity( tail );
			// Protect against stale data left in the ManagedEntity nullify next reference.
			managedEntity.$$_hibernate_setNextManagedEntity( null );
			tail = managedEntity;
			count++;
		}

this	org.hibernate.engine.internal.EntityEntryContext  (id=786)	
	count	2	
	head	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=944)	
		entityInstance	domain.Language  (id=549)												Java
		next	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=1172)	
		previous	null	
	tail	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=1172)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=778)	
		entityInstance	domain.Language  (id=560)	
		next	null	
		previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790) Go

/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 544	
		entityEntryContext.addEntityEntry( entity, e );
/d,
		return e;
e=EntityEntry[domain.Language#43](SAVING)
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 235	
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
/d,
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 4680
	
		return getEntityTuplizer().getPropertyValuesToInsert( object, mergeMap, session );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 524	
		final int span = entityMetamodel.getPropertySpan
2
		final Object[] result = new Object[span];

		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
		}
		return result;
[Go, 0]
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 252	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/d,
		Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@5f0344a0, org.hibernate.type.IntegerType@4fea1377]
/ deze komen uit	,
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=606)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=636)	
EntityMetamodel(domain.Language:[Attribute(name=name, type=string [non-identifier]),Attribute(name=version, type=integer [non-identifier])])

		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source );
false
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).addInsertAction(java.lang.Object[], java.io.Serializable, java.lang.Object, org.hibernate.persister.entity.EntityPersister, boolean, org.hibernate.event.spi.EventSource, boolean) line: 322	

		if ( useIdentityColumn ) {
/n,
		else {
			Object version = Versioning.getVersion( values, persister );
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
			source.getActionQueue().addAction( insert );
/s,
org.hibernate.engine.spi.ActionQueue.addAction(org.hibernate.action.internal.EntityInsertAction) line: 241	
		LOG.tracev( "Adding an EntityInsertAction for [{0}] object", action.getEntityName() );
		addInsertAction( action );
/s,
org.hibernate.engine.spi.ActionQueue.addInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 254	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/ TODO
		if ( nonNullableTransientDependencies == null ) {
			LOG.tracev( "Adding insert with no non-nullable, transient entities: [{0}]", insert );
			addResolvedEntityInsertAction( insert );
/s,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 279	
		else {
			LOG.trace( "Adding resolved non-early insert action." );
			addAction( AbstractEntityInsertAction.class, insert );
this	org.hibernate.engine.spi.ActionQueue  (id=1459)	
	insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=1467)	
		executables	java.util.ArrayList<E>  (id=1475)	
			elementData	java.lang.Object[5]  (id=1479)	
				[0]	org.hibernate.action.internal.EntityInsertAction  (id=1481)	
					entityName	"domain.Language" (id=468)	
					id	java.lang.Long  (id=949)	
					instance	domain.Language  (id=549)	
					persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=606)	
					session	org.hibernate.internal.SessionImpl  (id=553)	
					version	java.lang.Integer  (id=955)	
				[1]	org.hibernate.action.internal.EntityInsertAction  (id=1458)	

		}
		insert.makeEntityManaged();
/ WH Status.SAVING replaced by Status.MANAGED	,
/ TODO	,
/s,
org.hibernate.action.internal.EntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction).makeEntityManaged() line: 126	
		nullifyTransientReferencesIfNotAlready();
/ TODO
		final Object version = Versioning.getVersion( getState(), getPersister() );
		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),
				getState(),
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);
	}
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntity(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], org.hibernate.engine.spi.EntityKey, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 464	
		addEntity( entityKey, entity );  /= entitiesByKey.put( key, entity );	, key=EntityKey[domain.Language#43] is er al
		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(),
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);	
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 542	
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
EntityEntry[domain.Language#43](MANAGED)	
/ Is dus al managed	,
/ Hoe vinden we MANAGED terug in e?
/ WH e.compressedState 22	,
/ TODO
		entityEntryContext.addEntityEntry( entity, e );
/s,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 77	
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null
					? nonEnhancedEntityXref.get( entity )
					: null;
		}
/t,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 92	
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=1172)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=778)	
		compressedState	102	
		id	java.lang.Long  (id=717)	
	entityInstance	domain.Language  (id=560)	
	next null	
	previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)	


		final boolean alreadyAssociated = managedEntity != null;
		if ( !alreadyAssociated ) {
/ n,
		/ NIET: 	nonEnhancedEntityXref.put( entity, managedEntity ); / want is al,
		
		// associate the EntityEntry with the entity
		managedEntity.$$_hibernate_setEntityEntry( entityEntry ); / nog een keer,
		
		if ( alreadyAssociated ) {
			// if the entity was already associated with the context, skip the linking step.
			return;
		}
/ dus NIET:
		else {
			tail.$$_hibernate_setNextManagedEntity( managedEntity );
			managedEntity.$$_hibernate_setPreviousManagedEntity( tail );
			// Protect against stale data left in the ManagedEntity nullify next reference.
			managedEntity.$$_hibernate_setNextManagedEntity( null );
			tail = managedEntity;
			count++;
		}
/t,
org.hibernate.engine.spi.ActionQueue.addInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 254	
			addAction( AbstractEntityInsertAction.class, insert );
/ OK	, 
		insert.makeEntityManaged();
/d,
/ WH Status.SAVING replaced by Status.MANAGED	,
/ TODO
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 278
	
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/d,
		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntry(java.lang.Object) line: 433	
		return entityEntryContext.getEntityEntry( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		// locate a ManagedEntity for the entity, but only if it is associated with the same PersistenceContext.
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null
					? nonEnhancedEntityXref.get( entity )
					: null;
					
this	org.hibernate.engine.internal.EntityEntryContext  (id=786)	
	count	2	
	head	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=944)	EntityEntry[domain.Language#42](MANAGED)
		entityInstance	domain.Language  (id=549)	
		next	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=1172)	
		previous	null		
	nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=805)	
		size	2	
		table	java.lang.Object[64]  (id=829)	
			[52]	domain.Language  (id=549)	
			[53]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)	
			[60]	domain.Language  (id=560)	
			[61]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=1172)	
	tail	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=1172)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=1651)	EntityEntry[domain.Language#43](MANAGED)
		entityInstance	domain.Language  (id=560)	
		next	null	
		previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=790)	

/ dus we zien in nonEnhancedEntityXref dezelfde entries als in de EntityEntryContext, idg in head en tail,

/t,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 227	
		// locate a ManagedEntity for the entity, but only if it is associated with the same PersistenceContext.
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
		// and get/return the EntityEntry from the ManagedEntry
		return managedEntity == null
				? null
				: managedEntity.$$_hibernate_getEntityEntry();
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 295
	
		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
/d,
EntityEntry[domain.Language#43](MANAGED)
		if ( newEntry != original ) {
/j,
original	org.hibernate.engine.internal.MutableEntityEntry  (id=778)	EntityEntry[domain.Language#43](SAVING)
newEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=1651)	EntityEntry[domain.Language#43](MANAGED)

			EntityEntryExtraState extraState = newEntry.getExtraState( EntityEntryExtraState.class );
			if ( extraState == null ) {
/j,
				newEntry.addExtraState( original.getExtraState( EntityEntryExtraState.class ) );
null
/ want original.next==null,
/ TODO

/ Intermezzo

/ herinner	, in deze method in het begin,
		// Put a placeholder in entries, so we don't recurse back and try to save() the
		// same object again. QUESTION: should this be done before onSave() is called?
		// likewise, should it be done before onUpdate()?
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);

/ Einde Intermezzo

		return id;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 191	
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/d,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 133	
			case TRANSIENT: {
				entityIsTransient( event, createCache );
/d,
				break;
			}
/t,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 776	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
			listener.onPersist( event );
/d,
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 587	
            getEntityManager().persist(entity);
/d,
        } finally {
            if (isTraceEnabled) {
                long elapsed = System.currentTimeMillis() - start;
                ROOT_LOGGER.tracef("persist entityClass '%s' took %dms", entity.getClass().getName(), elapsed);
/ TODO LOG
            }
        }
/t,
repository.LanguageDao.inserts() line: 71	
	@PostConstruct
	public void inserts() {
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
		l=new Language();
		l.setName("Java");
		em1.persist(l);
		l=new Language();
		l.setName("Go");
		em.persist(l);
		l=new Language();
		l.setName("Go");
		em1.persist(l);
/d,


/ VOLGENDE	,

/s,
repository.LanguageDao.inserts() line: 73	
		l=new Language();
		l.setName("C++");
		em.persist(l);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	

this	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=428)	
	puScopedName	"test.war#arquillian-forge4-persistence-unit" (id=1948)	

        isInTx = TransactionUtil.isInTx(transactionManager);

        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 155
	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getTransactionScopedEntityManager(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 69	
        return getEntityManagerInTransactionRegistry(puScopedName, tsr);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getEntityManagerInTransactionRegistry(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 116	
	        return (EntityManager)tsr.getResource(scopedPuName);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106	
/ deze is in wildfly-transactions-10.1.0.Final.jar

/ Intermezzo

/ je zoekt hem zo op,
C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\system\layers\base\org\jboss\as
...
18-08-2016  18:12    <DIR>          transactions

C:\Users\ervelden\bin\wildfly-10.1.0.Final> dir /s *transactions*jar
 Directory of C:\Users\ervelden\bin\wildfly-10.1.0.Final\modules\system\layers\base\org\jboss\as\transactions\main
18-08-2016  18:12           207.086 wildfly-transactions-10.1.0.Final.jar

/ Einde Intermezzo

		return delegate.getResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 116	
/ TODO
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 156	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
/d,
org.hibernate.jpa.internal.EntityManagerImpl@5b580b80
...

/ FLUSH TO DATABASE

/ Tot nu toe write naar persistenceContext,

/ Intermezzo

/ com.arjuna.ats package zit in 
C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir /s *narayana*jar
 Directory of C:\Users\ervelden\bin\wildfly-10.1.0.Final\modules\system\layers\base\org\jboss\jts\integration\main
18-08-2016  18:12            48.185 narayana-jts-integration-5.3.3.Final.jar

 Directory of C:\Users\ervelden\bin\wildfly-10.1.0.Final\modules\system\layers\base\org\jboss\jts\main
18-08-2016  18:12         1.662.183 narayana-jts-idlj-5.3.3.Final.jar

C:\Users\ervelden\java\wildfly-source-jars>dir

16-03-2018  11:26         4.030.796 hibernate-core-5.0.10.Final-sources.jar
16-03-2018  11:11           321.097 hibernate-entitymanager-5.0.10.Final-sources.jar
18-03-2018  17:49         1.364.353 narayana-jts-idlj-5.3.3.Final-sources.jar
18-03-2018  17:50            43.033 narayana-jts-integration-5.3.3.Final-sources.jar
16-03-2018  08:30           189.079 wildfly-jpa-10.1.0.Final-sources.jar
18-03-2018  14:10           143.279 wildfly-transactions-10.1.0.Final-sources.jar

C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\system\layers\base\org\jboss\as\ejb3\main
18-08-2016  18:12             5.274 module.xml
18-08-2016  18:12         1.566.944 wildfly-ejb3-10.1.0.Final.jar
/ voor org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	


C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\system\layers\base\org\jboss\invocation\main
18-08-2016  18:12             1.633 module.xml
18-08-2016  18:12            75.043 jboss-invocation-1.4.1.Final.jar
/ voor org.jboss.invocation.InterceptorContext.proceed() line: 340	


C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\system\layers\base\org\jboss\as\weld\main
18-08-2016  18:12             3.858 module.xml
18-08-2016  18:12           267.599 wildfly-weld-10.1.0.Final.jar
/ voor org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	

C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\system\layers\base\org\jboss\as\ee\main
18-08-2016  18:12             2.717 module.xml
18-08-2016  18:12           581.564 wildfly-ee-10.1.0.Final.jar
/ voor 
org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	

C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\system\layers\base\org\wildfly\security\elytron\main
18-08-2016  18:12             1.666 module.xml
18-08-2016  18:12           191.730 wildfly-elytron-1.0.2.Final.jar
/ voor org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\system\layers\base\org\jboss\weld\core\main\weld-core-impl-2.3.5.Final.jar
/ voor org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
/ voor org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
/ voor org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\system\layers\base\org\jboss\ironjacamar\jdbcadapters\main\ironjacamar-jdbc-1.3.4.Final.jar
/ voor org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.rollback(javax.transaction.xa.Xid) line: 346	

/ voor org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.rollback(javax.transaction.xa.Xid) line: 196	

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\system\layers\base\org\jboss\ironjacamar\jdbcadapters\main\ironjacamar-jdbc-1.3.4.Final.jar | findstr WrapperDataSource
  5710 Mon May 23 08:13:56 CEST 2016 org/jboss/jca/adapters/jdbc/WrapperDataSource.class
/ voor org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 134	

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf    modules\system\layers\base\org\jboss\ironjacamar\impl\main\ironjacamar-core-impl-1.3.4.Final.jar
   527 Mon May 23 08:13:20 CEST 2016 org/jboss/jca/core/connectionmanager/TxConnectionManager.class
   
/ In ironjacamar\api en \impl zitten meerdere jar's	,

C:\Users\ervelden\bin\wildfly-10.1.0.Final> dir modules\system\layers\base\org\jboss\ironjacamar\api\main
18-08-2016  18:12           222.587 ironjacamar-common-api-1.3.4.Final.jar
18-08-2016  18:12             5.561 ironjacamar-common-spi-1.3.4.Final.jar
18-08-2016  18:12            50.830 ironjacamar-core-api-1.3.4.Final.jar
18-08-2016  18:12             1.706 module.xml

C:\Users\ervelden\bin\wildfly-10.1.0.Final> dir modules\system\layers\base\org\jboss\ironjacamar\impl\main
18-08-2016  18:12           258.976 ironjacamar-common-impl-1.3.4.Final.jar
18-08-2016  18:12           495.172 ironjacamar-core-impl-1.3.4.Final.jar
18-08-2016  18:12            63.638 ironjacamar-deployers-common-1.3.4.Final.jar
18-08-2016  18:12            72.153 ironjacamar-validator-1.3.4.Final.jar
18-08-2016  18:12             2.401 module.xml

/ ironjacamar-jdbc is adapter van de jdbc driver, allebei worden used	,
/ Maar we hebben ook,
C:\Users\ervelden\bin\wildfly-10.1.0.Final>dir modules\com\postgresql\main\postgresql-9.4-1202.jdbc42.jar

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\com\postgresql\main\postgresql-9.4-1202.jdbc42.jar | findstr XA
  2581 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/PGXAConnection$ConnectionHandler.class
  9539 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/PGXAConnection.class
   366 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/PGXADataSource.class
  1471 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/PGXADataSourceFactory.class
   853 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/PGXAException.class
  1806 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/jdbc3/AbstractJdbc3XADataSource.class
   789 Thu Aug 27 20:49:08 CEST 2015 org/postgresql/xa/jdbc4/AbstractJdbc4XADataSource.class

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\system\layers\base\org\jboss\ironjacamar\jdbcadapters\main\ironjacamar-jdbc-1.3.4.Final.jar | findstr XA
   486 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/spi/URLXASelectorStrategy.class
  1657 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/spi/XAData.class
  2881 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/URLXASelector.class
  1232 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnection$1.class
  6623 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnection.class
  1578 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnectionFactory$1$1.class
  1847 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnectionFactory$1.class
  1578 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnectionFactory$2$1.class
  1847 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnectionFactory$2.class
 15320 Mon May 23 08:13:58 CEST 2016 org/jboss/jca/adapters/jdbc/xa/XAManagedConnectionFactory.class
 

C:\Users\ervelden\java\wildfly-source-jars>copy d:\Users\ervelden\Downloads\h2-1.3.173-sources.jar
/ voor org.h2.jdbcx.JdbcXAConnection


/ Einde Intermezzo

/s,

Thread [default task-31] (Suspended (breakpoint at line 467 in org.hibernate.engine.spi.ActionQueue))
	org.hibernate.engine.spi.ActionQueue.prepareActions() line: 467	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 336	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39	
	org.hibernate.internal.SessionImpl.flush() line: 1282	
	org.hibernate.internal.SessionImpl.managedFlush() line: 465	
	org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963	
	org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	
	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();												<-
/cb,				org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);										<-
            }
/cb,			
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 344	
        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);  			<-
            } finally {
                tm.resume(tx);
            }
/cb,
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68	
            case REQUIRES_NEW:
                return requiresNew(invocation, component, transactionTimeout);
/cb,
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 161	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean) line: 134	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).createInstance() line: 88	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 64	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 61	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 56	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view4.findLanguagesNatively2() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.findLanguagesNatively2() line: not available	
	repository.LanguageDaoTest.testLanguagesNatively2() line: 97	
/=
	@Test
	public void testLanguagesNatively2() {
		List<Language>ls=languageDao.findLanguagesNatively2();
/cb,
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	


/ dus we zien dat,
	@Test
	public void testLanguagesNatively2() {
		List<Language>ls=languageDao.findLanguagesNatively2();
		
/ een flush oplevert	, en dat hebben we vroeger ook gezien	,
/ TODO
/ wat is de Invocation hierboven	?
/ TODO

/ CONTINUE

/c,
Thread [default task-31] (Suspended)	
	owns: java.lang.Object  (id=2709)	
	org.hibernate.action.internal.EntityInsertAction.execute() line: 75	
	org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 582
		try {
			for ( E e : list ) {
				try {
					e.execute();
/cb,					
	org.hibernate.engine.spi.ActionQueue.executeActions() line: 456	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 337	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39	
	org.hibernate.internal.SessionImpl.flush() line: 1282	
	org.hibernate.internal.SessionImpl.managedFlush() line: 465	
	org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963	
	org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	
	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 344	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 161	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean) line: 134	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).createInstance() line: 88	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 64	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 61	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 56	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view4.findLanguagesNatively2() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.findLanguagesNatively2() line: not available	
	repository.LanguageDaoTest.testLanguagesNatively2() line: 97	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	
/s,
org.hibernate.action.internal.EntityInsertAction.execute() line: 75	
		nullifyTransientReferencesIfNotAlready();
/ TODO
		final EntityPersister persister = getPersister();
		final SessionImplementor session = getSession();
		final Object instance = getInstance();
		final Serializable id = getId();

		final boolean veto = preInsert();
false
/ hij validates	, en dat gaat OK	,
/ TODO
		if ( !veto ) {			
			persister.insert( id, getState(), instance, session );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3397

		final int span = getTableSpan();
1		
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
			
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=2690)	
id	java.lang.Long  (id=3990)	
fields	java.lang.Object[2]  (id=3994)	
	[0]	"Go" (id=563)	
	[1]	java.lang.Integer  (id=3995)	
object	domain.Language  (id=3991)	
	serialVersionUID	1	
	id	java.lang.Long  (id=3990)	
	name	"Go" (id=563)	
	version	0	
session	org.hibernate.internal.SessionImpl  (id=451)
getPropertyInsertability()[true, true] 	, eig. van meta... TODO
getSQLInsertStrings()=[insert into Language (name, version, id) values (?, ?, ?)]	, eig van de persister,

/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2841	

/ In AbstractEntityPersister zitten methods zoals insert, update,

		if ( LOG.isTraceEnabled() ) {
			LOG.tracev( "Inserting entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
			if ( j == 0 && isVersioned() ) {
				LOG.tracev( "Version: {0}", Versioning.getVersion( fields, this ) );
			}
		}
/ TODO
		// TODO : shouldn't inserts be Expectations.NONE?
		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] ); 
/ insertResultCheckStyles=[COUNT]
expectation	org.hibernate.jdbc.Expectations$BasicExpectation  (id=6454)	
	expectedRowCount	1	

		// we can't batch joined inserts, *especially* not if it is an identity insert;
		// nor can we batch statements where the expectation is based on an output param
		final boolean useBatch = j == 0 && expectation.canBeBatched();
true
/ TODO j==0
		if ( useBatch && inserBatchKey == null ) {
			inserBatchKey = new BasicBatchKey(
					getEntityName() + "#INSERT",
					expectation
			);
		}
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=2690)	
	inserBatchKey	org.hibernate.engine.jdbc.batch.internal.BasicBatchKey  (id=6461)	
		comparison	"domain.Language#INSERT" (id=6460)	
		expectation	org.hibernate.jdbc.Expectations$BasicExpectation  (id=6454)	
			expectedRowCount	1	
		statementCount	1	

		final boolean callable = isInsertCallable( j );

		try {
			// Render the SQL query
			final PreparedStatement insert;
			if ( useBatch ) {
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.getBatch(org.hibernate.engine.jdbc.batch.spi.BatchKey) line: 207	
		if ( currentBatch != null ) {
/n,
		currentBatch = batchBuilder().buildBatch( key, this );
/s,
org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl.buildBatch(org.hibernate.engine.jdbc.batch.spi.BatchKey, org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 63	
		LOG.tracef( "Building batch [size=%s]", size );
		return size > 1
/n, 1
				? new BatchingBatch( key, jdbcCoordinator, size )
				: new NonBatchingBatch( key, jdbcCoordinator );
/t,
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).<init>(org.hibernate.engine.jdbc.batch.spi.BatchKey, org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 63	
		this.key = key;
		this.jdbcCoordinator = jdbcCoordinator;

		final JdbcServices jdbcServices = jdbcCoordinator.getJdbcSessionOwner()
				.getJdbcSessionContext()
				.getServiceRegistry()
				.getService( JdbcServices.class );

		this.sqlStatementLogger = jdbcServices.getSqlStatementLogger();
		this.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();
		
this	org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch  (id=6540)	
	sqlExceptionHelper	org.hibernate.engine.jdbc.spi.SqlExceptionHelper  (id=6467)	
		sqlExceptionConverter	org.hibernate.exception.internal.StandardSQLExceptionConverter  (id=6572)	
			delegates	java.util.ArrayList<E>  (id=6573)	
				elementData	java.lang.Object[10]  (id=6574)	
					[0]	org.hibernate.dialect.PostgreSQL81Dialect$4  (id=6575)	
					[1]	org.hibernate.exception.internal.SQLExceptionTypeDelegate  (id=6576)	
					[2]	org.hibernate.exception.internal.SQLStateConversionDelegate  (id=6577)	
				size	3	
	sqlStatementLogger	org.hibernate.engine.jdbc.spi.SqlStatementLogger  (id=6550)	
			FQCN	"org.jboss.logging.Logger" (id=6557)	
			logger	org.jboss.logmanager.Logger  (id=6558)	
			name	"org.hibernate.SQL" (id=6561)	
		format	true	
		logToStdout	true	
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2878	
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
/d,
						.getBatchStatement( sql, callable );
sql=insert into Language (name, version, id) values (?, ?, ?)
callable=false
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 120	
		PreparedStatement statement = statements.get( sql );
		if ( statement == null ) {
			statement = buildBatchStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).buildBatchStatement(java.lang.String, boolean) line: 136	
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 77	
		jdbcCoordinator.executeBatch();
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.executeBatch() line: 214	
		if ( currentBatch != null ) {
			currentBatch.execute();
/ NIETS	, er zijn geen stmt's	,
			
this	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=2720)	
	currentBatch	org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch  (id=6540)	
		LOG	org.hibernate.internal.CoreMessageLogger_$logger  (id=6554)	
		jdbcCoordinator	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=2720)	
		key	org.hibernate.engine.jdbc.batch.internal.BasicBatchKey  (id=6461)	domain.Language#INSERT
		observers	java.util.LinkedHashSet<E>  (id=6543)	[]
		sqlExceptionHelper	org.hibernate.engine.jdbc.spi.SqlExceptionHelper  (id=6467)	
		sqlStatementLogger	org.hibernate.engine.jdbc.spi.SqlStatementLogger  (id=6550)	
		statements	java.util.LinkedHashMap<K,V>  (id=6542)	{}
/t,
/s,
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
		};
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).<init>(org.hibernate.engine.jdbc.internal.StatementPreparerImpl, java.lang.String) line: 157
/=	
		protected StatementPreparationTemplate(String incomingSql) {
			final String inspectedSql = jdbcCoordinator.getJdbcSessionOwner()
					.getJdbcSessionContext()
					.getStatementInspector()
					.inspect( incomingSql );
			this.sql = inspectedSql == null ? incomingSql : inspectedSql;
		}

		public PreparedStatement prepareStatement() {
/ deze mth is er ook, straks hierin	,
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 78	
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/pd,
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 167	
/=
		public PreparedStatement prepareStatement() {
				getJdbcService().getSqlStatementLogger().logStatement( sql );
/ deze zien we 	,
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementStart();
/s,
org.hibernate.engine.internal.SessionEventListenerManagerImpl.jdbcPrepareStatementStart() line: 88	
		if ( listenerList == null ) {
			return;
/t,
					preparedStatement = doPrepare();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 85	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable											<-
$val.isCallable=false	, 
/ doPrepare is een closure, want hij sluit isCallable die param is van de outer fct in,
				? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
		return logicalConnection().getPhysicalConnection();
/s
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 111	
		return acquireConnectionIfNeeded();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	

				physicalConnection = jdbcConnectionAccess.obtainConnection();
/s,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
				return connectionProvider.getConnection();
/s,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
useCredentials=false
/s,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
        return delegate.getConnection();
/s,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 134	

this	org.jboss.jca.adapters.jdbc.WrapperDataSource  (id=19952)	
	cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=19954)	
	mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=19955)

	         if (mcf.getSpy().booleanValue())
/j,
            spyLogger.debugf("%s [%s] getConnection()",
                             mcf.getJndiName(), Constants.SPY_LOGGER_PREFIX_DATASOURCE);

         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 733	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
null
      ConnectionListener cl = getManagedConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 402	

         Transaction tx = transactionManager.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:3e status: ActionStatus.ABORTING >

         if (tx != null)
         {
            if (!allowMarkedForRollback)
            {
               if (!TxUtils.isActive(tx))
                  if (!getPool().hasConnection(subject, cri) || allowMarkedForRollbackFastFail)
                     throw new ResourceException(bundle.transactionNotActive(tx));  
            }
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).hasConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 842	

      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
      Lock lock = getTSRLock();

      if (lock == null)
         return false;
/t,
...
/ TODO
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/pd,
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 444	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
sql=insert into Language (name, version, id) values (?, ?, ?)
jndiName=java:jboss/datasources/PostgreSQLDS
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 743	
      else
      {
         return doPrepareStatement(sql, resultSetType, resultSetConcurrency);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);
/s,
com.sun.proxy.$Proxy55.prepareStatement(java.lang.String, int, int) line: not available	
/s,
org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 148	

this	org.postgresql.xa.PGXAConnection$ConnectionHandler  (id=20162)	
	con	com.sun.proxy.$Proxy55  (id=20163)	
		h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler  (id=20173)	
			con	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
	this$0	org.postgresql.xa.PGXAConnection  (id=20172)	
		autoCommit	true	
		con	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
			autoCommit	false	
			creatingURL	"jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10" (id=20179
			protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=20182)	
				pgStream	org.postgresql.core.PGStream  (id=20466)	
					connection	java.net.Socket  (id=20490)					/ de echte connectie	,
					encoding	org.postgresql.core.Encoding  (id=20491)	
					encodingWriter	java.io.OutputStreamWriter  (id=20492)	
					pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=20495)	
					pg_output	java.io.BufferedOutputStream  (id=20496)	

		currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20195) < formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a87b73:-7d13893:5aad2fab:39c5, node_name=1, branch_uid=0:ffffc0a87b73:-7d13893:5aad2fab:3dff, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >	
		isXA	true
		state 	STATE_ACTIVE

                return method.invoke(con, args);
method=public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int) throws java.sql.SQLException		
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 261

proxy=Pooled connection wrapping physical connection org.postgresql.jdbc42.Jdbc42Connection@5290c0a7
method=public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int) throws java.sql.SQLException
args=[insert into Language (name, version, id) values (?, ?, ?), 1003, 1007]

                else if (methodName.equals("prepareStatement"))
                {
                    Statement st = (Statement)method.invoke(con, args);
                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{PreparedStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).prepareStatement(java.lang.String, int, int) line: 282	
        return prepareStatement(sql, resultSetType, resultSetConcurrency, getHoldability());
/s,
org.postgresql.jdbc42.Jdbc42Connection.prepareStatement(java.lang.String, int, int, int) line: 40	
        return new Jdbc42PreparedStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement.<init>(org.postgresql.jdbc42.Jdbc42Connection, java.lang.String, int, int, int) line: 16	
        this(connection, sql, false, rsType, rsConcurrency, rsHoldability);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement.<init>(org.postgresql.jdbc42.Jdbc42Connection, java.lang.String, boolean, int, int, int) line: 21	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.Jdbc42Statement).<init>(org.postgresql.jdbc42.AbstractJdbc42Connection, java.lang.String, boolean, int, int, int) line: 31	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.AbstractJdbc42Statement).<init>(org.postgresql.jdbc42.AbstractJdbc42Connection, java.lang.String, boolean, int, int, int) line: 27	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc4.AbstractJdbc4Statement).<init>(org.postgresql.jdbc4.AbstractJdbc4Connection, java.lang.String, boolean, int, int, int) line: 33	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc3g.AbstractJdbc3gStatement).<init>(org.postgresql.jdbc3.AbstractJdbc3Connection, java.lang.String, boolean, int, int, int) line: 29	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc3.AbstractJdbc3Statement).<init>(org.postgresql.jdbc3.AbstractJdbc3Connection, java.lang.String, boolean, int, int, int) line: 49	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 193	
        this.connection = connection;
org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).borrowQuery(java.lang.String, boolean) line: 100	
        Object key = isCallable ? new CallableQueryKey(sql) : sql;
isCallable=false
        return statementCache.borrow(key);
		
this	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
	statementCache	org.postgresql.util.LruCache<Key,Value>  (id=20184)	
		cache	org.postgresql.util.LruCache$1  (id=20400)	
{select nextval ('hibernate_sequence')=org.postgresql.core.CachedQuery@1c07f5e9}

org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 193
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
/d,
cachedQuery	org.postgresql.core.CachedQuery  (id=20426)	
	key	"insert into Language (name, version, id) values (?, ?, ?)" (id=6435)	
	query	org.postgresql.core.v3.SimpleQuery  (id=20429)	
		nativeQuery	org.postgresql.core.NativeQuery  (id=20436)	
			nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=20443)	
		protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=20182)	

		forceBinaryTransfers |= connection.getForceBinary();
false
        resultsettype = rsType; / ResultSet.TYPE_FORWARD_ONLY
        concurrency = rsConcurrency; / ResultSet.CONCUR_READ_ONLY
        setFetchSize(connection.getDefaultFetchSize());
        setPrepareThreshold(connection.getPrepareThreshold());
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 347	
                    Statement st = (Statement)method.invoke(con, args);
/d,
st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=20395)	
	connection	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
	preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=20558)	
	preparedQuery	org.postgresql.core.CachedQuery  (id=20426)	
		key	"insert into Language (name, version, id) values (?, ?, ?)" (id=6435)	
		query	org.postgresql.core.v3.SimpleQuery  (id=20429)	
			nativeQuery	org.postgresql.core.NativeQuery  (id=20436)	
				nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=20443)	

                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{PreparedStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));
...
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);
/d,
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 743	
      else
      {
         return doPrepareStatement(sql, resultSetType, resultSetConcurrency);
/d,
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/pd,
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7.wrapPreparedStatement(java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 82	
/=
   protected WrappedPreparedStatement wrapPreparedStatement(PreparedStatement statement, boolean spy, String jndiName,
                                                            boolean doLocking)
statement	com.sun.proxy.$Proxy92  (id=20633)	
	h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=20613)	
		con	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler  (id=20173)	
		st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=20395)	/ hier zit de native query in,	
		this$0	org.postgresql.xa.PGXAConnection  (id=20172)	/ hier zit con in, maar ook currentXid en isXA,
jndiName	"java:jboss/datasources/PostgreSQLDS" (id=19959)	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7.wrapPreparedStatement(java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 82	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7.<init>(org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7, java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 51	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).<init>(org.jboss.jca.adapters.jdbc.WrappedConnection, java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 69	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).<init>(org.jboss.jca.adapters.jdbc.WrappedConnection, java.sql.PreparedStatement, boolean, java.lang.String, boolean, java.lang.String) line: 84	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).<init>(org.jboss.jca.adapters.jdbc.WrappedConnection, java.sql.Statement, boolean, java.lang.String, boolean, java.lang.String) line: 109	

      this.lc = lc;
      this.s = s; / Pooled statement wrapping physical statement insert into Language (name, version, id) values (?, ?, ?)
      this.spy = spy; / true
      this.jndiName = jndiName; / java:jboss/datasources/PostgreSQLDS
      this.doLocking = doLocking;
      this.spyLoggingCategory = spyLoggingCategory; / PreparedStatement
      this.timeoutSet = 0;

lc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=20145)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20158)	
		con	com.sun.proxy.$Proxy55  (id=20159)	
			h	org.postgresql.xa.PGXAConnection$ConnectionHandler  (id=20162)	
				this$0	org.postgresql.xa.PGXAConnection  (id=20172)	
					con	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
					currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20195)	
					isXA	true	
		currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20195)	
		xaConnection	org.postgresql.xa.PGXAConnection  (id=20172)	
			con	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
/ Moeten we voor de conn in de proxy kijken of in xaConnection?
/ TODO
      lc.registerStatement(this);
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/d,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 173	
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementStart();
					preparedStatement = doPrepare();
/d,
					setStatementTimeout( preparedStatement );
				}
				finally {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementEnd();
				}
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 78	
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/d,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).buildBatchStatement(java.lang.String, boolean) line: 136	
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/d,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 126	
			statement = buildBatchStatement( sql, callable );
/d,
			statements.put( sql, statement );
		return statement;
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2888	
			if ( useBatch ) {
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
/d,
				// Write the values of fields onto the prepared statement - we MUST use the state at the time the
				// insert was issued (cos of foreign key constraints). Not necessarily the object's current state

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2602	

/ Intermezzo

Thread [default task-70] (Suspended)	
	owns: java.lang.Object  (id=20132)	
	org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2602	
	org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2894
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/cb,	
	org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3397
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/cb,				
	org.hibernate.action.internal.EntityInsertAction.execute() line: 89	
		final boolean veto = preInsert();

		// Don't need to lock the cache here, since if someone
		// else inserted the same pk first, the insert would fail

		if ( !veto ) {
			
			persister.insert( id, getState(), instance, session );
/cb,
	org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 582
			for ( E e : list ) {
				try {
					e.execute();
/cb,					
	org.hibernate.engine.spi.ActionQueue.executeActions() line: 456	
		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
			ExecutableList<?> l = listProvider.get( this );
			if ( l != null && !l.isEmpty() ) {
				executeActions( l );
/cb,
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 337
			session.getJdbcCoordinator().flushBeginning();
			session.getPersistenceContext().setFlushing( true );
			// we need to lock the collection caches before executing entity inserts/updates in order to
			// account for bi-directional associations
			session.getActionQueue().prepareActions();
			session.getActionQueue().executeActions();		<-
/cb,	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39
		if ( persistenceContext.getNumberOfManagedEntities() > 0 ||
				persistenceContext.getCollectionEntries().size() > 0 ) {

			try {
				source.getEventListenerManager().flushStart();

				flushEverythingToExecutions( event );
				performExecutions( source );
/cb,
	org.hibernate.internal.SessionImpl.flush() line: 1282
		for ( FlushEventListener listener : listeners( EventType.FLUSH ) ) {
			listener.onFlush( flushEvent );
/cb,			
	org.hibernate.internal.SessionImpl.managedFlush() line: 465
		flush();
/cb,	
	org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963
			if ( flush ) {
				managedFlush();
/cb,				
	org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
		LOG.tracef( "SessionImpl#beforeTransactionCompletion()" );
		flushBeforeTransactionCompletion();
/cb,
	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485
		owner.beforeTransactionCompletion();
/cb,		
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
		try {
			transactionCoordinatorOwner.beforeTransactionCompletion();
/cb ,
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47
		log.trace( "Synchronization coordinator: beforeCompletion()" );

		if ( !target.isActive() ) {
			return;
		}
		target.beforeCompletion();
/cb,		
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37
		synchronizationCallbackCoordinator.beforeCompletion();
/cb,	
	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116
	
this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=20137)	
	jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=2487)	
		{TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:39c5 status: ActionStatus.ABORTING >=org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList@656b37b1}
	jcaSyncs	java.util.ArrayList<E>  (id=22542)	
		[org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer@9c790c6]
	preJcaSyncs	java.util.ArrayList<E>  (id=22536)
		[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@4a66b74d, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@13caba90, org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@7b5ab51c, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@76e48d88]
	tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20140)	
		TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:39c5 status: ActionStatus.ABORTING >

        // This is needed to guard against syncs being registered during the run, otherwise we could have used an iterator
        int lastIndexProcessed = 0;
        while ((lastIndexProcessed < preJcaSyncs.size())) {
		
            Synchronization preJcaSync = preJcaSyncs.get(lastIndexProcessed);
            if (TransactionLogger.ROOT_LOGGER.isTraceEnabled()) {
                TransactionLogger.ROOT_LOGGER.trace("JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: " + preJcaSync.getClass() + " HashCode: "
                    + preJcaSync.hashCode()
                    + " toString: "
                    + preJcaSync);
            }
            preJcaSync.beforeCompletion();				<-
            lastIndexProcessed = lastIndexProcessed + 1;
/cb,			
	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
		_theSynch.beforeCompletion();
/cb,
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
		                try
	                    {
	                        problem = !_currentRecord.beforeCompletion();
/cb,
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
        if(status() != ActionStatus.ABORT_ONLY || TxControl.isBeforeCompletionWhenRollbackOnly())
        {
            canEnd = beforeCompletion();				<-
        }

		if (canEnd)
		{
			outcome = super.End(report_heuristics);
		}
		else
			outcome = super.Abort();

		afterCompletion(outcome, report_heuristics);
/cb,		
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162
		int status = super.end(report_heuristics);
/cb,		
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
				switch (_theTransaction.commit(true))	
/cb,
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
			theTransaction.commitAndDisassociate();
/cb,
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
	            final int txStatus = tx.getStatus();
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();					<-
/cb,
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	
		for (int i = 0; i < MAX_RETRIES; i++) {
				tm.begin();
				Transaction tx = tm.getTransaction();
				try {
					return invocation.proceed();
				} catch (Throwable t) {
					handleExceptionInOurTx(invocation, t, tx, component);
				} finally {
					endTransaction(tm, tx);			<-	 , TODO
				}
/cb,			
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 344
        Transaction tx = tm.getTransaction();
        if (tx != null) {
/j,
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);	 <-
            } finally {
                tm.resume(tx);
            }
        } else {
            return invokeInOurTx(invocation, tm, component);
        }
/cb,

	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68
            case REQUIRES_NEW:
                return requiresNew(invocation, component, transactionTimeout);
/cb,	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 161	
			...
            final InterceptorContext interceptorContext = new InterceptorContext();
			...

		interceptorContext	org.jboss.invocation.InterceptorContext  (id=20098)	
			interceptors	org.jboss.invocation.Interceptor[17]  (id=3887)	
				[0]	org.jboss.invocation.PrivilegedWithCombinerInterceptor  (id=437)	
				[1]	org.jboss.invocation.ContextClassLoaderInterceptor  (id=436)	
				[2]	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor  (id=435)	
				[3]	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor  (id=434)	
				[4]	org.jboss.as.weld.injection.WeldInjectionContextInterceptor  (id=433)	
				[5]	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor  (id=432)	
				[6]	org.jboss.as.ee.component.NamespaceContextInterceptor  (id=431)	
				[7]	org.jboss.as.weld.ejb.Jsr299BindingsCreateInterceptor  (id=430)	
				[8]	org.jboss.as.weld.injection.WeldInterceptorInjectionInterceptor  (id=425)	
				[9]	org.jboss.as.ee.component.AroundConstructInterceptorFactory$1  (id=424)	
				[10]	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor  (id=423)	
				[11]	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor  (id=422)	
				[12]	org.jboss.as.weld.injection.WeldInjectionInterceptor  (id=421)	
				[13]	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor  (id=420)	
				[14]	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor  (id=418)	
				[15]	org.jboss.as.ee.component.ManagedReferenceLifecycleMethodInterceptor  (id=416)	
				[16]	org.jboss.invocation.TerminalInterceptor  (id=3892)	
/ deze interceptors zien we hierboven,
/cb,
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean) line: 134	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).createInstance() line: 88	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 64	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 61	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 56	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47
        PooledComponent<ComponentInstance> component = (PooledComponent<ComponentInstance>) getComponent(context, EJBComponent.class);
        ComponentInstance instance = component.getPool().get();
/cb,	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
            Transaction tx = tm.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:39c4 status: ActionStatus.ABORTED >
            try {
                return invocation.proceed(); 			<-
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
            }
        }
invocation	org.jboss.invocation.InterceptorContext  (id=20082)	
	method	java.lang.reflect.Method  (id=21368)	public java.util.List repository.LanguageDao.findLanguagesNatively()
/cb,		
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327
        final TransactionManager tm = component.getTransactionManager();

        if (timeout != -1) {
            tm.setTransactionTimeout(timeout);
        }

        final Transaction tx = tm.getTransaction();

        if (tx == null) {
/j,	tm.begin() moet nog,
            return invokeInOurTx(invocation, tm, component);				<-
        } else {
            return invokeInCallerTx(invocation, tx, component);
        }	
/cb,
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239
                case REQUIRED:
                    return required(invocation, component, timeoutInSeconds);


component	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=439)	
	applicationName	"test" (id=3951)	
	componentClass	java.lang.Class<T> (repository.LanguageDao) (id=306)	
	componentName	"LanguageDao" (id=21857)	
/cb,
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73
		...
        final InterceptorContext context = new InterceptorContext();
		...
context	org.jboss.invocation.InterceptorContext  (id=20082)	
	interceptors	org.jboss.invocation.Interceptor[14]  (id=21370)	
		[0]	org.jboss.invocation.PrivilegedWithCombinerInterceptor  (id=437)	
		[1]	org.jboss.invocation.AccessCheckingInterceptor  (id=2739)	
		[2]	org.jboss.invocation.ContextClassLoaderInterceptor  (id=2738)	
		[3]	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor  (id=2737)	
		[4]	org.jboss.as.ee.component.NamespaceContextInterceptor  (id=431)	
		[5]	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor  (id=2736)	
		[6]	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1  (id=2735)	
		[7]	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor  (id=2734)	
		[8]	org.jboss.as.ejb3.security.SecurityContextInterceptor  (id=20083)	
		[9]	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor  (id=446)	
		[10]	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor  (id=434)	
		[11]	org.jboss.as.ejb3.tx.CMTTxInterceptor  (id=445)	
		[12]	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor  (id=443)	
		[13]	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor  (id=21377)	
	method	java.lang.reflect.Method  (id=21368)	public java.util.List repository.LanguageDao.findLanguagesNatively()
	privateData	java.util.IdentityHashMap<K,V>  (id=21371)	
		table	java.lang.Object[16]  (id=21849)	
			[2]	java.lang.Class<T> (java.lang.Object) (id=170)	
			[3]	repository.LanguageDao$$$view4  (id=20087)	
			[4]	java.lang.Class<T> (org.jboss.as.ee.component.ComponentView) (id=2914)	
			[5]	org.jboss.as.ee.component.ViewService$View  (id=2741)	
			[6]	java.lang.Class<T> (org.jboss.as.ee.component.Component) (id=3061)	
			[7]	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=439)	
/cb,			
	repository.LanguageDao$$$view4.findLanguagesNatively() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.findLanguagesNatively() line: not available	
	repository.LanguageDaoTest.testLanguagesNatively() line: 84	
		List<Object[]>ls=languageDao.findLanguagesNatively();
this	repository.LanguageDaoTest  (id=20095)	
	languageDao	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$  (id=20094)	
/cb,	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748


/ Einde Intermezzo

/ we waren hier,
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2602	

		if ( LOG.isTraceEnabled() ) {
			LOG.tracev( "Dehydrating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
		}
		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i ) ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
fields	java.lang.Object[2]  (id=22610)	
	[0]	"Java" (id=482)	
	[1]	java.lang.Integer  (id=22725)	
includeColumns	(id=21059)	
	[0]	(id=21060)	
	[1]	(id=21061)	

this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=2690)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=6359)	
		propertyNames	java.lang.String[2]  (id=22653)	/ [name, version]
		propertyTypes	org.hibernate.type.Type[2]  (id=2697) [org.hibernate.type.StringType@5f0344a0, org.hibernate.type.IntegerType@4fea1377]
/s,
org.hibernate.type.StringType(org.hibernate.type.AbstractSingleColumnStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, boolean[], org.hibernate.engine.spi.SessionImplementor) line: 39	
		if ( settable[0] ) {
			nullSafeSet( st, value, index, session );
/s,
org.hibernate.type.StringType(org.hibernate.type.AbstractStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, org.hibernate.type.descriptor.WrapperOptions) line: 257	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
javaTypeDescriptor=org.hibernate.type.descriptor.sql.VarcharTypeDescriptor@66db596	
/s,
org.hibernate.type.StringType(org.hibernate.type.AbstractStandardBasicType<T>).remapSqlTypeDescriptor(org.hibernate.type.descriptor.WrapperOptions) line: 261	
		return options.remapSqlTypeDescriptor( sqlTypeDescriptor );
/s,
org.hibernate.internal.WrapperOptionsImpl.remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 44	
		final SqlTypeDescriptor remapped = sqlTypeDescriptor.canBeRemapped()
/j,
				? session.getFactory().getDialect().remapSqlTypeDescriptor( sqlTypeDescriptor )
				: sqlTypeDescriptor;
/s,
org.hibernate.dialect.PostgreSQLDialect(org.hibernate.dialect.Dialect).remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 454	
		final SqlTypeDescriptor overridden = getSqlTypeDescriptorOverride( sqlTypeDescriptor.getSqlType() );
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor.getSqlType() line: 33	
		return Types.VARCHAR;	/ java.sql.Types
/t,
/s,
org.hibernate.dialect.PostgreSQLDialect(org.hibernate.dialect.PostgreSQL81Dialect).getSqlTypeDescriptorOverride(int) line: 181	
			default: {
				descriptor = super.getSqlTypeDescriptorOverride( sqlCode );
/s,
	/**
	 * Returns the {@link SqlTypeDescriptor} that should be used to handle the given JDBC type code.  Returns
	 * {@code null} if there is no override.
	 *
	 * @param sqlCode A {@link Types} constant indicating the SQL column type
	 * @return The {@link SqlTypeDescriptor} to use as an override, or {@code null} if there is no override.
	 */

org.hibernate.dialect.PostgreSQLDialect(org.hibernate.dialect.Dialect).getSqlTypeDescriptorOverride(int) line: 480	
			default: {
				descriptor = null;
				break;
		}
		return descriptor;
/t,
org.hibernate.dialect.PostgreSQLDialect(org.hibernate.dialect.Dialect).remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 462	
		final SqlTypeDescriptor overridden = getSqlTypeDescriptorOverride( sqlTypeDescriptor.getSqlType() );
/d,
		return overridden == null ? sqlTypeDescriptor : overridden;
/t,
org.hibernate.internal.WrapperOptionsImpl.remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 46	
				? session.getFactory().getDialect().remapSqlTypeDescriptor( sqlTypeDescriptor )
/d,
				: sqlTypeDescriptor;
		return remapped == null ? sqlTypeDescriptor : remapped;
/t,
org.hibernate.type.StringType(org.hibernate.type.AbstractStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, org.hibernate.type.descriptor.WrapperOptions) line: 257	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/pd,
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor.getBinder(org.hibernate.type.descriptor.java.JavaTypeDescriptor<X>) line: 43	
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			...
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor$1(org.hibernate.type.descriptor.sql.BasicBinder<J>).<init>(org.hibernate.type.descriptor.java.JavaTypeDescriptor<J>, org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 46	
		this.javaDescriptor = javaDescriptor; / org.hibernate.type.descriptor.java.StringTypeDescriptor@4d8ff482
		this.sqlDescriptor = sqlDescriptor;/ org.hibernate.type.descriptor.sql.VarcharTypeDescriptor@66db596
/t,
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor$1(org.hibernate.type.descriptor.sql.BasicBinder<J>).bind(java.sql.PreparedStatement, J, int, org.hibernate.type.descriptor.WrapperOptions) line: 50	
/=
	public final void bind(PreparedStatement st, J value, int index, WrapperOptions options) throws SQLException {
this	org.hibernate.type.descriptor.sql.VarcharTypeDescriptor$1  (id=22771)	
st	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=20637)	
value	"Java" (id=482)	
index	1	

		else {
			if ( traceEnabled ) {
				log.trace(
						String.format(
								BIND_MSG_TEMPLATE,
								index,
								JdbcTypeNameMapper.getTypeName( sqlDescriptor.getSqlType() ),
								getJavaDescriptor().extractLoggableRepresentation( value )
						)
				);
			}
			doBind( st, value, index, options );
			
/ 7	. 

/ Er ging iets mis

/ we komen in een heel ander proces terecht	,

/s,
Daemon Thread [Transaction Reaper Worker 1] (Suspended (breakpoint at line 264 in org.postgresql.xa.PGXAConnection))
	org.postgresql.xa.PGXAConnection.end(javax.transaction.xa.Xid, int) line: 264	
        if (logger.logDebug())
			...
/cb,
	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.end(javax.transaction.xa.Xid, int) line: 295
this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20158)	
	xaConnection	org.postgresql.xa.PGXAConnection  (id=20172)	
	xaResource	org.postgresql.xa.PGXAConnection  (id=20172)	
xid	com.arjuna.ats.jta.xa.XidImple  (id=20195)	
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a87b73:-7d13893:5aad2fab:39c5, node_name=1, branch_uid=0:ffffc0a87b73:-7d13893:5aad2fab:3dff, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
            xaResource.end(xid, flags);	
/cb,
	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.end(javax.transaction.xa.Xid, int) line: 118
      xaResource.end(xid, flags);
/cb,	  
	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.topLevelAbort() line: 319	
				try
				{
					if (!_prepared)
					{
						if (endAssociation())
						{
							_theXAResource.end(_tranID, XAResource.TMFAIL);
/cb,
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).doAbort(boolean, com.arjuna.ats.arjuna.coordinator.AbstractRecord) line: 3017	
        if (recordBeingHandled != null)
XAResourceRecord < resource:XAResourceWrapperImpl@3d398011[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@690d8d40 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS], txid:< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a87b73:-7d13893:5aad2fab:39c5, node_name=1, branch_uid=0:ffffc0a87b73:-7d13893:5aad2fab:3dff, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >, heuristic: TwoPhaseOutcome.FINISH_OK, product: PostgreSQL/9.6.5, jndiName: java:jboss/datasources/PostgreSQLDS com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord@38b5cbc >
        {
            if (actionType == ActionType.TOP_LEVEL)
                ok = recordBeingHandled.topLevelAbort();
/cb,
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).doAbort(com.arjuna.ats.arjuna.coordinator.RecordList, boolean) line: 2996
            while ((recordBeingHandled = list_toprocess.getFront()) != null)
            {
                doAbort(reportHeuristics, recordBeingHandled);
/cb,	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Abort(boolean) line: 1672
        if (pendingList != null)
RecordList: 0:ffffc0a87b73:-7d13893:5aad2fab:3e0f
        {
            actionStatus = ActionStatus.ABORTING;

            while (pendingList.size() > 0)
                doAbort(pendingList, false); // turn off heuristics reporting
/cb,	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).cancel() line: 124
		int outcome = super.Abort(true);
/cb,		
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).cancel() line: 215
		int outcome = super.cancel();
/cb,	
	com.arjuna.ats.arjuna.coordinator.TransactionReaper.doCancellations() line: 381	
            try {
                if (e._control.running()) {
e=ReaperElement < BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:39c5 status: ActionStatus.ABORTING, 86400, ZOMBIE, Thread[Transaction Reaper Worker 1,5,main] >
                    // try to cancel the transaction, note that if the
                	// transaction previously failed to abort due to a 
                	// runtimeexception being raised by the AbstractRecord
                	// implementation then the transaction will effectively
                	// remain untouched and afterCompletion will not be called.

                    if (e._control.cancel() == ActionStatus.ABORTED) {
/cb,
	com.arjuna.ats.internal.arjuna.coordinator.ReaperWorkerThread.run() line: 78	
             _theReaper.doCancellations();

/ 7	. 
/c,
/ we komen weer in een ander proces,
/s,
Thread [Periodic Recovery] (Suspended (breakpoint at line 362 in org.jboss.jca.adapters.jdbc.xa.XAManagedConnection))
	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.recover(int) line: 362
      return xaResource.recover(flag);
/cb,	
	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.recover(int) line: 185
      return xaResource.recover(flag);
	  
this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22847)	
	xaResource	org.h2.jdbcx.JdbcXAConnection  (id=23136)	
		physicalConn	org.h2.jdbc.JdbcConnection  (id=23163)	conn4: url=jdbc:h2:tcp://localhost/~/h2/test user=SA
/cb,	  
	com.arjuna.ats.internal.jta.recovery.arjunacore.XARecoveryModule.xaRecoveryFirstPass(javax.transaction.xa.XAResource) line: 546
			Xid[] trans = null;

			try
			{
				trans = xares.recover(XAResource.TMSTARTRSCAN);
/cb,
	com.arjuna.ats.internal.jta.recovery.arjunacore.XARecoveryModule.periodicWorkFirstPass() line: 186
		for (XAResource xaResource : resources) {
resources=[
RecoveryOnlyEJBXAResource{receiverContext=EJBReceiverContext{clientContext=org.jboss.ejb.client.EJBClientContext@8a3db99, receiver=org.jboss.as.ejb3.remote.LocalEjbReceiver@6a5a6d97}, transactionOriginNodeIdentifier='1'},

XAResourceWrapperImpl@25030e3d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@7c16e73b pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS]
]
			try {
				xaRecoveryFirstPass(xaResource);
/cb,				
	com.arjuna.ats.internal.arjuna.recovery.PeriodicRecovery.doWorkInternal() line: 747	
        while (modules.hasMoreElements())
        {
            RecoveryModule m = (RecoveryModule) modules.nextElement();

            // we need to ensure we use the class loader context of the recovery module while we are executing
            // its methods

            ClassLoader cl = switchClassLoader(m);
            try {
            m.periodicWorkFirstPass(); 			<-
/cb,
	com.arjuna.ats.internal.arjuna.recovery.PeriodicRecovery.run() line: 375	
              doWorkInternal();

/ we gaan debug,
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.recover(int) line: 362	
      return xaResource.recover(flag);
/s,
org.h2.jdbcx.JdbcXAConnection.recover(int) line: 195	
            stat = physicalConn.createStatement();
            ResultSet rs = stat.executeQuery("SELECT * FROM INFORMATION_SCHEMA.IN_DOUBT ORDER BY TRANSACTION");
/s,
org.h2.jdbc.JdbcStatement.executeQuery(java.lang.String) line: 64	
                CommandInterface command = conn.prepareCommand(sql, fetchSize);
/s,
org.h2.jdbc.JdbcConnection.prepareCommand(java.lang.String, int) line: 1138	
        return session.prepareCommand(sql, fetchSize);
/s,
org.h2.engine.SessionRemote.prepareCommand(java.lang.String, int) line: 449	
        return new CommandRemote(this, transferList, sql, fetchSize);
		
/ zo doet H2 het dus, de socket zit in een transfer	, die in de session zit,
this	org.h2.engine.SessionRemote  (id=23204)	
	transferList	java.util.ArrayList<E>  (id=23217)	
		elementData	java.lang.Object[4]  (id=23230)	
			[0]	org.h2.value.Transfer  (id=23232)	
				in	java.io.DataInputStream  (id=23234)		/ input stream op socket
				out	java.io.DataOutputStream  (id=23236)	/ output stream op socket
				session	org.h2.engine.SessionRemote  (id=23204)	
				socket	java.net.Socket  (id=23237)	
				ssl	false	

/ Intermezzo

public class SessionRemote extends SessionWithState implements DataHandler {
    private void connectServer(ConnectionInfo ci) {
					...
                    Transfer trans = initTransfer(ci, databaseName, s);
                    transferList.add(trans);
					...

    private Transfer initTransfer(ConnectionInfo ci, String db, String server) throws IOException {
        Socket socket = NetUtils.createSocket(server, Constants.DEFAULT_TCP_PORT, ci.isSSL());
        Transfer trans = new Transfer(this);
        trans.setSocket(socket);
		...
		
/ er is ook,
   public SessionInterface connectEmbeddedOrServer(boolean openNew) {
/ TODO 
 

/ Einde Intermezzo

/s,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 45	
        prepare(session, true);
/s,

org.h2.command.CommandRemote.prepare(org.h2.engine.SessionRemote, boolean) line: 60	
                Transfer transfer = transferList.get(i);
                if (createParams) {
                    s.traceOperation("SESSION_PREPARE_READ_PARAMS", id);
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql);
/s,
org.h2.value.Transfer.writeInt(int) line: 142	
        out.writeInt(x); / dit is wat een data output stream kan : write primitives zoals int, char, ...
        return this;
		
/ Intermezzo

/ we zien wat we al dachten, de input/output stream  zijn op de socket,
    public synchronized void init() throws IOException {
        if (socket != null) {
            in = new DataInputStream(new BufferedInputStream(socket.getInputStream(), Transfer.BUFFER_SIZE));
            out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), Transfer.BUFFER_SIZE));
        }
    }	

/ zo worden strings write, char voor char,
class Transfer	
    public Transfer writeString(String s) throws IOException {
        if (s == null) {
            out.writeInt(-1);
        } else {
            int len = s.length();
            out.writeInt(len);
            for (int i = 0; i < len; i++) {
                out.writeChar(s.charAt(i));
            }
        }
        return this;
    }	

/ probeer String DataInputStream.readUTF, DataOutputStream.writeUTF(String)
/ TODO

/ Einde Intermezzo

/t,
org.h2.command.CommandRemote.prepare(org.h2.engine.SessionRemote, boolean) line: 65	
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql);
/d,
                s.done(transfer);
/s,
org.h2.engine.SessionRemote.done(org.h2.value.Transfer) line: 571	
        transfer.flush();
        int status = transfer.readInt();
        if (status == STATUS_ERROR) {
/n,
/t,
org.h2.command.CommandRemote.prepare(org.h2.engine.SessionRemote, boolean) line: 79	


                isQuery = transfer.readBoolean();
                readonly = transfer.readBoolean();
                int paramCount = transfer.readInt();
                if (createParams) {
                    parameters.clear();
                    for (int j = 0; j < paramCount; j++) {
/n,
                        ParameterRemote p = new ParameterRemote(j);
                        p.readMetaData(transfer);
                        parameters.add(p);
                    }
/t,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 48	
        prepare(session, true);
/d,
        // set session late because prepare might fail - in this case we don't
        // need to close the object
        this.session = session;
        this.fetchSize = fetchSize;
        created = session.getLastReconnect();
/t,
org.h2.jdbc.JdbcStatement.executeQuery(java.lang.String) line: 74	
                CommandInterface command = conn.prepareCommand(sql, fetchSize);
/d,
                boolean scrollable = resultSetType != ResultSet.TYPE_FORWARD_ONLY;
/n,
                boolean updatable = resultSetConcurrency == ResultSet.CONCUR_UPDATABLE;
/n,
                setExecutingStatement(command);
/s,
org.h2.jdbc.JdbcStatement.setExecutingStatement(org.h2.command.CommandInterface) line: 1028	
        } else {
            conn.setExecutingStatement(this);
            lastExecutedCommandType = c.getCommandType();
        }
        executingCommand = c;
/t,
org.h2.jdbc.JdbcStatement.executeQuery(java.lang.String) line: 74	
                 setExecutingStatement(command);
/d,
                try {
                    result = command.executeQuery(maxRows, scrollable);
/s,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 143	
        synchronized (session) {
            int objectId = session.getNextId();
            ResultRemote result = null;
            for (int i = 0, count = 0; i < transferList.size(); i++) {
                prepareIfRequired();
                Transfer transfer = transferList.get(i);
                try {
                    session.traceOperation("COMMAND_EXECUTE_QUERY", id);
                    transfer.writeInt(SessionRemote.COMMAND_EXECUTE_QUERY).writeInt(id).writeInt(objectId).writeInt(
                            maxRows);
                    } else {
                        fetch = fetchSize;
                    }
                    transfer.writeInt(fetch);
                    sendParameters(transfer);
                    session.done(transfer);	/=         transfer.flush();
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch);
/ TODO
/t,
org.h2.jdbc.JdbcStatement.executeQuery(java.lang.String) line: 83	
                    result = command.executeQuery(maxRows, scrollable);
                } finally {
                    setExecutingStatement(null);
                }
                command.close();
                resultSet = new JdbcResultSet(conn, this, result, id, closedByResultSet, scrollable, updatable);
/ TODO
            return resultSet;
/t,
org.h2.jdbcx.JdbcXAConnection.recover(int) line: 201	
            stat = physicalConn.createStatement();
            ResultSet rs = stat.executeQuery("SELECT * FROM INFORMATION_SCHEMA.IN_DOUBT ORDER BY TRANSACTION");
/d,
            ArrayList<Xid> list = New.arrayList();
            while (rs.next()) {
/n,
                String tid = rs.getString("TRANSACTION");
                int id = getNextId(XID);
                Xid xid = new JdbcXid(factory, id, tid);
                list.add(xid);
            }
            rs.close();
            Xid[] result = new Xid[list.size()];
            list.toArray(result);
            if (list.size() > 0) {
/n,
                prepared = true;
            }
            return result;
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.recover(int) line: 362	
      return xaResource.recover(flag);
/d,

/ 	7. 

/ c,
Daemon Thread [Transaction Reaper Worker 1] (Suspended (breakpoint at line 346 in org.jboss.jca.adapters.jdbc.xa.XAManagedConnection))	
	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.rollback(javax.transaction.xa.Xid) line: 346	
	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.rollback(javax.transaction.xa.Xid) line: 196
      xaResource.rollback(xid);
xid=< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a87b73:-7d13893:5aad2fab:39c5, node_name=1, branch_uid=0:ffffc0a87b73:-7d13893:5aad2fab:3dff, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
/cb,	  
	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.topLevelAbort() line: 369	
							_theXAResource.end(_tranID, XAResource.TMFAIL);
/ zonet	,
				try
				{
					_theXAResource.rollback(_tranID);			<-
				}
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).doAbort(boolean, com.arjuna.ats.arjuna.coordinator.AbstractRecord) line: 3017	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).doAbort(com.arjuna.ats.arjuna.coordinator.RecordList, boolean) line: 2996	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Abort(boolean) line: 1672	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).cancel() line: 124	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).cancel() line: 215	
	com.arjuna.ats.arjuna.coordinator.TransactionReaper.doCancellations() line: 381	
	com.arjuna.ats.internal.arjuna.coordinator.ReaperWorkerThread.run() line: 78	

/ we debug,
/s,
org.postgresql.xa.PGXAConnection.rollback(javax.transaction.xa.Xid) line: 409	
            if (currentXid != null && xid.equals(currentXid))
            {
                state = STATE_IDLE;
                currentXid = null;
                conn.rollback();
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).rollback() line: 868	
this	org.postgresql.jdbc42.Jdbc42Connection  (id=20174)	
	protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=20182)	
		pgStream	org.postgresql.core.PGStream  (id=20466)	
			connection	java.net.Socket  (id=20490)	
			pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=20495)	
			pg_output	java.io.BufferedOutputStream  (id=20496)	

        if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE)
            executeTransactionCommand(rollbackQuery);
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).executeTransactionCommand(org.postgresql.core.Query) line: 817	
        int flags = QueryExecutor.QUERY_NO_METADATA | QueryExecutor.QUERY_NO_RESULTS | QueryExecutor.QUERY_SUPPRESS_BEGIN;
        getQueryExecutor().execute(query, null, new TransactionCommandHandler(),
                                   0, 0, flags);
query=ROLLBACK
/ TODO		
			
			
			

	






/ Einde DEBUG CHAMELEON TEST IN WILDFLY

/ DEBUG TX

/ de 2de debugs wildfly, dus de test 	, en we moeten eerst  op de command line:
$ standalone.bat --debug
/ daarna in eclipse: 
aquillian-forge4-remote-wildfly	/ localhost 8787
/ daarna in forge:
$ build test

$ vi LanguageDaoTest.java
	@Test
	public void testInsertInTx() {
		languageDao.insertInTx();
		
	}
/ enigste test die er is,

$ vi LanguageDao.java
	public void insertInTx() {
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
		l=new Language();
		l.setName("Java");
		em1.persist(l);
		l=new Language();
		l.setName("Go");
		em.persist(l);
		l=new Language();
		l.setName("Go");
		em1.persist(l);
		l=new Language();
		l.setName("C++");
		em.persist(l);
		l=new Language();
		l.setName("C++");
		em1.persist(l);
	}
	
/s,
Thread [default task-43] (Suspended (breakpoint at line 272 in org.jboss.as.ejb3.tx.CMTTxInterceptor))	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
/cb,
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
        final TransactionManager tm = component.getTransactionManager();

        if (timeout != -1) {
            tm.setTransactionTimeout(timeout);
        }

        final Transaction tx = tm.getTransaction();

        if (tx == null) {
/j,
            return invokeInOurTx(invocation, tm, component);
/cb,
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
                case REQUIRED:
                    return required(invocation, component, timeoutInSeconds);
component	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=17644)	
/cb,
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73
context	org.jboss.invocation.InterceptorContext  (id=17149)	
	interceptors	org.jboss.invocation.Interceptor[14]  (id=17243)	
		[0]	org.jboss.invocation.PrivilegedWithCombinerInterceptor  (id=17160)	
		[1]	org.jboss.invocation.AccessCheckingInterceptor  (id=17159)	
		[2]	org.jboss.invocation.ContextClassLoaderInterceptor  (id=17158)	
		[3]	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor  (id=17157)	
		[4]	org.jboss.as.ee.component.NamespaceContextInterceptor  (id=17156)	
		[5]	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor  (id=17155)	
		[6]	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1  (id=17154)	
		[7]	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor  (id=17153)	
		[8]	org.jboss.as.ejb3.security.SecurityContextInterceptor  (id=17152)	
		[9]	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor  (id=17151)	
		[10]	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor  (id=17150)	
		[11]	org.jboss.as.ejb3.tx.CMTTxInterceptor  (id=17148)	
		[12]	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor  (id=17247)	
		[13]	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor  (id=17248)
	method	java.lang.reflect.Method  (id=17244)			
/cb,
	repository.LanguageDao$$$view5.insertInTx() line: not available	
/cb,
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
/cb,
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	

/ we zien 2 proxies,
repository.LanguageDao$$$view5.insertInTx() line: not available	
repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
/ TODO

/ lees,
http://docs.jboss.org/jbosstm/docs/4.2.2/javadoc/jts/constant-values.html#com.arjuna.ats.arjuna.ObjectStatus.ACTIVE

/ we gaan debug,
/s,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 272	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).begin() line: 78	
        transactionManager.begin() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 55	
		if (jtaLogger.logger.isTraceEnabled()) {
            jtaLogger.logger.trace("BaseTransaction.begin");
        }
/ TODO LOG
		    try
		    {
		        checkTransactionState();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).checkTransactionState() line: 253	
		// ok, no transaction currently associated with thread.

		TransactionImple theTransaction = TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1057	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
/s,
com.arjuna.ats.arjuna.coordinator.BasicAction.Current() line: 1256	
        return ThreadActionData.currentAction();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 57	
		Deque<BasicAction> txs = _threadList.get();
null	
/ Intermezzo
	private static ThreadLocal<Deque<BasicAction>> _threadList = new ThreadLocal<Deque<BasicAction>>();
/ Einde Intermezzo
		return null;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1060	
		final BasicAction current = BasicAction.Current();
		if (current != null)
/n,
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
			if (tx == null)
				tx = new TransactionImple(current);
		}

		return tx;
null
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).checkTransactionState() line: 256	
		TransactionImple theTransaction = TransactionImple.getTransaction();
null
		if (theTransaction == null)
			return;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 86	
		if (!_supportSubtransactions)
		{
		    try
		    {
		        checkTransactionState();
/d,
		Integer value = _timeouts.get();
null
		if (value != null)
/n,
		{
			v = value.intValue();
		}
		else
		    v = TxControl.getDefaultTimeout();
86400
/ Zelf opgegeven	, 
/ TODO Ga na,
		TransactionImple.putTransaction(new TransactionImple(v));
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 101	
		_theTransaction = new AtomicAction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction.<init>() line: 38
		super();	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).<init>() line: 74	
		super();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).<init>() line: 55	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).<init>() line: 72	
        super(ObjectType.NEITHER);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.StateManager).<init>(int) line: 801
        this(ot, ObjectModel.SINGLE);	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.StateManager).<init>(int, int) line: 805	
        objectModel = om; / ObjectModel.SINGLE
        currentStatus = (((objectModel == ObjectModel.SINGLE) && (ot == ObjectType.RECOVERABLE)) ? ObjectStatus.ACTIVE
                : ObjectStatus.PASSIVE_NEW); <-
        initialStatus = currentStatus; / ObjectStatus.PASSIVE_NEW
        myType = ot; / ObjectType.NEITHER

        objectUid = new Uid(); / 0:ffffc0a87b73:-7d13893:5aad2fab:754a

        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("StateManager::StateManager( " + ot + ", " + om + " )");
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).<init>() line: 72	
        super(ObjectType.NEITHER);
/d,
        pendingList = null;
        preparedList = null;
        readonlyList = null;
        failedList = null;
        heuristicList = null;

        currentHierarchy = null;
        transactionStore = null;
        savedIntentionList = false;

        actionStatus = ActionStatus.CREATED;
        actionType = ActionType.NESTED;

        parentAction = null;
        recordBeingHandled = null;

        heuristicDecision = TwoPhaseOutcome.PREPARE_OK;
		_checkedAction = arjPropertyManager
				.getCoordinatorEnvironmentBean().getCheckedActionFactory()
				.getCheckedAction(get_uid(), type());

        _childThreads = null;
        _childActions = null;
...
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 104	
		_theTransaction = new AtomicAction();
/d,
		_theTransaction.begin(timeout);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 116	
		int status = super.start();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).start() line: 65	
		return start(BasicAction.Current()); / BasicAction.Current()==null
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).start(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 76	
		if (parentAction != null)
/n,
		{
		    if (typeOfAction() == ActionType.NESTED)
			parentAction.addChildAction(this);
		}

		return super.Begin(parentAction);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Begin(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 1368	
        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("BasicAction::Begin() for action-id "
                    + get_uid());
        }
            else
            {
                actionInitialise(parentAct);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).actionInitialise(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 3515	
        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("BasicAction::actionInitialise() for action-id "
                    + get_uid());
        }

        if (parent != null) /* ie not top_level */
/n,
        else
        {
            currentHierarchy = new ActionHierarchy(
                    ActionHierarchy.DEFAULT_HIERARCHY_DEPTH); 	/ 1 diep	, geen hierarchy dus,
/s,
com.arjuna.ats.arjuna.coordinator.ActionHierarchy.<init>(int) line: 72	
	if (tsLogger.logger.isTraceEnabled()) {
        tsLogger.logger.trace("ActionHierarchy::ActionHierarchy(" + depth + ")");
    }

	hierarchy = null;
	maxHierarchyDepth = depth;
	currentDepth = 0;

	if (maxHierarchyDepth > 0)
	    hierarchy = new ActionInfo[maxHierarchyDepth];	/ 1
    }
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).actionInitialise(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 3541	
        else
        {
            currentHierarchy = new ActionHierarchy(
                    ActionHierarchy.DEFAULT_HIERARCHY_DEPTH);
/d,
            /*
                * This is a top-level atomic action so set the signal handler block
                * a number of signals.
                */
        }
        currentHierarchy.add(get_uid(), actionType);
		
this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17833)	
	currentHierarchy	com.arjuna.ats.arjuna.coordinator.ActionHierarchy  (id=17855)	
		DEFAULT_HIERARCHY_DEPTH	1	
		currentDepth	1	
		hierarchy	com.arjuna.ats.arjuna.coordinator.ActionInfo[1]  (id=17857)	
			[0]	com.arjuna.ats.arjuna.coordinator.ActionInfo  (id=17858)	
				actionType	1	
				actionUid	com.arjuna.ats.arjuna.common.Uid  (id=17859)	
		maxHierarchyDepth	1

        switch (actionType)
            case ActionType.NESTED:
                if (parent == null)
/j,
                    actionType = ActionType.TOP_LEVEL;
                break;		
        parentAction = parent; / null
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Begin(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 1392	
                actionInitialise(parentAct);
/d,					
                actionStatus = ActionStatus.RUNNING;	/ WAS: CREATED

				if ((actionType != ActionType.TOP_LEVEL)
/n,
                ActionManager.manager().put(this);
/s,
com.arjuna.ats.arjuna.coordinator.ActionManager.put(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 78	
		_allActions.put(act.get_uid(), new Lifetime(act)); / act=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.RUNNING
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Begin(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 1392	
                ActionManager.manager().put(this);
/d,
        return actionStatus;	/ RUNNING
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).start(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 76	
		return super.Begin(parentAction);
/d,
...
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 118	
		int status = super.start();	/ RUNNING
/d,
		if (status == ActionStatus.RUNNING)
		{
			/*
			 * Now do thread/action tracking.
			 */

			ThreadActionData.pushAction(this);/ this=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.RUNNING

			_timeout = timeout; / 86400
			
			if (_timeout == 0)
/n,
				_timeout = TxControl.getDefaultTimeout();

			if (_timeout > 0)
				TransactionReaper.transactionReaper().insert(this, _timeout);
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 109	
		_theTransaction.begin(timeout);
/d,
		_resources = new Hashtable();
		_duplicateResources = new Hashtable();
		_suspendCount = 0;
		_xaTransactionTimeoutEnabled = getXATransactionTimeoutEnabled(); / = 		return XA_TRANSACTION_TIMEOUT_ENABLED; /= true
        _txLocalResources = Collections.synchronizedMap(new HashMap());			
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 98	
		TransactionImple.putTransaction(new TransactionImple(v));
/pd,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTransaction(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple) line: 1578	
		_transactions.put(tx.get_uid(), tx);
/t,

/ Intermezzo

tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17832)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17833)	
	
/ we zien de AtomicAction in de TransactionImple	.
/ waarom is de TransactionImpl er?
/ TODO
	
/ Einde Intermezzo

...
/t,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 273	
            tm.begin();
/d,
            Transaction tx = tm.getTransaction();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
        return transactionManager.getTransaction() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
		return TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1060	
		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.RUNNING
/ de vorige keer was nog null,
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
			if (tx == null)
/n,
				tx = new TransactionImple(current);
		}
		return tx;
/= de TransactionImple waar current als _transaction in zit,
/t,
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();	<- naar de volgende interceptor,
           } finally {
                endTransaction(tm, tx);
/s,
org.jboss.invocation.InterceptorContext.proceed() line: 337	
this	org.jboss.invocation.InterceptorContext  (id=17149)	
	interceptorPosition	12	
	interceptors	org.jboss.invocation.Interceptor[14]  (id=17243)	
		[0]	org.jboss.invocation.PrivilegedWithCombinerInterceptor  (id=17160)	
		[1]	org.jboss.invocation.AccessCheckingInterceptor  (id=17159)	
		[2]	org.jboss.invocation.ContextClassLoaderInterceptor  (id=17158)	
		[3]	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor  (id=17157)	
		[4]	org.jboss.as.ee.component.NamespaceContextInterceptor  (id=17156)	
		[5]	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor  (id=17155)	
		[6]	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1  (id=17154)	
		[7]	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor  (id=17153)	
		[8]	org.jboss.as.ejb3.security.SecurityContextInterceptor  (id=17152)	
		[9]	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor  (id=17151)	
		[10]	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor  (id=17150)	
		[11]	org.jboss.as.ejb3.tx.CMTTxInterceptor  (id=17148)	
		[12]	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor  (id=17247)	
		[13]	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor  (id=17248)	
	method	java.lang.reflect.Method  (id=17244)	public void repository.LanguageDao.insertInTx()

	    if (interceptorPosition < interceptors.length) {
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
public class PooledInstanceInterceptor extends AbstractEJBInterceptor {
org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 46	
        PooledComponent<ComponentInstance> component = (PooledComponent<ComponentInstance>) getComponent(context, EJBComponent.class);
/s,
org.jboss.as.ejb3.component.interceptors.AbstractEJBInterceptor.getComponent(org.jboss.invocation.InterceptorContext, java.lang.Class<C>) line: 40	
        Component component = context.getPrivateData(Component.class);
component	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=17644)	
	componentClass	java.lang.Class<T> (repository.LanguageDao) (id=17071)	

        return componentType.cast(component);
/t,
public class PooledInstanceInterceptor extends AbstractEJBInterceptor {
org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 46	
        PooledComponent<ComponentInstance> component = (PooledComponent<ComponentInstance>) getComponent(context, EJBComponent.class);
/d,
        ComponentInstance instance = component.getPool().get();
/s,
org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 108	
        try {
            boolean acquired = semaphore.tryAcquire(timeout, timeUnit);
            ...

        T bean = pool.poll();	 / null

        if( bean !=null) {
            //we found a bean instance in the pool, return it
            return bean;
        }

        try {
            // Pool is empty, create an instance
            bean = create();
/s,
org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 56	
        T bean = factory.create();
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 61	
/=
        StatelessObjectFactory<StatelessSessionComponentInstance> factory = new StatelessObjectFactory<StatelessSessionComponentInstance>() {
            @Override
            public StatelessSessionComponentInstance create() {
                return (StatelessSessionComponentInstance) createInstance();	 <-
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).createInstance() line: 88	
        BasicComponentInstance instance = constructComponentInstance(null, true);
...
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 146	
        // create the component instance
        final BasicComponentInstance basicComponentInstance = this.instantiateComponentInstance(preDestroyInterceptor, interceptorInstanceMap, context);
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent.instantiateComponentInstance(org.jboss.invocation.Interceptor, java.util.Map<java.lang.reflect.Method,org.jboss.invocation.Interceptor>, java.util.Map<java.lang.Object,java.lang.Object>) line: 90	
        return new StatelessSessionComponentInstance(this, preDestroyInterceptor, methodInterceptors);
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance.<init>(org.jboss.as.ee.component.BasicComponent, org.jboss.invocation.Interceptor, java.util.Map<java.lang.reflect.Method,org.jboss.invocation.Interceptor>) line: 44	
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance(org.jboss.as.ejb3.component.session.SessionBeanComponentInstance).<init>(org.jboss.as.ee.component.BasicComponent, org.jboss.invocation.Interceptor, java.util.Map<java.lang.reflect.Method,org.jboss.invocation.Interceptor>) line: 47	
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance(org.jboss.as.ejb3.component.EjbComponentInstance).<init>(org.jboss.as.ee.component.BasicComponent, org.jboss.invocation.Interceptor, java.util.Map<java.lang.reflect.Method,org.jboss.invocation.Interceptor>) line: 45	
/s,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance(org.jboss.as.ee.component.BasicComponentInstance).<init>(org.jboss.as.ee.component.BasicComponent, org.jboss.invocation.Interceptor, java.util.Map<java.lang.reflect.Method,org.jboss.invocation.Interceptor>) line: 70	
        // Associated component
        this.component = component;	 / StatelessSessionComponent LanguageDao
        this.preDestroy = preDestroyInterceptor;
        this.methodMap = Collections.unmodifiableMap(methodInterceptors);
/t,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 152	
        final BasicComponentInstance basicComponentInstance = this.instantiateComponentInstance(preDestroyInterceptor, interceptorInstanceMap, context);
/d,
basicComponentInstance	org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance  (id=18464)	
	component	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=17644)
	methodMap	java.util.Collections$UnmodifiableMap<K,V>  (id=18499)	
{public void repository.LanguageDao.create(domain.Language)=org.jboss.invocation.ChainedInterceptor@7a778101, public boolean java.lang.Object.equals(java.lang.Object)=org.jboss.invocation.ChainedInterceptor@505ce1b3, public domain.Language repository.LanguageDao.findById(java.lang.Long)=org.jboss.invocation.ChainedInterceptor@d51f25c, public void repository.LanguageDao.deleteById(java.lang.Long)=org.jboss.invocation.ChainedInterceptor@235c2e23, public java.lang.String java.lang.Object.toString()=org.jboss.invocation.ChainedInterceptor@6565dcc0, public java.util.List repository.LanguageDao.listAll(java.lang.Integer,java.lang.Integer)=org.jboss.invocation.ChainedInterceptor@5283f8a6, public void repository.LanguageDao.insertInTx()=org.jboss.invocation.ChainedInterceptor@50c233b8, public java.util.List repository.LanguageDao.findLanguagesNatively()=org.jboss.invocation.ChainedInterceptor@122d22b5, public native int java.lang.Object.hashCode()=org.jboss.invocation.ChainedInterceptor@59e56fec, public java.util.List repository.LanguageDao.findLanguagesNatively2()=org.jboss.invocation.ChainedInterceptor@146efabe, public domain.Language repository.LanguageDao.update(domain.Language)=org.jboss.invocation.ChainedInterceptor@55705478, public java.util.List repository.LanguageDao.findLanguages()=org.jboss.invocation.ChainedInterceptor@2eb3ece9}

        if(instance != null) {
/n,
        if (invokePostConstruct) {
            // now invoke the postconstruct interceptors
            final InterceptorContext interceptorContext = new InterceptorContext();
            interceptorContext.putPrivateData(Component.class, this);
            interceptorContext.putPrivateData(ComponentInstance.class, basicComponentInstance);
            interceptorContext.putPrivateData(InvocationType.class, InvocationType.POST_CONSTRUCT);
            interceptorContext.setContextData(new HashMap<String, Object>());
			
interceptorContext	org.jboss.invocation.InterceptorContext  (id=18520)	
	interceptors	org.jboss.invocation.Interceptor[0]  (id=17239)	
/ heeft nog GEEN interceptors,

            try {
                postConstructInterceptor.processInvocation(interceptorContext);

this	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=17644)		
	postConstructInterceptor	org.jboss.invocation.ChainedInterceptor  (id=17676)	
		interceptors	org.jboss.invocation.Interceptor[16]  (id=18523)	
			[0]	org.jboss.invocation.PrivilegedWithCombinerInterceptor  (id=17160)	
			[1]	org.jboss.invocation.ContextClassLoaderInterceptor  (id=18524)	
			[2]	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor  (id=18525)	
			[3]	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor  (id=17150)	
			[4]	org.jboss.as.weld.injection.WeldInjectionContextInterceptor  (id=18526)	
			[5]	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor  (id=18527)	
			[6]	org.jboss.as.ee.component.NamespaceContextInterceptor  (id=17156)	
			[7]	org.jboss.as.weld.ejb.Jsr299BindingsCreateInterceptor  (id=18528)	
			[8]	org.jboss.as.weld.injection.WeldInterceptorInjectionInterceptor  (id=18529)	
			[9]	org.jboss.as.ee.component.AroundConstructInterceptorFactory$1  (id=18530)	
			[10]	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor  (id=18531)	
			[11]	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor  (id=18532)	
			[12]	org.jboss.as.weld.injection.WeldInjectionInterceptor  (id=18533)	
			[13]	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor  (id=18534)	
			[14]	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor  (id=18535)	
			[15]	org.jboss.invocation.TerminalInterceptor  (id=18536)
		method null

/ dus de post contstructor interceptor ( is een chain van interceptors) heeft geen method, want het is de post constructor interceptor,

/ hebben we daar nu mee te maken, want ik heb de @PostConstruct method uit comment	,
/ TODO
							
/s,
org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 57
/=
    public Object processInvocation(final InterceptorContext context) throws Exception {
        final int oldNext = context.getNextInterceptorIndex();	/ 0
        final Interceptor[] old = context.getInterceptors();	/ []
        context.setInterceptors(interceptors); / de post constructor interceptors,
        try {
            return context.proceed();
/s,
org.jboss.invocation.InterceptorContext.proceed() line: 338	
        if (interceptorPosition < interceptors.length) {
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
        } else {
            return context.run();
/s,
org.jboss.invocation.InterceptorContext.run() line: 356	
        return proceed();
/s,
org.jboss.invocation.InterceptorContext.proceed() line: 340	
        if (interceptorPosition < interceptors.length) {
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 59	

this	org.jboss.invocation.ContextClassLoaderInterceptor  (id=18524)	
	classLoader	org.jboss.modules.ModuleClassLoader  (id=19553)	ModuleClassLoader for Module "deployment.test.war:main" from Service Module Loader

        final ClassLoader old;
        Thread thread = Thread.currentThread();
        if (System.getSecurityManager() == null) {
/j,
            old = thread.getContextClassLoader();	/ this.classLoader==old	,
            thread.setContextClassLoader(classLoader);
        try {
            return context.proceed();

/ Intermezzo

/ we zitten nog steeds in  de semaphore,

org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
        ComponentInstance instance = component.getPool().get();
/s,
org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124	
        try {
            boolean acquired = semaphore.tryAcquire(timeout, timeUnit);
        try {
            // Pool is empty, create an instance
            bean = create();


/ Einde Intermezzo

/s,
org.jboss.invocation.InterceptorContext.proceed() line: 337	
        if (interceptorPosition < interceptors.length) {			/ 2
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
        ConcurrentContext.pushCurrent(concurrentContext);        
/s,
    /**
     * a thread local stack with the contexts pushed
     */
    private static final ThreadLocalStack<ConcurrentContext> current = new ThreadLocalStack<ConcurrentContext>();
		current.push(context);
/t,
org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
        ConcurrentContext.pushCurrent(concurrentContext);
/d,
        try {
            return context.proceed();
/s,
org.jboss.invocation.InterceptorContext.proceed() line: 337	
        if (interceptorPosition < interceptors.length) {
4
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 39	
        CurrentInvocationContext.push(context);
/s,
org.jboss.as.ejb3.context.CurrentInvocationContext.push(org.jboss.invocation.InterceptorContext) line: 58
        assert invocation != null : "invocation is null";	
        stack.push(invocation);
/t,
org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
        CurrentInvocationContext.push(context);
/d,
        try {
            return context.proceed();		
/s,
org.jboss.invocation.InterceptorContext.proceed() line: 337	
        if (interceptorPosition < interceptors.length) {
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 42	
        context.putPrivateData(WeldInjectionContext.class, weldComponentService.createInjectionContext());
/s,
org.jboss.as.weld.injection.WeldComponentService.createInjectionContext() line: 89	

        return new WeldInjectionContext(beanManager.createCreationalContext(bean), bean, delegateProduce, injectionTarget, interceptorInjections);
/ de WeldComponentService en de SessionBean waren er al,
/ TODO
this	org.jboss.as.weld.injection.WeldComponentService  (id=19683)	
	bean	org.jboss.weld.bean.SessionBean<T>  (id=19685)	
		annotatedType	org.jboss.weld.annotated.slim.backed.BackedAnnotatedType<X>  (id=19687)	
[BackedAnnotatedType] public @Stateless class repository.LanguageDao
		attributes	org.jboss.weld.bean.attributes.ImmutableBeanAttributes<T>  (id=19688)	
BeanAttributes with types [Object, LanguageDao] and qualifiers [@Any @Default]
		beanManager	org.jboss.weld.manager.BeanManagerImpl  (id=19689)
Weld BeanManager for test.war/WEB-INF/lib/de1836e3-7767-46ff-8ff3-eaf42e6c26cd.jar [bean count=32]		
		contextualInstanceStrategy	org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy<T>  (id=19691)	
		ejbDescriptor	org.jboss.weld.ejb.InternalEjbDescriptor<T>  (id=19692)	
		enhancedAnnotatedItem	null	
		identifier	org.jboss.weld.bean.StringBeanIdentifier  (id=19708)	
		initialized	true	
		preInitialized	false	
		producer	org.jboss.weld.injection.producer.ejb.SessionBeanInjectionTarget<T>  (id=19709)
InjectionTarget for Session bean [class repository.LanguageDao with qualifiers [@Any @Default]; local interfaces are [LanguageDao]		
		producer	null	
		proxyInstantiator	org.jboss.weld.injection.producer.ejb.SessionBeanProxyInstantiator<T>  (id=19710)	
		proxyRequired	false	
		qualifiers	com.google.common.collect.RegularImmutableSet<E>  (id=19711)	
		type	java.lang.Class<T> (repository.LanguageDao) (id=17071)	
/s,
org.jboss.weld.manager.BeanManagerImpl.createCreationalContext(javax.enterprise.context.spi.Contextual<T>) line: 1208	
        return new CreationalContextImpl<T>(contextual);
contextual	org.jboss.weld.bean.SessionBean<T>  (id=19685)	
...
/t,
org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
        context.putPrivateData(WeldInjectionContext.class, weldComponentService.createInjectionContext());
context	org.jboss.invocation.InterceptorContext  (id=18520)	
	privateData	java.util.IdentityHashMap<K,V>  (id=18522)	
		table	java.lang.Object[16]  (id=19507)
			[6]	java.lang.Class<T> (org.jboss.as.ee.component.Component) (id=10375)	
			[7]	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=17644)	
			[8]	java.lang.Class<T> (org.jboss.as.ee.component.ComponentInstance) (id=10255)	
			[9]	org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance  (id=18464)	
			[10]	java.lang.Class<T> (org.jboss.as.ee.component.interceptors.InvocationType) (id=10200)	
			[11]	org.jboss.as.ee.component.interceptors.InvocationType  (id=19512)		
			[12]	java.lang.Class<T> (org.jboss.as.weld.injection.WeldInjectionContext) (id=8203)	
			[13]	org.jboss.as.weld.injection.WeldInjectionContext  (id=20000)	
				bean	org.jboss.weld.bean.SessionBean<T>  (id=19685)	
				context	org.jboss.weld.context.CreationalContextImpl<T>  (id=19995)	
				delegateProduce	false	
				injectionTarget	org.jboss.weld.injection.producer.ejb.SessionBeanInjectionTarget<T>  (id=19709)	
				interceptorInjections	java.util.HashMap<K,V>  (id=19733)
				
		return context.proceed();	
/s,
org.jboss.invocation.InterceptorContext.proceed() line: 337	
        if (interceptorPosition < interceptors.length) {
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 56	
        switch (transactionAttributeType) 	/ is eig van deze LifecycleCMTTxInterceptor
            case REQUIRES_NEW:
                return requiresNew(invocation, component, transactionTimeout);
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 334	
        final TransactionManager tm = component.getTransactionManager();

        if (timeout != -1) {
/n,
            tm.setTransactionTimeout(timeout);
        }

        Transaction tx = tm.getTransaction();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
        return transactionManager.getTransaction() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
		return TransactionImple.getTransaction();		
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1062	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current(); / BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY
		if (current != null)
		{
			final Uid txid = current.get_uid(); / 0:ffffc0a87b73:-7d13893:5aad2fab:754a

			tx = (TransactionImple) _transactions.get(txid);
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY >
			if (tx == null)
/n,
				tx = new TransactionImple(current);
		}

		return tx;		
/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 341	
        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).suspend() line: 194	
        return transactionManager.suspend();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.suspend() line: 61	
		if (jtaLogger.logger.isTraceEnabled()) {
/n,
            jtaLogger.logger.trace("TransactionImpleManager.suspend");
        }

		try
		{
			TransactionImple tx = TransactionImple.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY >
			if (tx != null)
			{
				tx.getAtomicAction().suspend();
/s,
com.arjuna.ats.arjuna.AtomicAction.suspend() line: 329	
/=
	public static final AtomicAction suspend ()
/ TODO static	, waar is tx.getAtomicAction()	?
	{
		BasicAction curr = ThreadActionData.currentAction();
BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY	
		if (curr != null)
		{
			if (curr instanceof AtomicAction)
				ThreadActionData.purgeActions();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.purgeActions(java.lang.Thread, boolean) line: 231	
		Deque<BasicAction> txs = _threadList.get();
[BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY]
		_threadList.set(null);

		if (txs != null)
		{
			if (unregister)
			{
				while (!txs.isEmpty())
				{
					BasicAction act = txs.pop();
[]
					if (act != null)
                    {
						act.removeChildThread(ThreadUtil.getThreadId(t));
/ TODO
...
/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 344	
            tm.suspend();
/d,
            try {
                return invokeInOurTx(invocation, tm, component);
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 271	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).begin() line: 78	
        transactionManager.begin() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 68	
		if (jtaLogger.logger.isTraceEnabled()) {
            jtaLogger.logger.trace("BaseTransaction.begin");
        }
/ TODO LOG
		if (!_supportSubtransactions)
		{
		    try
		    {
		        checkTransactionState();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).checkTransactionState() line: 253	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
null
/ nu, want,	
/s,
com.arjuna.ats.arjuna.coordinator.BasicAction.Current() line: 1256	
        return ThreadActionData.currentAction();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 56	
		Deque<BasicAction> txs = _threadList.get();	/ _threadList is een ThreadLocal,
null
		return null;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1060	
		final BasicAction current = BasicAction.Current();
		if (current != null)
/n,
		return tx;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).checkTransactionState() line: 255	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/d,
null
		if (theTransaction == null)
			return;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 83	
		        checkTransactionState();
/d,
		else
		    v = TxControl.getDefaultTimeout();	/ 84600

		// TODO set default timeout

		TransactionImple.putTransaction(new TransactionImple(v));
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 102	
		_theTransaction = new AtomicAction();
...
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.StateManager).<init>(int, int) line: 812	
/=
    protected StateManager (int ot, int om)	/ ot=NEITHER, om=SINGLE
    {
        objectModel = om;
        currentStatus = (((objectModel == ObjectModel.SINGLE) && (ot == ObjectType.RECOVERABLE)) ? ObjectStatus.ACTIVE
                : ObjectStatus.PASSIVE_NEW);
        initialStatus = currentStatus;
        myType = ot;

        objectUid = new Uid();	/ 0:ffffc0a87b73:-7d13893:5aad2fab:754e
/ zonet hadden we 0:ffffc0a87b73:-7d13893:5aad2fab:754a
...
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 104	
		_theTransaction = new AtomicAction();
/d,
		_theTransaction.begin(timeout);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 116	
		int status = super.start();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).start() line: 65	
		return start(BasicAction.Current());	
/ this=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.CREATED
/ BasicAction.Current()==null,	heeft rol van parent TODO
/s,
	public int start (BasicAction parentAction)
	{
/ this=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.CREATED

		if (parentAction != null)
/n,
		{
		    if (typeOfAction() == ActionType.NESTED)
			parentAction.addChildAction(this);
		}

		return super.Begin(parentAction);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Begin(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 1391
/ this=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.CREATED	
	
            else
            {
                actionInitialise(parentAct);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).actionInitialise(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 3565	
            case ActionType.NESTED:
                if (parent == null)
/j,
                    actionType = ActionType.TOP_LEVEL;
                break;
        }

        parentAction = parent;
null
this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=20207)	BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.CREATED

                actionStatus = ActionStatus.RUNNING;
this BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.RUNNING

                ActionManager.manager().put(this);
/s,
com.arjuna.ats.arjuna.coordinator.ActionManager.put(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 78	
		_allActions.put(act.get_uid(), new Lifetime(act));
{0:ffffc0a87b73:-7d13893:5aad2fab:754e=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@64210b83, 0:ffffc0a87b73:-7d13893:5aad2fab:754a=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@433aa89d}

/t,
	return actionStatus;
...
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 118	
		int status = super.start();
/d,
		if (status == ActionStatus.RUNNING)
		{
			/*
			 * Now do thread/action tracking.
			 */

			ThreadActionData.pushAction(this);
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction, boolean) line: 82	
		Deque<BasicAction> txs = _threadList.get();
null
		if (txs == null)
		{
			txs = new ArrayDeque<BasicAction>();
			txs.push(a);

			_threadList.set(txs);
		}
		if (register)
                    a.addChildThread(Thread.currentThread());
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).begin(int) line: 126	
			ThreadActionData.pushAction(this);
/d,
/ Herinner	,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.currentAction() line: 56	
		Deque<BasicAction> txs = _threadList.get();	/ _threadList is een ThreadLocal,

			_timeout = timeout;	/ 86400

			if (_timeout == 0)
				_timeout = TxControl.getDefaultTimeout();

			if (_timeout > 0)
				TransactionReaper.transactionReaper().insert(this, _timeout);
		}
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.<init>(int) line: 104	
		_theTransaction = new AtomicAction();
		_theTransaction.begin(timeout);
/d,
		...
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).begin() line: 98	
		TransactionImple.putTransaction(new TransactionImple(v));
/ pd,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTransaction(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple) line: 1578	
		_transactions.put(tx.get_uid(), tx);
{0:ffffc0a87b73:-7d13893:5aad2fab:754e=TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.RUNNING >, 0:ffffc0a87b73:-7d13893:5aad2fab:754a=TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY >}

/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            Transaction tx = tm.getTransaction(); 
/d,
            try {
                return invocation.proceed();
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
        if (interceptorPosition < interceptors.length) {
            Interceptor next = interceptors[interceptorPosition++];
            try {
                return next.processInvocation(this);
/s,
org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 46	
        NamespaceContextSelector.pushCurrentSelector(selector);
        try {
            WritableServiceBasedNamingStore.pushOwner(deploymentUnitServiceName); / service jboss.deployment.unit."test.war"
            try {
                return context.proceed();
...
/s,
org.jboss.as.weld.ejb.Jsr299BindingsCreateInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 69	
        BeanManagerImpl beanManager = this.beanManager;
        if(beanManager == null) {
/j,
            //cache the BM lookup, as it is quite slow
           beanManager = this.beanManager = this.weldContainer.getValue().getBeanManager(beanArchiveId);
beanArchiveId="test.war/WEB-INF/lib/de1836e3-7767-46ff-8ff3-eaf42e6c26cd.jar"

this	org.jboss.msc.value.InjectedValue<T>  (id=20286)	
	valueUpdater	java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl<T,V>  (id=20265)	
	value	org.jboss.msc.value.ImmediateValue<T>  (id=20298)	
		value	org.jboss.as.weld.WeldBootstrapService  (id=20300)		<- this.weldContainer.getValue()
			NULL	org.jboss.msc.service.NullService  (id=18425)	
			NULL_VALUE	org.jboss.msc.value.ImmediateValue<T>  (id=18426)	
			SERVICE_NAME	org.jboss.msc.service.ServiceName  (id=20301)	
			beanDeploymentArchives	java.util.Collections$UnmodifiableMap<K,V>  (id=20302)	
			bootstrap	org.jboss.weld.bootstrap.WeldBootstrap  (id=20303)	
			deployment	org.jboss.as.weld.deployment.WeldDeployment  (id=20304)	
			deploymentName	"test.war" (id=17672)	
			environment	org.jboss.weld.bootstrap.api.Environments  (id=20305)	
			executorServices	org.jboss.msc.value.InjectedValue<T>  (id=20306)	
			rootBeanDeploymentArchive	org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl  (id=20307)	
			securityServices	org.jboss.msc.value.InjectedValue<T>  (id=20308)	
			serverExecutor	org.jboss.msc.value.InjectedValue<T>  (id=20309)	
			started	true	
			weldTransactionServices	org.jboss.msc.value.InjectedValue<T>  (id=20310)	
/s,
org.jboss.as.weld.WeldBootstrapService.getBeanManager(java.lang.String) line: 186	
        BeanDeploymentArchive beanDeploymentArchive = beanDeploymentArchives.get(beanArchiveId);
EXPLICIT BeanDeploymentArchive (test.war/WEB-INF/lib/de1836e3-7767-46ff-8ff3-eaf42e6c26cd.jar)
        return bootstrap.getManager(beanDeploymentArchive);
/s,
org.jboss.weld.bootstrap.WeldBootstrap.getManager(org.jboss.weld.bootstrap.spi.BeanDeploymentArchive) line: 106	
        return weldRuntime == null ? null : weldRuntime.getManager(beanDeploymentArchive);
/s,
org.jboss.weld.bootstrap.WeldRuntime.getManager(org.jboss.weld.bootstrap.spi.BeanDeploymentArchive) line: 49	
        BeanManagerImpl beanManager = bdaToBeanManagerMap.get(beanDeploymentArchive);
Weld BeanManager for test.war/WEB-INF/lib/de1836e3-7767-46ff-8ff3-eaf42e6c26cd.jar [bean count=32]

bdaToBeanManagerMap={SYNTHETIC BeanDeploymentArchive (org.hibernate.validator.cdi:main.additionalClasses)=Weld BeanManager for org.hibernate.validator.cdi:main.additionalClasses [bean count=30], IMPLICIT BeanDeploymentArchive (/C:/Users/ervelden/bin/wildfly-10.1.0.Final/bin/content/test.war/WEB-INF/lib/arquillian-protocol.jar)=Weld BeanManager for /C:/Users/ervelden/bin/wildfly-10.1.0.Final/bin/content/test.war/WEB-INF/lib/arquillian-protocol.jar [bean count=30], EXPLICIT BeanDeploymentArchive (test.war/WEB-INF/lib/de1836e3-7767-46ff-8ff3-eaf42e6c26cd.jar)=Weld BeanManager for test.war/WEB-INF/lib/de1836e3-7767-46ff-8ff3-eaf42e6c26cd.jar [bean count=32], EXPLICIT BeanDeploymentArchive (test.war)=Weld BeanManager for test.war [bean count=29], SYNTHETIC BeanDeploymentArchive (com.sun.jsf-impl:main.additionalClasses)=Weld BeanManager for com.sun.jsf-impl:main.additionalClasses [bean count=36], SYNTHETIC BeanDeploymentArchive (org.jboss.resteasy.resteasy-cdi:main.additionalClasses)=Weld BeanManager for org.jboss.resteasy.resteasy-cdi:main.additionalClasses [bean count=30], SYNTHETIC BeanDeploymentArchive (org.hibernate.validator:main.additionalClasses)=Weld BeanManager for org.hibernate.validator:main.additionalClasses [bean count=4], SYNTHETIC BeanDeploymentArchive (deployment.test.war:main.additionalClasses)=Weld BeanManager for deployment.test.war:main.additionalClasses [bean count=30], SYNTHETIC BeanDeploymentArchive (org.jberet.jberet-core:main.additionalClasses)=Weld BeanManager for org.jberet.jberet-core:main.additionalClasses [bean count=89], SYNTHETIC BeanDeploymentArchive (org.jboss.as.jsf:main.additionalClasses)=Weld BeanManager for org.jboss.as.jsf:main.additionalClasses [bean count=30]}

        return beanManager == null ? null : beanManager.getCurrent(); / return this; / beanManager dus,
/t,
org.jboss.as.weld.ejb.Jsr299BindingsCreateInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 76	
           beanManager = this.beanManager = this.weldContainer.getValue().getBeanManager(beanArchiveId);
/d,
        //this is not always called with the deployments TCCL set
        //which causes weld to blow up
        SessionBean<Object> bean = null;
        if (ejbName != null) {
            EjbDescriptor<Object> descriptor = beanManager.getEjbDescriptor(this.ejbName);
            if (descriptor != null) {
                bean = beanManager.getBean(descriptor);
/s,
org.jboss.weld.manager.BeanManagerImpl.getBean(org.jboss.weld.ejb.spi.EjbDescriptor<T>) line: 1246	
        return cast(getEnterpriseBeans().get(descriptor));
enterpriseBeans={org.jboss.as.weld.ejb.EjbDescriptorImpl@29b47ccb=Session bean [class repository.LanguageDao with qualifiers [@Any @Default]; local interfaces are [LanguageDao]}
/t,
org.jboss.as.weld.ejb.Jsr299BindingsCreateInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
                bean = beanManager.getBean(descriptor);
Session bean [class repository.LanguageDao with qualifiers [@Any @Default]; local interfaces are [LanguageDao]
/d,
        InterceptorBindings interceptorBindings = this.interceptorBindings.getValue();
null
        final ComponentInstance componentInstance = interceptorContext.getPrivateData(ComponentInstance.class);
org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance@5cdb6cdc
        WeldInterceptorInstances existing = (WeldInterceptorInstances) componentInstance.getInstanceData(SerializedCdiInterceptorsKey.class);
null
        if (existing == null) {
            CreationalContext<Object> creationalContext = beanManager.createCreationalContext(bean);
            HashMap<String, SerializableContextualInstance<Interceptor<Object>, Object>> interceptorInstances = new HashMap<String, SerializableContextualInstance<Interceptor<Object>, Object>>();

			if (interceptorBindings != null) {
/n,
			WeldInterceptorInstances instances = new WeldInterceptorInstances(creationalContext, interceptorInstances);
            componentInstance.setInstanceData(SerializedCdiInterceptorsKey.class, instances);
        }
        return interceptorContext.proceed();
/s,
org.jboss.as.weld.injection.WeldInterceptorInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
        WeldInjectionContext injectionContext = context.getPrivateData(WeldInjectionContext.class);
injectionContext	org.jboss.as.weld.injection.WeldInjectionContext  (id=20000)	
	bean	org.jboss.weld.bean.SessionBean<T>  (id=19685)	
	context	org.jboss.weld.context.CreationalContextImpl<T>  (id=19995)	
	delegateProduce	false	
	injectionTarget	org.jboss.weld.injection.producer.ejb.SessionBeanInjectionTarget<T>  (id=19709)	
	interceptorInjections	java.util.HashMap<K,V>  (id=19733)	

        final ComponentInstance componentInstance = context.getPrivateData(ComponentInstance.class);
componentInstance	org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance  (id=18464)	
	component	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent  (id=17644)	
	instanceData	java.util.HashMap<K,V>  (id=18465) 
{class org.jboss.as.ejb3.component.stateful.SerializedCdiInterceptorsKey=org.jboss.as.weld.ejb.WeldInterceptorInstances@7f976f75}	
	methodMap	java.util.Collections$UnmodifiableMap<K,V>  (id=18499)	

        //now inject the interceptors
        for (final Class<?> interceptorClass : interceptorClasses) {
            final ManagedReference instance = (ManagedReference) componentInstance.getInstanceData(interceptorClass);
            if (instance != null) {
                injectionContext.injectInterceptor(instance.getInstance());
            }
        }
        return context.proceed();
/s,
org.jboss.as.ee.component.AroundConstructInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 26	
                aroundConstruct.processInvocation(context);
/ TODO
                context.setParameters(null);
                return context.proceed();
/s,
org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 87	
            ComponentInstance componentInstance = context.getPrivateData(ComponentInstance.class);
org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance@5cdb6cdc
            Object target;
            if (Modifier.isStatic(field.getModifiers())) {
/n,
                target = null;
            } else {
                target = ((ManagedReference) componentInstance.getInstanceData(targetKey)).getInstance();
repository.LanguageDao@2f3b6d54

            final ManagedReference reference = factory.getReference(); / naar de EntityManager em,
factory=org.jboss.as.naming.deployment.ContextNames$BindInfo$1$1@2ca429e8
			...
            boolean ok = false;
            try {
                componentInstance.setInstanceData(valueContextKey, reference);
this	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor  (id=18531)	
	valueContextKey	java.lang.Object  (id=21237)
reference	org.jboss.as.naming.ImmediateManagedReference  (id=21231)	
	instance	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=21233)	

                field.set(target, reference.getInstance());
target=repository.LanguageDao@2f3b6d54
field=private javax.persistence.EntityManager repository.LanguageDao.em

                Object result = context.proceed();
/s,
org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 87

/ dezelfde interceptor nog een keer,
/ deze heeft een andere factory,

            ComponentInstance componentInstance = context.getPrivateData(ComponentInstance.class);
            Object target;
            if (Modifier.isStatic(field.getModifiers())) {
/n,
                target = null;
            } else {
                target = ((ManagedReference) componentInstance.getInstanceData(targetKey)).getInstance();
                if (target == null) {
                    throw EeLogger.ROOT_LOGGER.injectionTargetNotFound();
                }
            }
            final ManagedReference reference = factory.getReference();
factory=org.jboss.as.naming.deployment.ContextNames$BindInfo$1$1@73406249
reference	org.jboss.as.naming.ImmediateManagedReference  (id=21292)	
	instance	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=21293)	
		emf	org.hibernate.jpa.internal.EntityManagerFactoryImpl  (id=21307)	
		puScopedName	"test.war#arquillian-forge4-persistence-unit-1" (id=21308)	
		transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=17645)
/ TODO
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=17687)	
/ dit is de H2 pu,
            ...
            boolean ok = false;
            try {
                componentInstance.setInstanceData(valueContextKey, reference);
                field.set(target, reference.getInstance());
/ we zien de value niet in field,
/ TODO
                Object result = context.proceed();
/s,
org.jboss.as.weld.injection.WeldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 48	
        WeldInjectionContext injectionContext = context.getPrivateData(WeldInjectionContext.class);
        ManagedReference reference = (ManagedReference) context.getPrivateData(ComponentInstance.class).getInstanceData(BasicComponentInstance.INSTANCE_KEY);
reference	org.jboss.as.weld.injection.WeldManagedReferenceFactory$WeldManagedReference  (id=20895)	
	context	org.jboss.weld.context.CreationalContextImpl<T>  (id=19995)	
	instance	repository.LanguageDao  (id=20887)	

        if (reference != null) {
/j, 
/ nu wel,
            injectionContext.inject(reference.getInstance());
        return context.proceed();
/s,
org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
        return aroundInvoke(context.getInvocationContext());
/s,
org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
        if (isRequestContextActive()) {
            return invocation.proceed();
/s,
org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
            return InterceptorContext.this.proceed();
/s,
org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 88	
        final ComponentInstance componentInstance = context.getPrivateData(ComponentInstance.class);
        final WeldInterceptorInstances interceptorInstances = (WeldInterceptorInstances) componentInstance.getInstanceData(SerializedCdiInterceptorsKey.class);
        final InterceptorBindings interceptorBindings = this.interceptorBindings.getValue();
null
        switch (interceptionType) {
            case POST_CONSTRUCT:
/ HIER HIER HIER
                return doLifecycleInterception(context, interceptorInstances, interceptorBindings);
/s,
org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doLifecycleInterception(org.jboss.invocation.InterceptorContext, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 114	
        if (interceptorBindings == null) {
            return context.proceed();
/s,
org.jboss.invocation.TerminalInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 38	
        return null;
		
/ Intermezzo

/ we zijn in,

Thread [default task-43] (Suspended)	
	org.jboss.invocation.TerminalInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 38	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doLifecycleInterception(org.jboss.invocation.InterceptorContext, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 114	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 103	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.injection.WeldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 53	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 107	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 107	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.AroundConstructInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 28	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.injection.WeldInterceptorInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 56	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.ejb.Jsr299BindingsCreateInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
            }
/ voor het maken van de bean wordt een nieuwe tx create en ...
/ TODO 
/ de tm wordt suspend, en daarna begin, 
/ TODO
/cb,
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 344	
        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);
            } finally {
                tm.resume(tx);
            }
/ voor het maken van de bean wordt de huidige tx suspend en weer resumed	,
/cb,
	org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 161	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean) line: 134	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).createInstance() line: 88	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 64	
	org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 61	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 56
        T bean = factory.create();
/cb,	
	org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124
        try {
            // Pool is empty, create an instance
            bean = create();
/cb,			
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
        PooledComponent<ComponentInstance> component = (PooledComponent<ComponentInstance>) getComponent(context, EJBComponent.class);
        ComponentInstance instance = component.getPool().get();
/cb,
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view5.insertInTx() line: not available [local variables unavailable]	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	



/ Einde Intermezzo

/t,
org.jboss.invocation.InterceptorContext.proceed() line: 342	
            try {
                return next.processInvocation(this);	/ null
            } finally {
                interceptorPosition--;
...
/t,
org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 108	
                componentInstance.setInstanceData(valueContextKey, reference);
                field.set(target, reference.getInstance());
                Object result = context.proceed();
null
                ok = true;
                return result;
/t,
org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory$ManagedReferenceFieldInjectionInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 108	
                componentInstance.setInstanceData(valueContextKey, reference);
                field.set(target, reference.getInstance());
                Object result = context.proceed();
null
                ok = true;
                return result;
...
/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	

            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
/d,
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);  	<- nu,
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 85	
            if (tx != tm.getTransaction()) {
/n,
                throw EjbLogger.ROOT_LOGGER.wrongTxOnThread(tx, tm.getTransaction());
            }
/ TODO LOG
            final int txStatus = tx.getStatus();
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 115
		TransactionImple theTransaction = TransactionImple.getTransaction();
/ de tx om de current atomic action heen	,		
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.RUNNING
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.RUNNING >
		return tx;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/d,
		theTransaction.commitAndDisassociate();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1183	
				if (_theTransaction != null)	/ BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.RUNNING
					switch (_theTransaction.commit(true))
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
		int status = super.end(report_heuristics);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 89	
        if(status() != ActionStatus.ABORT_ONLY || TxControl.isBeforeCompletionWhenRollbackOnly())	/ RUNNING
/j,
            canEnd = beforeCompletion();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 310
/ NIETS, 
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 89	
		if (canEnd)
		{
			outcome = super.End(report_heuristics);	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).End(boolean) line: 1456	
        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("BasicAction::End() for action-id "
                    + get_uid());
        }
/ TODO LOG
        /* Check for superfluous invocation */

        if ((actionStatus != ActionStatus.RUNNING)
/n,
        /*
           * Check we are the current action. Abort parents if not true. Check we
           * have not children (threads or actions).
           */

        if (!checkIsCurrent() || checkChildren(true)
                || (actionStatus == ActionStatus.ABORT_ONLY))
/s,
    /**
     * Check to see if this transaction is the one that is current for this
     * thread. If it isn't, then we mark this transaction as rollback only.
     *
     * @return <code>true</code> if the transaction is current,
     *         <code>false</code> otherwise.
     */
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).checkIsCurrent() line: 3364	
        boolean isCurrent = true;

        if (checkForCurrent())	
/s,
    /**
     * Do we want to check that a transaction can only be terminated by a thread
     * that has it as its current transaction? The base class has this check
     * enabled (i.e., we check), but some implementations may wish to override
     * this.
     *
     * @return <code>false</code> to disable checking.
     */

    protected boolean checkForCurrent ()
    {
        return false;
    }
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).checkIsCurrent() line: 3364	
         if (checkForCurrent())
/n,
        return isCurrent;	/ true,
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).End(boolean) line: 1478	
        if (!checkIsCurrent() || checkChildren(true)
/pd,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).checkChildren(boolean) line: 3369	
       /*
           * If we have child threads then by default we just print a warning and
           * continue. The other threads will eventually find out the outcome.
           */

        if ((_childThreads != null) && (_childThreads.size() > 0))
        {
            if ((_childThreads.size() != 1)
                    || ((_childThreads.size() == 1) && (!_childThreads.contains(Thread.currentThread())))) {
                /*
                     * More than one thread or the one thread is not the current
                     * thread
                     */
/n,
        /* Ensure I have no child actions */

        if ((_childActions != null) && (_childActions.size() > 0))
/n,
        return problem;	/ false
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).End(boolean) line: 1478	
        if (!checkIsCurrent() || checkChildren(true)
/n,
                || (actionStatus == ActionStatus.ABORT_ONLY))
/ TODO Wanneer set?

/ als we in Eclipse op de class F3 (op extends class)	, dan kunnen we de jar kiezen in .m2/repository	, en download hij de source jar in .m2/repository,
/ TODO

/t,
        {
            return Abort();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Abort() line: 1613	
         return Abort(false);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).Abort(boolean) line: 1629	
        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("BasicAction::Abort() for action-id "
                    + get_uid());
        }
/ TODO LOG
		...
        ActionManager.manager().remove(get_uid());
/s,
com.arjuna.ats.arjuna.coordinator.ActionManager.remove(com.arjuna.ats.arjuna.common.Uid) line: 109	

_allActions={0:ffffc0a87b73:-7d13893:5aad2fab:754e=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@64210b83, 0:ffffc0a87b73:-7d13893:5aad2fab:754a=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@433aa89d}
id=0:ffffc0a87b73:-7d13893:5aad2fab:754e
		_allActions.remove(id);
_allActions={0:ffffc0a87b73:-7d13893:5aad2fab:754a=com.arjuna.ats.arjuna.coordinator.ActionManager$Lifetime@433aa89d}

        actionStatus = ActionStatus.ABORTED;
        return actionStatus;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 101	
		if (canEnd)
		{
			outcome = super.End(report_heuristics);
/d,
		afterCompletion(outcome, report_heuristics);
		return outcome;  / ActionStatus.ABORTED
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 168	
		int status = super.end(report_heuristics);
/d,
		/*
		 * Now remove this thread from the action state.
		 */

		ThreadActionData.popAction();
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction() line: 141
		return popAction(ThreadUtil.getThreadId(), true);
/s,
com.arjuna.ats.arjuna.utils.ThreadUtil.getThreadId() line: 43
	return getThreadId(Thread.currentThread()) ;	
/s,
com.arjuna.ats.arjuna.utils.ThreadUtil.getThreadId(java.lang.Thread) line: 53	
	final Object id = THREAD_ID.get() ;	/ THREAD_ID is een ThreadLocal,
TSThread:d
	if (id != null)
	{
	    return (String)id ;
...
/t,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction(java.lang.String, boolean) line: 164	
		return popAction(ThreadUtil.getThreadId(), true);
/pd,
/s,
	/**
	 * By setting the unregister flag accordingly, information about the thread
	 * is not removed from the action.
	 */
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction(java.lang.String, boolean) line: 164	
		Deque<BasicAction> txs = _threadList.get(); / _threadList is een ThreadLocal,
[BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.ABORTED]	

		if (txs != null)
		{
			BasicAction a = txs.pop();

			if (a != null && unregister) 	/ true,
			{
				a.removeChildThread(threadId);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).removeChildThread(java.lang.String) line: 649	
        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("BasicAction::removeChildThread () action "+get_uid()+" removing "+threadId);
        }
/ TODO LOG 
        synchronized (this)
        {
            if (_childThreads != null)	/ {TSThread:d=Thread[default task-43,5,main]}	, 
						/ dit is de current thread, die we zien in Eclipse's debugger	,
            {
                _childThreads.remove(threadId);
_childThreads={}
                result = true;
            }
        }
        return result; / true
/t,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.popAction(java.lang.String, boolean) line: 177	
			if (a != null && unregister)
			{
				a.removeChildThread(threadId);
/d,
			}

			if (txs.size() == 0)
/j,
			{
				_threadList.set(null);
			}

			return a;


		TransactionReaper.transactionReaper().remove(this);

		return status;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 170	
		ThreadActionData.popAction();
/d,
		TransactionReaper.transactionReaper().remove(this);		
/s,
com.arjuna.ats.arjuna.coordinator.TransactionReaper.remove(java.lang.Object) line: 575	
/=
    public final void remove(Object control) / control=	BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.ABORTED
        if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("TransactionReaper::remove ( " + control + " )");
        }
/ TODO LOG 
_timeouts={}
        ReaperElement key = _timeouts.get(control);
        if (key == null) {
            return;
        }		
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1212	
				switch (_theTransaction.commit(true))
					case ActionStatus.ABORTING:
                        RollbackException rollbackException = addSuppressedThrowables(new RollbackException( jtaLogger.i18NLogger.get_transaction_arjunacore_commitwhenaborted() ));
						
						throw rollbackException;
		finally
		{
			TransactionImple.removeTransaction(this);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.removeTransaction(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple) line: 1583

_transactions=
{0:ffffc0a87b73:-7d13893:5aad2fab:754e=TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.ABORTED >, 0:ffffc0a87b73:-7d13893:5aad2fab:754a=TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY >}	
tx=TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754e status: ActionStatus.ABORTED >

		_transactions.remove(tx.get_uid());

_transactions={0:ffffc0a87b73:-7d13893:5aad2fab:754a=TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY >}

/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 116	
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();
/d,
        } catch (RollbackException e) {
            handleEndTransactionException(e);
/s,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).handleEndTransactionException(java.lang.Exception) line: 137	
        if (e instanceof RollbackException)
            throw new EJBTransactionRolledbackException("Transaction rolled back", e);
/t,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 346	
        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);
/d,
            } finally {
                tm.resume(tx);
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).resume(javax.transaction.Transaction) line: 119	
        if (transaction == null) {
/n,
            suspend(); // This is what AtomicAction does
        } else {
            transactionManager.resume(transaction) ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.resume(javax.transaction.Transaction) line: 92	
		if (jtaLogger.logger.isTraceEnabled()) {
            jtaLogger.logger.trace("TransactionImpleManager.resume");
        }
/ TODO LOG 

		super.checkTransactionState();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).checkTransactionState() line: 253	
		// ok, no transaction currently associated with thread.

		TransactionImple theTransaction = TransactionImple.getTransaction();	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059
		TransactionImple tx = null;	
			final BasicAction current = BasicAction.Current();
null			
		return tx;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).checkTransactionState() line: 255	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/d,
null
		if (theTransaction == null)
			return;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.resume(javax.transaction.Transaction) line: 103	
		super.checkTransactionState();
/d,
		if ((which == null) || (which instanceof TransactionImple))
		{
		    TransactionImple theTransaction = (TransactionImple) which;
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY >

		    try
		    {
		        AtomicAction act = ((theTransaction == null) ? null : theTransaction.getAtomicAction());
		        if (!AtomicAction.resume(act))
/s,
com.arjuna.ats.arjuna.AtomicAction.resume(com.arjuna.ats.arjuna.AtomicAction) line: 366	
		if (act == null)
/n,
		{
			suspend(); // If you ever change this, you need to change the way resume is handled in /ArjunaJTS/integration/src/main/java/com/arjuna/ats/jbossatx/BaseTransactionManagerDelegate.java
		}
		else
			ThreadActionData.restoreActions(act);				
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.restoreActions(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 102	
		purgeActions();
/s,
	public static void purgeActions ()
	{
		purgeActions(Thread.currentThread(), true);
	}
/s,
	public static void purgeActions (Thread t, boolean unregister)
	{
		Deque<BasicAction> txs = _threadList.get();	/ null

		_threadList.set(null);
/ is _threadList {} of null	? 
/ TODO
/t,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.restoreActions(com.arjuna.ats.arjuna.coordinator.BasicAction) line: 102	
		purgeActions();
/d,
		if (act != null) / act=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY
		{
			/*
			 * First get the hierarchy from the bottom up.
			 */

			Deque<BasicAction> s = new ArrayDeque<BasicAction>();
			BasicAction nextLevel = act.parent();	/ null

			s.push(act);

			while (nextLevel != null)
/n,
			{
				s.push(nextLevel);

				nextLevel = nextLevel.parent();
			}
			try
			{
				while (!s.isEmpty())
				{
					pushAction(s.pop());
/s,
com.arjuna.ats.internal.arjuna.thread.ThreadActionData.pushAction(com.arjuna.ats.arjuna.coordinator.BasicAction, boolean) line: 80	
		Deque<BasicAction> txs = _threadList.get();
null
		if (txs == null)
		{
			txs = new ArrayDeque<BasicAction>();
			txs.push(a);	/ a=BasicAction: 0:ffffc0a87b73:-7d13893:5aad2fab:754a status: ActionStatus.ABORT_ONLY

			_threadList.set(txs);
		if (register)
                    a.addChildThread(Thread.currentThread());		
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).addChildThread(java.lang.Thread) line: 621	
            if (actionStatus <= ActionStatus.ABORTING)
/n, 
/ want ==
/ dan NIETS,
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.resume(javax.transaction.Transaction) line: 114	
		        if (!AtomicAction.resume(act))
/n,
		            throw new InvalidTransactionException();

		        theTransaction = null;		
/t,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).resume(javax.transaction.Transaction) line: 123	
            transactionManager.resume(transaction) ;
/d,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor(org.jboss.as.ejb3.tx.CMTTxInterceptor).requiresNew(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 346	
        Transaction tx = tm.getTransaction();
        if (tx != null) {
            tm.suspend();
            try {
                return invokeInOurTx(invocation, tm, component);
            } finally {
                tm.resume(tx);
/d,
org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 68	
            case REQUIRES_NEW:
                return requiresNew(invocation, component, transactionTimeout);
/d,
/t,
org.jboss.as.weld.injection.WeldInjectionContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
        context.putPrivateData(WeldInjectionContext.class, weldComponentService.createInjectionContext());
        return context.proceed();
/d,
/t,
org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
       CurrentInvocationContext.push(context);
        try {
            return context.proceed();
/d,
        } finally {
            CurrentInvocationContext.pop();
        }
/t,
org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
        ConcurrentContext.pushCurrent(concurrentContext);
        try {
            return context.proceed();
/d,
        } finally {
            ConcurrentContext.popCurrent();
/t,
org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
        if (System.getSecurityManager() == null) {
            old = thread.getContextClassLoader();
            thread.setContextClassLoader(classLoader);
      
        try {
            return context.proceed();
        } finally {
            if (System.getSecurityManager() == null) {
                thread.setContextClassLoader(old); / ModuleClassLoader for Module "deployment.test.war:main" from Service Module Loader
/d,
/t,
org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
        final Interceptor[] old = context.getInterceptors(); / []
        context.setInterceptors(interceptors); de nieuwe rij, met org.jboss.as.ejb3.tx.LifecycleCMTTxInterceptor@6652e89e	, 
        try {
            return context.proceed();
        } finally {
            context.setInterceptors(old, oldNext);           
/t,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent(org.jboss.as.ee.component.BasicComponent).constructComponentInstance(org.jboss.as.naming.ManagedReference, boolean, java.util.Map<java.lang.Object,java.lang.Object>) line: 161	
        final BasicComponentInstance basicComponentInstance = this.instantiateComponentInstance(preDestroyInterceptor, interceptorInstanceMap, context); / org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance@4aa9193c
        if (invokePostConstruct) {
            // now invoke the postconstruct interceptors
            final InterceptorContext interceptorContext = new InterceptorContext();
            interceptorContext.putPrivateData(Component.class, this);
            interceptorContext.putPrivateData(ComponentInstance.class, basicComponentInstance);
            interceptorContext.putPrivateData(InvocationType.class, InvocationType.POST_CONSTRUCT);
            interceptorContext.setContextData(new HashMap<String, Object>());

            try {
                postConstructInterceptor.processInvocation(interceptorContext); / interceptorContext.interceptors=[]	, die worden er WH door .processInvocation er in set, en aan het eind weer [] set	(dat zien we hier vlakboven)	,
/d,
        return basicComponentInstance; / / org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance@4aa9193c
...
/t,
org.jboss.as.ejb3.component.stateless.StatelessSessionComponent$1.create() line: 64	
        StatelessObjectFactory<StatelessSessionComponentInstance> factory = new StatelessObjectFactory<StatelessSessionComponentInstance>() {
            @Override
            public StatelessSessionComponentInstance create() {
                return (StatelessSessionComponentInstance) createInstance();
/d,
org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>(org.jboss.as.ejb3.pool.AbstractPool<T>).create() line: 58	
       T bean = factory.create();
/d,
        createCount.incrementAndGet();	 / 'n AtomicInteger	,

        return bean;
/t,
org.jboss.as.ejb3.pool.strictmax.StrictMaxPool<T>.get() line: 124	
        try {
            boolean acquired = semaphore.tryAcquire(timeout, timeUnit);
           
        try {
            // Pool is empty, create an instance
            bean = create();
/d,
        } finally {
            if (bean == null) {
/n,
                semaphore.release();
/ NIET	, TODO
            }
        }
        return bean;
    }
/t,
org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 48	
        PooledComponent<ComponentInstance> component = (PooledComponent<ComponentInstance>) getComponent(context, EJBComponent.class);
        ComponentInstance instance = component.getPool().get();
/d,
        context.putPrivateData(ComponentInstance.class, instance);
        boolean discarded = false;
        try {
            return context.proceed();
/ Hier gaat de stack weer omhoog	, we kwamen net van boven, toen de bean was created	,
/ er volgt nog 1 interceptor, org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor	, die de interceptor van de org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor calls, een ChainedInterceptor, die de interceptors vervangt (tijdelijk)	,
/s,
org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
        ComponentInstance componentInstance = context.getPrivateData(ComponentInstance.class);/org.jboss.as.ejb3.component.stateless.StatelessSessionComponentInstance@4aa9193c
        if (componentInstance == null) {
            throw EeLogger.ROOT_LOGGER.noComponentInstance();
        }
        Method oldMethod = context.getMethod();	/ public void repository.LanguageDao.insertInTx()
        try {
            context.setMethod(componentMethod);
            context.setTarget(componentInstance.getInstance()); / repository.LanguageDao@6bf1e545 TODO
            return componentInstance.getInterceptor(componentMethod).processInvocation(context);
/s,
org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
context	org.jboss.invocation.InterceptorContext  (id=17461)	
	interceptors	org.jboss.invocation.Interceptor[7]  (id=18570)	
		[0]	org.jboss.invocation.InitialInterceptor  (id=18562)	
		[1]	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor  (id=17619)	
		[2]	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor  (id=18561)	
		[3]	org.jboss.as.jpa.interceptor.SBInvocationInterceptor  (id=18560)	
		[4]	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor  (id=18559)	
		[5]	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1  (id=18558)	
		[6]	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor  (id=18556)	
	method	java.lang.reflect.Method  (id=18552)	
	target	repository.LanguageDao  (id=18493)	

        final int oldNext = context.getNextInterceptorIndex();
        final Interceptor[] old = context.getInterceptors();
old	org.jboss.invocation.Interceptor[14]  (id=18553)	
	[0]	org.jboss.invocation.PrivilegedWithCombinerInterceptor  (id=17472)	
	[1]	org.jboss.invocation.AccessCheckingInterceptor  (id=17471)	
	[2]	org.jboss.invocation.ContextClassLoaderInterceptor  (id=17470)	
	[3]	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor  (id=17469)	
	[4]	org.jboss.as.ee.component.NamespaceContextInterceptor  (id=17468)	
	[5]	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor  (id=17467)	
	[6]	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1  (id=17466)	
	[7]	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor  (id=17465)	
	[8]	org.jboss.as.ejb3.security.SecurityContextInterceptor  (id=17464)	
	[9]	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor  (id=17463)	
	[10]	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor  (id=17462)	
	[11]	org.jboss.as.ejb3.tx.CMTTxInterceptor  (id=17460)	
	[12]	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor  (id=17590)	
	[13]	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor  (id=18564)	

        context.setInterceptors(interceptors);
        try {
            return context.proceed();	
/s,
org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
        final Method method = context.getMethod();
        try {
            return context.proceed();
/s,
org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
        ConcurrentContext.pushCurrent(concurrentContext);
        try {
            return context.proceed();
/s,
org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
        return aroundInvoke(context.getInvocationContext());
/s,
org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
       if (isRequestContextActive()) {
            return invocation.proceed();
/s,
/**
 * Session bean Invocation interceptor.
 * Used for stateless session bean invocations to allow NonTxEmCloser to close the
 * underlying entity manager after a non-transactional invocation.
 *
 * @author Scott Marlow
 */
public class SBInvocationInterceptor implements Interceptor {

    public static final InterceptorFactory FACTORY = new ImmediateInterceptorFactory(new SBInvocationInterceptor());

    @Override
    public Object processInvocation(InterceptorContext context) throws Exception {

        NonTxEmCloser.pushCall();
        try {
            return context.proceed();   // call the next interceptor or target
/s,
org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
        final EJBComponent component = getComponent(context, EJBComponent.class); / StatelessSessionComponent LanguageDao
        if (!component.isStatisticsEnabled())
            return context.proceed();
/s,
org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
		} else {
                    return aroundInvoke.processInvocation(context);
/s,
org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
        final ComponentInstance componentInstance = context.getPrivateData(ComponentInstance.class);
        final WeldInterceptorInstances interceptorInstances = (WeldInterceptorInstances) 			componentInstance.getInstanceData(SerializedCdiInterceptorsKey.class);
        final InterceptorBindings interceptorBindings = this.interceptorBindings.getValue();	/ null
        switch (interceptionType) {
            case AROUND_INVOKE:
                return doMethodInterception(context.getInvocationContext(), InterceptionType.AROUND_INVOKE, interceptorInstances, interceptorBindings);
/s,
org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
        if (interceptorBindings != null) {
/n,
            List<Interceptor<?>> currentInterceptors = interceptorBindings.getMethodInterceptors(interceptionType, invocationContext.getMethod());
            return delegateInterception(invocationContext, interceptionType, currentInterceptors, interceptorInstances);
        } else {
/j,
            return invocationContext.proceed();
/s,
org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
        final ManagedReference reference = (ManagedReference) context.getPrivateData(ComponentInstance.class).getInstanceData(contextKey);
org.jboss.as.weld.injection.WeldManagedReferenceFactory$WeldManagedReference@49bde05c
        final Object instance = reference.getInstance();
repository.LanguageDao@6bf1e545
        try {
            return method.invoke(instance, context.getParameters());
/s,
repository.LanguageDao.insertInTx() line: 81	
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 575	
        long start = 0;
        if (isTraceEnabled)
/n,
/ TODO
            start = System.currentTimeMillis();
        try {
            transactionIsRequired();
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).transactionIsRequired() line: 876	
        if (!this.isExtendedPersistenceContext() && !this.isInTx()) {
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.isExtendedPersistenceContext() line: 100	
        return false;
/t,
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.isInTx() line: 105	
        return TransactionUtil.isInTx(transactionManager);	

this	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=17656)	
	transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=17484)	
		transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=17485)	
/s,
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 56	
        Transaction tx = getTransaction(transactionManager);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getTransaction(javax.transaction.TransactionManager) line: 93	
        try {
            return transactionManager.getTransaction();
/s
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
        return transactionManager.getTransaction() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
		return TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1057	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current(); / BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:92 status: ActionStatus.ABORT_ONLY
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid); / TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:92 status: ActionStatus.ABORT_ONLY >
			if (tx == null)
/n,
				tx = new TransactionImple(current);
		}
		return tx;
/t,
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 57	
        Transaction tx = getTransaction(transactionManager);
        if (tx == null || !TxUtils.isActive(tx))

/ Intermezzo

C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf modules\system\layers\base\org\hibernate\jipijapa-hibernate5\main\jipijapa-hibernate5-10.1.0.Final.jar | findstr TwoPhaseBoot
  1485 Thu Aug 18 19:07:54 CEST 2016 org/jboss/as/jpa/hibernate5/TwoPhaseBootstrapImpl.class
  
C:\Users\ervelden\bin\wildfly-10.1.0.Final>jar tvf  \Users\ervelden\.m2\repository\org\jboss\jboss-transaction-spi\7.3.0.Final\jboss-transaction-spi-7.3.0.Final.jar | findstr TxUtils
  6165 Tue Jul 21 16:03:58 CEST 2015 org/jboss/tm/TxUtils.class
  

/ Einde Intermezzo	

/s,
org.jboss.tm.TxUtils.isActive(javax.transaction.Transaction) line: 77	
      try
      {
         int status = tx.getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 353	
		int status = javax.transaction.Status.STATUS_NO_TRANSACTION;
		
		if (_theTransaction != null)
		{
			status = StatusConverter.convert(_theTransaction.status()); 
/ _theTransaction=BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:92 status: ActionStatus.ABORT_ONLY
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).status() line: 387	
        int s = ActionStatus.INVALID;

            s = actionStatus;		/ RUNNING
/t,
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 53	
		switch (status)
		{
		case ActionStatus.RUNNING:
			return javax.transaction.Status.STATUS_ACTIVE;
...
/t,
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 59	
        if (tx == null || !TxUtils.isActive(tx))
/n,
        return true;
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).transactionIsRequired() line: 879	
        if (!this.isExtendedPersistenceContext() && !this.isInTx()) 
/n,
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            transactionIsRequired();
/d,
            getEntityManager().persist(entity);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
        isInTx = TransactionUtil.isInTx(transactionManager);
true
        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/j,
        } else {
/n,
            entityManager = NonTxEmCloser.get(puScopedName);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 155	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getTransactionScopedEntityManager(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 69	
        return getEntityManagerInTransactionRegistry(puScopedName, tsr);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getEntityManagerInTransactionRegistry(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 116	
        return (EntityManager)tsr.getResource(scopedPuName);

tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=18861)	
	delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=18863)	
		tm	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18740)	
			transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=18742)	
/ TransactionManagerImple.getTransaction() calls static TransactionImple.getTransaction()

/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106	
        return delegate.getResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 125	
        if (jtaLogger.logger.isTraceEnabled()) {
            jtaLogger.logger.trace("TransactionSynchronizationRegistryImple.getResource");
        }
/ TODO LOG
        TransactionImple transactionImple = getTransactionImple();
        return transactionImple.getTxLocalResource(key);
/s,
static com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1059	
		final BasicAction current = BasicAction.Current();
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:2c0 status: ActionStatus.RUNNING >
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126	
        TransactionImple transactionImple = getTransactionImple();
/s,
		return transactionImple.getTxLocalResource(key);	/ je zegt dus op de trans-action: get trans-actional local resource,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);	/ _txLocalResources={}
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 156	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
        if (entityManager == null) {
            entityManager = createEntityManager(emf, properties, synchronizationType);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.createEntityManager(javax.persistence.EntityManagerFactory, java.util.Map, javax.persistence.SynchronizationType) line: 179	
        // only JPA 2.1 applications can specify UNSYNCHRONIZED.
        // Default is SYNCHRONIZED if synchronizationType is not passed to createEntityManager
        if (SynchronizationType.UNSYNCHRONIZED.equals(synchronizationType)) {
/n,
            // properties are allowed to be be null in jpa 2.1
            return unsynchronizedEntityManagerWrapper(emf.createEntityManager(synchronizationType, properties));
        }

        if (properties != null && properties.size() > 0) {
/n,
           return emf.createEntityManager(properties);
        }
        return emf.createEntityManager();
/s,
org.hibernate.jpa.internal.EntityManagerFactoryImpl.createEntityManager() line: 286		/ nog steeds jpa,
		return internalCreateEntityManager( SynchronizationType.SYNCHRONIZED, Collections.EMPTY_MAP ); / we zien synchronized,
/s,
org.hibernate.jpa.internal.EntityManagerFactoryImpl.internalCreateEntityManager(javax.persistence.SynchronizationType, java.util.Map) line: 319	

		//TODO support discardOnClose, persistencecontexttype?, interceptor,
		return new EntityManagerImpl(
				this,
				PersistenceContextType.EXTENDED,
				synchronizationType, / SYNCHRONIZED
				transactionType,	/ JTA
				discardOnClose,
				sessionInterceptorClass,
				map
		);
/s,
org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 58	
		super( entityManagerFactory, pcType, synchronizationType, transactionType, properties );
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.ejb.AbstractEntityManagerImpl).<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, java.util.Map) line: 32	
		super( entityManagerFactory, type, synchronizationType, transactionType, properties );
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, java.util.Map) line: 136	
	protected transient TransactionImpl tx = new TransactionImpl( this );
/s,
org.hibernate.jpa.internal.TransactionImpl.<init>(org.hibernate.jpa.spi.AbstractEntityManagerImpl) line: 32
/ is WH de local trans-action with in this case the db server; er is ook de global trans-action van arjuna,	
/ TODO
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, java.util.Map) line: 155	
		for ( String key : ENTITY_MANAGER_SPECIFIC_PROPERTIES ) {
[javax.persistence.lock.scope, javax.persistence.lock.timeout, org.hibernate.flushMode, javax.persistence.cache.retrieveMode, javax.persistence.cache.storeMode, javax.persistence.query.timeout]
			if ( entityManagerFactory.getProperties().containsKey( key ) ) {
/n,
				this.properties.put( key, entityManagerFactory.getProperties().get( key ) );
			}
			if ( properties != null && properties.containsKey( key ) ) {
/n,
				this.properties.put( key, properties.get( key ) );
			}
/t,
org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 83	
		super( entityManagerFactory, pcType, synchronizationType, transactionType, properties );
/d,
...
		postInit();
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
		// NOTE : pulse() already handles auto-join-ability correctly
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse();
/s,
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 115	
		if ( session == null ) {
			SessionBuilderImplementor sessionBuilder = internalGetEntityManagerFactory().getSessionFactory().withOptions();
this	org.hibernate.jpa.internal.EntityManagerImpl  (id=19662)	
	entityManagerFactory	org.hibernate.jpa.internal.EntityManagerFactoryImpl  (id=18988)	
		sessionFactory	org.hibernate.internal.SessionFactoryImpl  (id=19650)	
/s,
org.hibernate.internal.SessionFactoryImpl.withOptions() line: 702	
		return new SessionBuilderImpl( this );
/s,
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.<init>(org.hibernate.internal.SessionFactoryImpl) line: 1296	

			this.sessionFactory = sessionFactory;
			this.sessionOwner = null;
			final Settings settings = sessionFactory.settings;

			// set up default builder values...
			this.interceptor = sessionFactory.getInterceptor(); / org.hibernate.EmptyInterceptor@6b2dd70b
			this.statementInspector = sessionFactory.getSessionFactoryOptions().getStatementInspector();	/ null
			this.connectionReleaseMode = settings.getConnectionReleaseMode(); / AFTER_STATEMENT
			this.autoClose = settings.isAutoCloseSessionEnabled(); / false
			this.flushBeforeCompletion = settings.isFlushBeforeCompletionEnabled(); / false

			if ( sessionFactory.getCurrentTenantIdentifierResolver() != null ) {
/n,
				tenantIdentifier = sessionFactory.getCurrentTenantIdentifierResolver().resolveCurrentTenantIdentifier();
			}

			listeners = settings.getBaselineSessionEventsListenerBuilder().buildBaselineList(); / []
/t,
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 132	
		if ( session == null ) {
			SessionBuilderImplementor sessionBuilder = internalGetEntityManagerFactory().getSessionFactory().withOptions();
/d,
			sessionBuilder.owner( this );
			if (sessionInterceptorClass != null) {
/n,
			sessionBuilder.autoJoinTransactions( getSynchronizationType() == SynchronizationType.SYNCHRONIZED ); / true
			session = sessionBuilder.openSession();
/s,
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1318	
			log.tracef( "Opening Hibernate Session.  tenant=%s, owner=%s", tenantIdentifier, sessionOwner );
/ TODO LOG
			final SessionImpl session = new SessionImpl(
					connection,
					sessionFactory,
					sessionOwner,
					getTransactionCoordinator(),	/ null
					getJdbcCoordinator(),		/ null
					getTransaction(),	/ null
					getTransactionCompletionProcesses(),	/ null
					autoJoinTransactions,
					sessionFactory.settings.getRegionFactory().nextTimestamp(),
/s,
org.hibernate.cfg.Settings.getRegionFactory() line: 300	
	return sessionFactoryOptions.getServiceRegistry().getService( RegionFactory.class );
org.hibernate.cache.internal.NoCachingRegionFactory@c93adb
/t,
/s,
org.hibernate.cache.internal.NoCachingRegionFactory.nextTimestamp() line: 60	
		return System.currentTimeMillis() / 100;
/t,
					interceptor,
					statementInspector,
					flushBeforeCompletion,
					autoClose,
					connectionReleaseMode,
					tenantIdentifier
			);			
/s,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 190	
	private transient FlushMode flushMode = FlushMode.AUTO;
	private transient CacheMode cacheMode = CacheMode.NORMAL;			
		this.timestamp = timestamp;
		this.sessionOwner = sessionOwner; / org.hibernate.jpa.internal.EntityManagerImpl@8fbe3f9
		this.interceptor = interceptor == null ? EmptyInterceptor.INSTANCE : interceptor; / org.hibernate.EmptyInterceptor@6b2dd70b al,
		this.actionQueue = new ActionQueue( this );
/s,
org.hibernate.engine.spi.ActionQueue.<init>(org.hibernate.engine.spi.SessionImplementor) line: 219	
		this.session = session;
		isTransactionCoordinatorShared = false;
/t,
		this.persistenceContext = new StatefulPersistenceContext( this );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.<init>(org.hibernate.engine.spi.SessionImplementor) line: 148	
		this.session = session;

		entitiesByKey = new HashMap<EntityKey, Object>( INIT_COLL_SIZE );
		entitiesByUniqueKey = new HashMap<EntityUniqueKey, Object>( INIT_COLL_SIZE );
		//noinspection unchecked
		proxiesByKey = new ConcurrentReferenceHashMap<EntityKey, Object>( INIT_COLL_SIZE, .75f, 1, ConcurrentReferenceHashMap.ReferenceType.STRONG, ConcurrentReferenceHashMap.ReferenceType.WEAK, null );
		entitySnapshotsByKey = new HashMap<EntityKey, Object>( INIT_COLL_SIZE );

		entityEntryContext = new EntityEntryContext( this );
//		entityEntries = IdentityMap.instantiateSequenced( INIT_COLL_SIZE );
		collectionEntries = IdentityMap.instantiateSequenced( INIT_COLL_SIZE );
		parentsByChild = new IdentityHashMap<Object,Object>( INIT_COLL_SIZE );

		collectionsByKey = new HashMap<CollectionKey, PersistentCollection>( INIT_COLL_SIZE );
		arrayHolders = new IdentityHashMap<Object, PersistentCollection>( INIT_COLL_SIZE );

		nullifiableEntityKeys = new HashSet<EntityKey>();

		initTransientState();
/s,
	private void initTransientState() {
		nullAssociations = new HashSet<AssociationKey>( INIT_COLL_SIZE );
		nonlazyCollections = new ArrayList<PersistentCollection>( INIT_COLL_SIZE );
	}
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 249	
		this.persistenceContext = new StatefulPersistenceContext( this );
/d,
		this.autoCloseSessionEnabled = autoCloseSessionEnabled;	/ false
		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled; 	/ false

		initializeFromSessionOwner( sessionOwner );			
/s,
org.hibernate.internal.SessionImpl.initializeFromSessionOwner(org.hibernate.engine.spi.SessionOwner) line: 375	
		if ( sessionOwner != null ) {
			if ( sessionOwner.getExceptionMapper() != null ) {
/j,
				exceptionMapper = sessionOwner.getExceptionMapper();
			}
			else {
				exceptionMapper = STANDARD_EXCEPTION_MAPPER;
			}
			if ( sessionOwner.getAfterCompletionAction() != null ) {
/j,
				afterCompletionAction = sessionOwner.getAfterCompletionAction();
			}
			else {
				afterCompletionAction = STANDARD_AFTER_COMPLETION_ACTION;
			}
			if ( sessionOwner.getManagedFlushChecker() != null ) {
/j,
				managedFlushChecker = sessionOwner.getManagedFlushChecker();
			}
			else {
				managedFlushChecker = STANDARD_MANAGED_FLUSH_CHECKER;
			}
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 266	
		initializeFromSessionOwner( sessionOwner );
/d,
		this.jdbcSessionContext = new JdbcSessionContextImpl( factory, this.statementInspector );
/s,
org.hibernate.internal.AbstractSessionImpl$JdbcSessionContextImpl.<init>(org.hibernate.internal.AbstractSessionImpl, org.hibernate.internal.SessionFactoryImpl, org.hibernate.resource.jdbc.spi.StatementInspector) line: 463	
			this.sessionFactory = sessionFactory;
			this.inspector = inspector;
			this.serviceRegistry = sessionFactory.getServiceRegistry();
			this.jdbcObserver = new JdbcObserverImpl();
/ TODO
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 269	
		this.jdbcSessionContext = new JdbcSessionContextImpl( factory, this.statementInspector );
/d,
		if ( transactionCoordinator == null ) {
			this.isTransactionCoordinatorShared = false;
			this.connectionReleaseMode = connectionReleaseMode;	/ AFTER_STATEMENT
			this.autoJoinTransactions = autoJoinTransactions;	/ true

			this.jdbcCoordinator = new JdbcCoordinatorImpl( connection, this );
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.<init>(java.sql.Connection, org.hibernate.resource.jdbc.spi.JdbcSessionOwner) line: 106	
		else {
			this.logicalConnection = new LogicalConnectionManagedImpl(
					owner.getJdbcConnectionAccess(),
					owner.getJdbcSessionContext()
			);
		...
/ TODO
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 274	
			this.jdbcCoordinator = new JdbcCoordinatorImpl( connection, this );
/d,	
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(
					this.jdbcCoordinator,
					this
			);
/s,
	return sessionFactoryOptions.getServiceRegistry().getService( ... );
/ TODO
/t,
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 25	
		return new JtaTransactionCoordinatorImpl(
				this,
				owner,
				options.shouldAutoJoinTransaction()	/ true
		);
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 77	

	private final SynchronizationRegistryStandardImpl synchronizationRegistry = new SynchronizationRegistryStandardImpl();
	private int timeOut = -1;
		this.observers = new ArrayList<TransactionObserver>();
		this.transactionCoordinatorBuilder = transactionCoordinatorBuilder;
		this.transactionCoordinatorOwner = owner;	/ org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl@7f0a5952
		this.autoJoinTransactions = autoJoinTransactions;	/ true

		final JdbcSessionContext jdbcSessionContext = owner.getJdbcSessionOwner().getJdbcSessionContext();
org.hibernate.internal.AbstractSessionImpl$JdbcSessionContextImpl@3c61706e

		this.jtaPlatform = jdbcSessionContext.getServiceRegistry().getService( JtaPlatform.class );
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform@7a7892ec

/ Intermezzo

/ lees,
https://blog.akquinet.de/2016/05/18/red-hat-jboss-enterprise-application-platform-7-jboss-eap-7-final-release/
The Jipijapa project is an abstraction layer that allows the integration of different JPA persistence providers. JBoss EAP 7 comes with the following Jipijapa abstraction layer:

Hibernate 5, 4.3 and 4.1
OpenJPA
EclipseLink
Other JPA persistence providers or your own JPA implementation can be integrated via the Jipijapa SPI.

/ org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform is ook in de jipijapa-hibernate5-10.1.0.Final-sources.jar

/ Einde Intermezzo

		final SessionFactoryOptions sessionFactoryOptions = jdbcSessionContext.getSessionFactory().getSessionFactoryOptions();
		this.preferUserTransactions = sessionFactoryOptions.isPreferUserTransaction();
		this.performJtaThreadTracking = sessionFactoryOptions.isJtaTrackByThread();

		synchronizationRegistered = false;

		pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 132	
		if ( !autoJoinTransactions ) {
/n,
			return;
		}		
		if ( synchronizationRegistered ) {
/n,
			return;
		}
		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform(org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform).canRegisterSynchronization() line: 131	
		return getSynchronizationStrategy().canRegisterSynchronization();
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform.getSynchronizationStrategy()
/=
    @Override
    protected JtaSynchronizationStrategy getSynchronizationStrategy() {
        return synchronizationStrategy;
    }
/t,	
/s,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.canRegisterSynchronization() line: 36	
		final TransactionSynchronizationRegistry registry = synchronizationRegistryAccess.getSynchronizationRegistry();
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1.getSynchronizationRegistry() line: 47	
/=
    public JBossAppServerJtaPlatform(final JtaManager jtaManager) {
        this.jtaManager = jtaManager;
        this.synchronizationStrategy = new SynchronizationRegistryBasedSynchronizationStrategy(new SynchronizationRegistryAccess() {
            @Override
            public TransactionSynchronizationRegistry getSynchronizationRegistry() {
                return jtaManager.getSynchronizationRegistry();										<-
            }
        });		
this	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1  (id=19833)	
	val$jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=19837)	
		transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18740)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=18861)	
/t,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.canRegisterSynchronization() line: 37	
		final TransactionSynchronizationRegistry registry = synchronizationRegistryAccess.getSynchronizationRegistry();
/d,
registry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=18861)	
	delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=18863)	
		tm	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18740)	

		return JtaStatusHelper.isActive( registry.getTransactionStatus() ) && ! registry.getRollbackOnly();
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionStatus() line: 91	
        return delegate.getTransactionStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionStatus() line: 157	
            return tm.getStatus();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
        return transactionManager.getStatus() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
		TransactionImple theTransaction = TransactionImple.getTransaction();	
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1069	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
		return tx;
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:2c0 status: ActionStatus.RUNNING >		
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 169	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/d,
		if (theTransaction == null)
/n,
			return javax.transaction.Status.STATUS_NO_TRANSACTION;
		else
			return theTransaction.getStatus();
...
/t,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.canRegisterSynchronization() line: 37	
		return JtaStatusHelper.isActive( registry.getTransactionStatus() ) && ! registry.getRollbackOnly();
/pd,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getRollbackOnly() line: 205	
        try
        {
            return (transactionImple.getStatus() == Status.STATUS_MARKED_ROLLBACK);
...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 146	
		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
/n,
			log.trace( "JTA platform says we cannot currently resister synchronization; skipping" );
			return;
		}

		joinJtaTransaction();
/s,
	/**
	 * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the
	 * RegisteredSynchronization with the JTA system
	 */
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158	

/ Intermezzo

/ lees,
https://en.wikipedia.org/wiki/Java_Transaction_API
The Java Transaction API (JTA), one of the Java Enterprise Edition (Java EE) APIs, enables distributed transactions to be done across multiple X/Open XA resources in a Java environment. JTA is a specification developed under the Java Community Process as JSR 907.

/ lees,
http://www.ejbtutorial.com/corba/tutorial-for-corba-hello-world-using-java

/ Einde Intermezzo



		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.getSynchronizationCallbackCoordinator() line: 122	
		if ( callbackCoordinator == null ) {
/j,
			callbackCoordinator = performJtaThreadTracking
/j,
					? new SynchronizationCallbackCoordinatorTrackingImpl( this ) 
/ this=org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl@164e45b6
					: new SynchronizationCallbackCoordinatorNonTrackingImpl( this );
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl.<init>(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackTarget) line: 30	
		// super ctor calls reset() followed by pulse()
		super( target ); / target=org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl@164e45b6
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158	
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/pd,
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform(org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform).registerSynchronization(javax.transaction.Synchronization) line: 126	
		getSynchronizationStrategy().registerSynchronization( synchronization );
		
synchronization	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=19870)	
	synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=19867)	
		delayedCompletionHandling	false	
		target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19803)	
			jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=19817)	
			synchronizationRegistry	org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl  (id=19806)	

/s,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29	
		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
				synchronization
		);			
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1.getSynchronizationRegistry() line: 47	
/=
    public JBossAppServerJtaPlatform(final JtaManager jtaManager) {
        this.jtaManager = jtaManager;
        this.synchronizationStrategy = new SynchronizationRegistryBasedSynchronizationStrategy(new SynchronizationRegistryAccess() {
            @Override
            public TransactionSynchronizationRegistry getSynchronizationRegistry() {
                return jtaManager.getSynchronizationRegistry();	<- /= return transactionSynchronizationRegistry;
/t,
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 68
/=
    public void registerInterposedSynchronization(Synchronization sync)

/ sync is local tx, 	
sync	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=19870)	
	synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=19867)	
		target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19803)	
			synchronizationRegistry	org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl  (id=19806)	
			transactionCoordinatorOwner	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=19770)	
				logicalConnection	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl  (id=19794)	
					physicalConnection	null	
				owner	org.hibernate.internal.SessionImpl  (id=19729)	


/ Intermezzo

/ tsr

/ lees,
/ https://help.sap.com/doc/saphelp_me150/15.0.3VERSIONFORSAPME/fr-FR/58/4fffb090a7463ea35cc6386a3e6d85/frameset.htm

The TransactionSynchronizationRegistry is an interface that is part of the Java Transaction API (JTA) implementation. It is designed to provide Enterprise Java Beans (EJBs), Web application components, persistence managers, and resource adapters with the abilities to associate resources with ongoing transactions, to register synchronization objects according to specific ordering semantics, to obtain the transaction context and status of ongoing transactions, and to mark these transactions for rollback.

The TransactionSynchronizationRegistry object can be used by any number of thread-safe application server components.

An instance of the TransactionSynchronizationRegistry interface can be looked up via JNDI by the standard name java:comp/TransactionSynchronizationRegistry or via a dependency injection @Resource of the type TransactionSynchronizationRegistry .

/ Einde Intermezzo

            Transaction tx = transactionManager.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:2c0 status: ActionStatus.RUNNING >

            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);	/ interposedSyncs={}
            if (jcaOrderedLastSynchronization == null) {
/j,
                JCAOrderedLastSynchronizationList toPut = new JCAOrderedLastSynchronizationList((com.arjuna.ats.jta.transaction.Transaction) tx, interposedSyncs);
                jcaOrderedLastSynchronization = interposedSyncs.putIfAbsent(tx, toPut);
                if (jcaOrderedLastSynchronization == null) {
                    jcaOrderedLastSynchronization = toPut;
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization);
/s, com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.registerInterposedSynchronization(javax.transaction.Synchronization) line: 136	
       TransactionImple transactionImple = getTransactionImple();	/ JTA tx,

        try
        {
            transactionImple.registerSynchronizationImple(new SynchronizationImple(synchronization, true));
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.<init>(javax.transaction.Synchronization, boolean) line: 59	
		_theSynch = ptr;
		_theUid = new Uid(); / 0:ffffc0a82b4c:-2c619851:5ad7638e:118f
		_isInterposed = isInterposed;
		
		
/ Intermezzo

Thread [default task-57] (Suspended)	
	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.<init>(javax.transaction.Synchronization, boolean) line: 60	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.registerInterposedSynchronization(javax.transaction.Synchronization) line: 140	
	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 75	
	org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29	
	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform(org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform).registerSynchronization(javax.transaction.Synchronization) line: 126	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 158	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 146	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 92	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 28	
	org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 274	
	org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1327	
	org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 133	
	org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
	org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 83	
	org.hibernate.jpa.internal.EntityManagerFactoryImpl.internalCreateEntityManager(javax.persistence.SynchronizationType, java.util.Map) line: 319	
	org.hibernate.jpa.internal.EntityManagerFactoryImpl.createEntityManager() line: 286	
	org.jboss.as.jpa.container.TransactionScopedEntityManager.createEntityManager(javax.persistence.EntityManagerFactory, java.util.Map, javax.persistence.SynchronizationType) line: 187	
	org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 157	
	org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
	org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
	
	
	repository.LanguageDao.insertInTx() line: 83	
	
	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view6.insertInTx() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	


/ Einde Intermezzo
		
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.registerInterposedSynchronization(javax.transaction.Synchronization) line: 140	
            transactionImple.registerSynchronizationImple(new SynchronizationImple(synchronization, true));
/pd,		
		
/ synchronization is een JTA ding	,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.registerSynchronizationImple(com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple) line: 388	
		if (_theTransaction != null)
		{
			if (_theTransaction.addSynchronization(synchronizationImple) != AddOutcome.AR_ADDED)
			{
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).addSynchronization(com.arjuna.ats.arjuna.coordinator.SynchronizationRecord) line: 135	
		switch (status())
		{
		// https://jira.jboss.org/jira/browse/JBTM-608
		case ActionStatus.RUNNING:
		case ActionStatus.PREPARING:
		{
                // need to guard against synchs being added while we are performing beforeCompletion processing
                if (_synchs.add(sr))
                {
                    result = AddOutcome.AR_ADDED;
                }
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.registerSynchronizationImple(com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple) line: 407	
		if (_theTransaction != null)
		{
			if (_theTransaction.addSynchronization(synchronizationImple) != AddOutcome.AR_ADDED)
/n,
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.registerInterposedSynchronization(javax.transaction.Synchronization) line: 150	
        try
        {
            transactionImple.registerSynchronizationImple(new SynchronizationImple(synchronization, true));
/d,
/t,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 78	
                    delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization);	/ jcaOrderedLastSynchronization is JTA
/d,
                }
            }
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync); / sync is local tx
/s,
   /**
     * This is only allowed at various points of the transaction lifecycle.
     *
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.registerInterposedSynchronization(javax.transaction.Synchronization) line: 70	
        int status = tx.getStatus();
        switch (status) {
            case javax.transaction.Status.STATUS_ACTIVE:
            case javax.transaction.Status.STATUS_PREPARING:
                break;

		} else {
            if (TransactionLogger.ROOT_LOGGER.isTraceEnabled()) {
                TransactionLogger.ROOT_LOGGER.trace("JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: " + synchronization.getClass() + " HashCode: "
                    + synchronization.hashCode() + " toString: " + synchronization);
            }
/ TODO LOG
            preJcaSyncs.add(synchronization);
			
this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19892)	
	jcaSyncs	java.util.ArrayList<E>  (id=19895)	
	preJcaSyncs	java.util.ArrayList<E>  (id=19894)
[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@2526472b]
	tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-2c619851:5ad7638e:1189 status: ActionStatus.RUNNING >
		_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17908)	
			_synchs	java.util.TreeSet<E>  (id=19945)	
[SynchronizationImple< 0:ffffc0a82b4c:-2c619851:5ad7638e:118f, org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList@10ed98e3 >]
/=
			_synchs	java.util.TreeSet<E>  (id=19945)	
				m	java.util.TreeMap<K,V>  (id=19950)	
					root	java.util.TreeMap$Entry<K,V>  (id=20031)	
						key	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=19936)	
							_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19892)	
								jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19061)	
								jcaSyncs	java.util.ArrayList<E>  (id=19895)	
								preJcaSyncs	java.util.ArrayList<E>  (id=19894)	/ see hierboven,
								tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-2c619851:5ad7638e:1189 status: ActionStatus.RUNNING >								
							_theUid	com.arjuna.ats.arjuna.common.Uid  (id=19937)	/ 0:ffffc0a82b4c:-2c619851:5ad7638e:118f
						left	null	
						parent	null	
						right	null	
						value	java.lang.Object  (id=19949)	
					size	1	


synchronization	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=19882)	
	synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=19875)	
		target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19858)	



...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 160
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );	
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
/d,

this	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19858)	
	jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=17521)	
		jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=17520)	
			transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=17966)	
				interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19061)	
					table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=20189)	
						[5]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=20193)	
							key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
								_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17908)	
									objectUid	com.arjuna.ats.arjuna.common.Uid  (id=17913)
0:ffffc0a82b4c:-2c619851:5ad7638e:1189		
									_synchs	java.util.TreeSet<E>  (id=19945)	
										m	java.util.TreeMap<K,V>  (id=19950)	
											root	java.util.TreeMap$Entry<K,V>  (id=20031)	
												key	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=19936)	
													_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19892)	
														jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19061)	
														jcaSyncs	java.util.ArrayList<E>  (id=19895)	
														preJcaSyncs	java.util.ArrayList<E>  (id=19894)	
														tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)
													_theUid	com.arjuna.ats.arjuna.common.Uid  (id=19937) 
0:ffffc0a82b4c:-2c619851:5ad7638e:118f	
							val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19892)	



		synchronizationRegistered = true;
		log.debug( "Hibernate RegisteredSynchronization successfully registered with JTA platform" );			
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 147	
		joinJtaTransaction();
/d,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 93	
		pulse();
/d,
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 278	
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(
					this.jdbcCoordinator,
					this
			);
/d,
			this.currentHibernateTransaction = getTransaction();
/s,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 313	
		if ( this.currentHibernateTransaction == null 
/j	,
			|| this.currentHibernateTransaction.getStatus() != TransactionStatus.ACTIVE ) {
			this.currentHibernateTransaction = new TransactionImpl( getTransactionCoordinator() );
/s,
org.hibernate.engine.transaction.internal.TransactionImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinator) line: 36	
		this.transactionCoordinator = transactionCoordinator;
		this.transactionDriverControl = transactionCoordinator.getTransactionDriverControl();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.getTransactionDriverControl() line: 203	
		if ( physicalTransactionDelegate == null ) {
			physicalTransactionDelegate = makePhysicalTransactionDelegate();
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.makePhysicalTransactionDelegate() line: 211	
		if ( preferUserTransactions ) {
		else {
			adapter = makeTransactionManagerAdapter();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.makeTransactionManagerAdapter() line: 256	
			final TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate@7a1605da
			else {
				return new JtaTransactionAdapterTransactionManagerImpl( transactionManager );
/s,
/**
 * JtaTransactionAdapter for coordinating with the JTA TransactionManager
 *
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.<init>(javax.transaction.TransactionManager) line: 31	
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.makePhysicalTransactionDelegate() line: 234	
		else {
			adapter = makeTransactionManagerAdapter();
/d,
			if ( adapter == null ) {
/n,
				log.debug( "Unable to access TransactionManager, attempting to use UserTransaction instead" );
/ TODO LOG
		return new TransactionDriverControlImpl( adapter );
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl.<init>(org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl, org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapter) line: 378	
/=
public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {
	private static final Logger log = logger( JtaTransactionCoordinatorImpl.class );
	/**
	 * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the
	 * local transaction ({@link org.hibernate.Transaction} to callback into this
	 * TransactionCoordinator for the purpose of driving the underlying JTA transaction.
	 */
	public class TransactionDriverControlImpl implements TransactionDriver {
		private final JtaTransactionAdapter jtaTransactionAdapter;
		private boolean invalid;

		public TransactionDriverControlImpl(JtaTransactionAdapter jtaTransactionAdapter) {
			this.jtaTransactionAdapter = jtaTransactionAdapter;
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl@5b9f1f0a
		}
/ LINK JTA TX EN LOCAL TX
		@Override
		public void begin() {
			errorIfInvalid();

			jtaTransactionAdapter.begin();
			JtaTransactionCoordinatorImpl.this.joinJtaTransaction();
		}
/t,
org.hibernate.engine.transaction.internal.TransactionImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinator) line: 37
		this.transactionDriverControl = transactionCoordinator.getTransactionDriverControl();
/d,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 315	
			this.currentHibernateTransaction = new TransactionImpl( getTransactionCoordinator() );
/d,
		}
		getTransactionCoordinator().pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 132	
		if ( synchronizationRegistered ) {
			return;
		}
/ hier waren we net al,
/t,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 316	
		getTransactionCoordinator().pulse();
/d,
		return currentHibernateTransaction;		
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 337	
		if ( transactionCoordinator == null ) {
			this.isTransactionCoordinatorShared = false;
			this.connectionReleaseMode = connectionReleaseMode;
			this.autoJoinTransactions = autoJoinTransactions;

			this.jdbcCoordinator = new JdbcCoordinatorImpl( connection, this );
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(
					this.jdbcCoordinator,
					this
			);
			this.currentHibernateTransaction = getTransaction();
		}
/d,
		loadQueryInfluencers = new LoadQueryInfluencers( factory );
		if ( TRACE_ENABLED ) {
/n,
			LOG.tracef( "Opened session at timestamp: %s", timestamp );
		}
/s,
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1336	
			final SessionImpl session = new SessionImpl(
					connection,
					sessionFactory,
					sessionOwner,
					getTransactionCoordinator(),
					getJdbcCoordinator(),
					getTransaction(),
					getTransactionCompletionProcesses(),
					autoJoinTransactions,
					sessionFactory.settings.getRegionFactory().nextTimestamp(),
					interceptor,
					statementInspector,
					flushBeforeCompletion,
					autoClose,
					connectionReleaseMode,
					tenantIdentifier
			);
/d,
			return session;
			
session	org.hibernate.internal.SessionImpl  (id=19191)	
	transactionCoordinator	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19858)	
		jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=17521)	
			jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=17520)	
				transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=17966)	
					interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19061)	
						table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=20189)	
							[5]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=20193)	
								key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
									_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17908)	
										_synchs	java.util.TreeSet<E>  (id=19945)	
											m	java.util.TreeMap<K,V>  (id=19950)	
												root	java.util.TreeMap$Entry<K,V>  (id=20031)	
													key	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=19936)	
															preJcaSyncs	java.util.ArrayList<E>  (id=19894)	
															tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
														_theUid	com.arjuna.ats.arjuna.common.Uid  (id=19937)	

/t,
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 135	
			session = sessionBuilder.openSession();
		}
		return session;
/d,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
		// NOTE : pulse() already handles auto-join-ability correctly
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse();
/pd,
/d, want pulse() is al gedaan,
		setDefaultProperties();
/s,
	/**
	 * Sets the default property values for the properties the entity manager supports and which are not already explicitly
	 * set.
	 */
	private void setDefaultProperties() {
		if ( properties.get( AvailableSettings.FLUSH_MODE ) == null ) {
			properties.put( AvailableSettings.FLUSH_MODE, getSession().getFlushMode().toString() );	/ AUTO
		}
		if ( properties.get( AvailableSettings.LOCK_SCOPE ) == null ) {
			this.properties.put( AvailableSettings.LOCK_SCOPE, PessimisticLockScope.EXTENDED.name() );
		}
		if ( properties.get( AvailableSettings.LOCK_TIMEOUT ) == null ) {
			properties.put( AvailableSettings.LOCK_TIMEOUT, LockOptions.WAIT_FOREVER );
		}
		if ( properties.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) == null ) {
			properties.put( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE, CacheModeHelper.DEFAULT_RETRIEVE_MODE );
		}
		if ( properties.get( AvailableSettings.SHARED_CACHE_STORE_MODE ) == null ) {
			properties.put( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheModeHelper.DEFAULT_STORE_MODE );
		}
this	org.hibernate.jpa.internal.EntityManagerImpl  (id=20128)	
	properties	java.util.HashMap<K,V>  (id=21779)	
{javax.persistence.lock.timeout=-1, org.hibernate.flushMode=AUTO, javax.persistence.cache.retrieveMode=USE, javax.persistence.lock.scope=EXTENDED, javax.persistence.cache.storeMode=USE}
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 177	
		setDefaultProperties();
/d,
		applyProperties();
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).applyProperties() line: 181	
		getSession().setFlushMode( ConfigurationHelper.getFlushMode( properties.get( AvailableSettings.FLUSH_MODE ) ) );
/s,
org.hibernate.internal.SessionImpl.setFlushMode(org.hibernate.FlushMode) line: 1481	
		errorIfClosed();
		checkTransactionSynchStatus();
		LOG.tracev( "Setting flush mode to: {0}", flushMode );
		this.flushMode = flushMode;	 / enum, 
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).applyProperties() line: 181	
		getSession().setFlushMode( ConfigurationHelper.getFlushMode( properties.get( AvailableSettings.FLUSH_MODE ) ) );
/d,
		setLockOptions( this.properties, this.lockOptions );
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).setLockOptions(java.util.Map<java.lang.String,java.lang.Object>, org.hibernate.LockOptions) line: 224	
		Object lockScope = props.get( AvailableSettings.LOCK_SCOPE );
EXTENDED
		if ( lockScope instanceof String && PessimisticLockScope.valueOf( ( String ) lockScope ) == PessimisticLockScope.EXTENDED ) {
			options.setScope( true );
		}
		Object lockTimeout = props.get( AvailableSettings.LOCK_TIMEOUT );
Integer -1
		int timeout = 0;
		else if ( lockTimeout instanceof Number ) {
			timeout = ( (Number) lockTimeout ).intValue();
			timeoutSet = true;
		}
		if ( timeoutSet ) {
			else if ( timeout < 0 ) {
				options.setTimeOut( LockOptions.WAIT_FOREVER );
			}		
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).applyProperties() line: 183	
		setLockOptions( this.properties, this.lockOptions );
/d,			
		getSession().setCacheMode(                   / NORMAL, want:
				CacheModeHelper.interpretCacheMode(
						currentCacheStoreMode(),	/ USE
						currentCacheRetrieveMode()	/ USE
				)
		);
/s,
org.hibernate.jpa.internal.util.CacheModeHelper.interpretCacheMode(javax.persistence.CacheStoreMode, javax.persistence.CacheRetrieveMode) line: 49	
params: USE, USE
		final boolean get = ( CacheRetrieveMode.USE == retrieveMode ); / true

		switch ( storeMode ) {
			case USE: {
				return get ? CacheMode.NORMAL : CacheMode.PUT;
/t,
org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 84	
		postInit();
/d,
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 158	
        if (entityManager == null) {
            entityManager = createEntityManager(emf, properties, synchronizationType);
/d,
            if (ROOT_LOGGER.isDebugEnabled()) {
/j,
/ TODO LOG 
                ROOT_LOGGER.debugf("%s: created entity manager session %s", TransactionUtil.getEntityManagerDetails(entityManager, scopedPuName),
                        TransactionUtil.getTransaction(transactionManager).toString());
            }
/ we zien,
21:25:47,716 DEBUG [org.jboss.as.jpa] (default task-13) default task-13:transaction scoped EntityManager [test.war#arquillian-forge4-persistence-unit]: created entity manager session TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:2f5 status: ActionStatus.RUNNING >

transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=19562)	
	delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=20139)	
		tm	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=19560)	
			TRANSACTION_MANAGER	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=20102)	
			transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=20102)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20137)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=21874)	
			[4]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=21877)	
				key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20101)	
				val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=20138)	
					tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20101)						<-		global tx
					preJcaSyncs	java.util.ArrayList<E>  (id=20144)											<-		local tx	
					/=
						elementData	java.lang.Object[10]  (id=21984)	
							[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=20134)	
								synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=20133)	
									target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=20131)	
										callbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=20133)	
											target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=20131)	
										jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=19824)	
										physicalTransactionDelegate	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=20885)	
										synchronizationRegistry	org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl  (id=21993)	
										transactionCoordinatorOwner	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=21994)	
											logicalConnection	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl  (id=22001)	
												physicalConnection	null	
											owner	org.hibernate.internal.SessionImpl  (id=20126)	
	
					
            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
			
scopedPuName=test.war#arquillian-forge4-persistence-unit
transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=17966)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19061)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=20189)	
			[5]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=20193)	
				key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
					_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17908)	
						_synchs	java.util.TreeSet<E>  (id=19945)	
							m	java.util.TreeMap<K,V>  (id=19950)	
								root	java.util.TreeMap$Entry<K,V>  (id=20031)	
									key	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=19936)	
										_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19892)	
										_theUid	com.arjuna.ats.arjuna.common.Uid  (id=19937)	
						transactionStore	null
/s,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 73
	
        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);						
/s,
org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization.<init>(javax.persistence.EntityManager, java.lang.String) line: 152	

/=
public class TransactionUtil {
    /**
     * Using the TransactionListener, we can detect Synchronization.afterCompletion() being called from a
     * background thread, while the application may still be actively using the EntityManager.
     * We need to ensure that the background thread does not close the EntityManager while the application thread
     * is actively using it.
     *
     * We know when the application thread is associated with the transaction and can defer closing the EntityManager
     * until both conditions are met:
     *
     *   1. application is disassociated from transaction
     *   2. Synchronization.afterCompletion has been called
     *
     * See discussions for more details about how we arrived at using the TransactionListener:
     *     https://developer.jboss.org/message/919807
     *     https://developer.jboss.org/thread/252572
     */
    private static class SessionSynchronization implements Synchronization, TransactionListener {
        private EntityManager manager;  // the underlying entity manager
        private String scopedPuName;
        private transient boolean transactionDisassociatedFromApplication = false;
        private transient boolean afterCompletionCalled = false;

        public SessionSynchronization(EntityManager session, String scopedPuName) {
            this.manager = session;
            this.scopedPuName = scopedPuName;
        }

        /**
         * After the JTA transaction is ended (Synchronization.afterCompletion has been called) and
         * the JTA transaction is no longer associated with application thread (application thread called
         * transaction.rollback/commit/suspend), the entity manager can safely be closed.
         */
        private void safeCloseEntityManager() {
            ...
/t,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 74	
        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);
/d,
        tsr.registerInterposedSynchronization(sessionSynchronization);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 70	
            Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
jcaOrderedLastSynchronization	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=20138)	
	jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20137)	
	jcaSyncs	java.util.ArrayList<E>  (id=20143)	
[]
	preJcaSyncs	java.util.ArrayList<E>  (id=20144)	
[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@1879b9bb]
	tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20101)	
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:2f5 status: ActionStatus.RUNNING >

            if (jcaOrderedLastSynchronization == null) {
/n,
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync);
sync=org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@46d08051
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.registerInterposedSynchronization(javax.transaction.Synchronization) line: 90	
        } else {
            if (TransactionLogger.ROOT_LOGGER.isTraceEnabled()) {
/n,
/ TODO LOG 
                TransactionLogger.ROOT_LOGGER.trace("JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: " + synchronization.getClass() + " HashCode: "
                    + synchronization.hashCode() + " toString: " + synchronization);
            }
            preJcaSyncs.add(synchronization);
			
this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19892)	
	preJcaSyncs	java.util.ArrayList<E>  (id=19894)	
		elementData	java.lang.Object[10]  (id=20221)	
			[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=19882)	
				synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=19875)	
					target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19858)	
						jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=17521)	
			[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=21200)	
				manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19071)	

/t,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 76	
        tsr.registerInterposedSynchronization(sessionSynchronization);
        try {
            getTransactionListenerRegistry(transactionManager).addListener(getTransaction(transactionManager), sessionSynchronization, eventTypes);
/ getTransactionListenerRegistry(transactionManager)==transactionManager==com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate@7a1605da
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).addListener(javax.transaction.Transaction, org.jboss.tm.listener.TransactionListener, java.util.EnumSet<org.jboss.tm.listener.EventType>) line: 163	
        Collection<TransactionListener> listeners = getListeners(transaction, true);
[]
        if (listeners != null) {
            listeners.add(listener);

            // if transaction is already associated with the current thread notify this listener
            try {
                if (transaction.equals(getTransaction()) && types.contains(EventType.ASSOCIATED))
                    listener.onEvent(new TransactionEvent(transaction, EnumSet.of(EventType.ASSOCIATED)));
/ doet WH NIETS, 
/ TODO

/ Intermezzo

    /**
     * Get the transaction associated with the thread.
     * @return the transaction or null if none associated.
     */
    public Transaction getTransaction()
        throws SystemException
    {
        return transactionManager.getTransaction() ;
/=
	BasicAction.Current()
==
		Deque<BasicAction> txs = _threadList.get();
		
/ Dit is een ThreadLocal, is current tx assoc. met deze thread	,

		/= ThreadLocal, TODO
    }

/ Einde Intermezzo
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 163	
            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
/d,			
            TransactionUtil.putEntityManagerInTransactionRegistry(scopedPuName, entityManager, transactionSynchronizationRegistry);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.putEntityManagerInTransactionRegistry(java.lang.String, javax.persistence.EntityManager, javax.transaction.TransactionSynchronizationRegistry) line: 127	
        tsr.putResource(scopedPuName, entityManager);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.putResource(java.lang.Object, java.lang.Object) line: 112	
        delegate.putResource(key, value);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 109	
        if (jtaLogger.logger.isTraceEnabled()) {
/n,
/ TODO LOG 
            jtaLogger.logger.trace("TransactionSynchronizationRegistryImple.putResource");
        }
        TransactionImple transactionImple = getTransactionImple();
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:78c063d2:5abd0139:2f5 status: ActionStatus.RUNNING >
        transactionImple.putTxLocalResource(key, value);
		
key=test.war#arquillian-forge4-persistence-unit		
value=org.hibernate.jpa.internal.EntityManagerImpl@4513fbc9
/ wel logische, typisch local,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.putTxLocalResource(java.lang.Object, java.lang.Object) line: 1096	
			_txLocalResources.put(key, value);
{__TX_LISTENERS=[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@46d08051], test.war#arquillian-forge4-persistence-unit=org.hibernate.jpa.internal.EntityManagerImpl@5e387854}
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/pd,
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1144	
			internalGetSession().persist( entity );
...
/s,
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
		firePersist( new PersistEvent( entityName, object, this ) );
/s,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
/s,
org.hibernate.internal.SessionImpl.listeners(org.hibernate.event.spi.EventType<T>) line: 654	
		return eventListenerGroup( type ).listeners();	type=create
/s,
org.hibernate.internal.SessionImpl.eventListenerGroup(org.hibernate.event.spi.EventType<T>) line: 658	
		return factory.getServiceRegistry().getService( EventListenerRegistry.class ).getEventListenerGroup( type );
/s,
org.hibernate.event.service.internal.EventListenerRegistryImpl.getEventListenerGroup(org.hibernate.event.spi.EventType) line: 79	
this	org.hibernate.event.service.internal.EventListenerRegistryImpl  (id=18485)	
	registeredEventListeners	org.hibernate.event.service.internal.EventListenerGroupImpl<T>[36]  (id=18488)	
		[0]	org.hibernate.event.service.internal.EventListenerGroupImpl<T>  (id=18489)	
			duplicationStrategies	java.util.LinkedHashSet<E>  (id=18598)	
			eventType	org.hibernate.event.spi.EventType<T>  (id=18453)	
			listeners	java.util.ArrayList<E>  (id=18599)	
		[1]	org.hibernate.event.service.internal.EventListenerGroupImpl<T>  (id=18490)	
			duplicationStrategies	java.util.LinkedHashSet<E>  (id=18603)	
			eventType	org.hibernate.event.spi.EventType<T>  (id=18476)	
			listeners	java.util.ArrayList<E>  (id=18604)
		...
		[34]	org.hibernate.event.service.internal.EventListenerGroupImpl<T>  (id=18523)	
		[35]	org.hibernate.event.service.internal.EventListenerGroupImpl<T>  (id=18524)

		EventListenerGroupImpl<T> listeners = registeredEventListeners[ eventType.ordinal() ];
listeners	org.hibernate.event.service.internal.EventListenerGroupImpl<T>  (id=18495)	
	duplicationStrategies	java.util.LinkedHashSet<E>  (id=19155)	
	eventType	org.hibernate.event.spi.EventType<T>  (id=18442)	
	listeners	java.util.ArrayList<E>  (id=19156)	
		return listeners;		
/t,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
/d,
			listener.onPersist( event );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
		onPersist( event, new IdentityHashMap( 10 ) );
		
event	org.hibernate.event.spi.PersistEvent  (id=22238)	
	entityName	null	
	object	domain.Language  (id=22249)	
	session	org.hibernate.internal.SessionImpl  (id=20126)	

		final SessionImplementor source = event.getSession();
SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=ExecutableList{size=0} updates=ExecutableList{size=0} deletions=ExecutableList{size=0} orphanRemovals=ExecutableList{size=0} collectionCreations=ExecutableList{size=0} collectionRemovals=ExecutableList{size=0} collectionUpdates=ExecutableList{size=0} collectionQueuedOps=ExecutableList{size=0} unresolvedInsertDependencies=null])
		final Object object = event.getObject();
Language name: Java
		else {
			entity = object;
		else {
			entityName = source.bestGuessEntityName( entity ); / domain.Language
			event.setEntityName( entityName );
		}
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
source	org.hibernate.internal.SessionImpl  (id=17871)	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=19188)	
		entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=19195)	
			nonEnhancedEntityXref	null	/ hier zou hij moeten zijn,
				
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntry(java.lang.Object) line: 433	
		return entityEntryContext.getEntityEntry( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		// locate a ManagedEntity for the entity, but only if it is associated with the same PersistenceContext.
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );	
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null
/n,
					? nonEnhancedEntityXref.get( entity )
					: null;													<-
		}		
...
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 99	
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
null
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).getEntityState(java.lang.Object, java.lang.String, org.hibernate.engine.spi.EntityEntry, org.hibernate.engine.spi.SessionImplementor) line: 489	
		final boolean traceEnabled = LOG.isTraceEnabled();
/ TODO LOG
		if ( entry != null ) { // the object is persistent
/n,
		// the object is transient or detached

		// the entity is not associated with the session, so
		// try interceptor and unsaved-value

		if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source ) ) {
/s,
org.hibernate.engine.internal.ForeignKeys.isTransient(java.lang.String, java.lang.Object, java.lang.Boolean, org.hibernate.engine.spi.SessionImplementor) line: 219	

		// let the interceptor inspect the instance to decide
		Boolean isUnsaved = session.getInterceptor().isTransient( entity );
/s,
org.hibernate.EmptyInterceptor.isTransient(java.lang.Object) line: 77	
		return null;
/t,
		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
/s,
org.hibernate.internal.SessionImpl.getEntityPersister(java.lang.String, java.lang.Object) line: 1529	
		else {
			// try block is a hack around fact that currently tuplizers are not
			// given the opportunity to resolve a subclass entity name.  this
			// allows the (we assume custom) interceptor the ability to
			// influence this decision if we were not able to based on the
			// given entityName
			try {
				return factory.getEntityPersister( entityName ).getSubclassEntityPersister( object, getFactory() );
/s,
org.hibernate.internal.SessionFactoryImpl.getEntityPersister(java.lang.String) line: 779	

		EntityPersister result = entityPersisters.get( entityName );
entityPersisters={domain.Language=SingleTableEntityPersister(domain.Language)}
/ is er al,
/t,
org.hibernate.engine.internal.ForeignKeys.isTransient(java.lang.String, java.lang.Object, java.lang.Boolean, org.hibernate.engine.spi.SessionImplementor) line: 226	
		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
/d,
		isUnsaved = persister.isTransient( entity, session );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).isTransient(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 4324	
		if ( canExtractIdOutOfEntity() ) {
			id = getIdentifier( entity, session );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getIdentifier(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 4612	
		return getEntityTuplizer().getIdentifier( entity, session );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).getIdentifier(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 209	
			else {
				id = idGetter.get( entity );
entity	domain.Language  (id=19175)	
	serialVersionUID	1	
	id	null					/ heeft nog geen id (komt straks uit db)	, dus is transient,
	name	"Java" (id=19177)	
	version	0	
		try {
			return (Serializable) id;		/ null	
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).isTransient(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 4332	
		if ( canExtractIdOutOfEntity() ) {
			id = getIdentifier( entity, session );
/d,
		// we *always* assume an instance with a null
		// identifier or no identifier property is unsaved!
		if ( id == null ) {
/j,
			return Boolean.TRUE;
/t,
org.hibernate.engine.internal.ForeignKeys.isTransient(java.lang.String, java.lang.Object, java.lang.Boolean, org.hibernate.engine.spi.SessionImplementor) line: 228	
		isUnsaved = persister.isTransient( entity, session );
		if ( isUnsaved != null ) {
/j, true != null
			return isUnsaved;
		}
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).getEntityState(java.lang.Object, java.lang.String, org.hibernate.engine.spi.EntityEntry, org.hibernate.engine.spi.SessionImplementor) line: 514	
		if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source ) ) {
/j,
			if ( traceEnabled ) {
/n,
				LOG.tracev( "Transient instance of: {0}", getLoggableName( entityName, entity ) );
/ TODO LOG 
			}
			return EntityState.TRANSIENT;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 100	
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/d,
		switch ( entityState ) {
			case TRANSIENT: {
				entityIsTransient( event, createCache );
				break;
			}
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 183	
		LOG.trace( "Saving transient instance" );
/ TODO LOG 
		final EventSource source = event.getSession();
		final Object entity = source.getPersistenceContext().unproxy( event.getObject() );
Language name: Java
/ doet NIETS,
		if ( createCache.put( entity, entity ) == null ) {
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 66	
		callbackRegistry.preCreate( entity );
/ TODO
		return super.saveWithGeneratedId( entity, entityName, anything, source, requiresImmediateIdAccess );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		EntityPersister persister = source.getEntityPersister( entityName, entity );	/ TODO
SingleTableEntityPersister(domain.Language)
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
		
/ we gaan nu eerst de id gen, en vervolgens (straks) save,

/s,
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/s,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
		// IMPL NOTE : this method is called concurrently and is
		// not synchronized. It is very important to work on the
		// local variable: the field lastSourceValue is not
		// reliable as it might be mutated by multipled threads.
		// The lastSourceValue field is only accessed by tests,
		// so this is not a concern.
		IntegralDataTypeHolder value = callback.getNextValue();
/s,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );	 <-
sql=select nextval ('hibernate_sequence')
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
/=
		public PreparedStatement prepareStatement() {
			try {
				getJdbcService().getSqlStatementLogger().logStatement( sql );
/ TODO LOG 
				final PreparedStatement preparedStatement;
				try {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementStart();
					preparedStatement = doPrepare();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 85	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
/j,
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
		return logicalConnection().getPhysicalConnection();
/s,
	protected final LogicalConnectionImplementor logicalConnection() {
		return jdbcCoordinator.getLogicalConnection();
/t,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
		return acquireConnectionIfNeeded();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 83	
			try {
				physicalConnection = jdbcConnectionAccess.obtainConnection();
/s,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 385	
				return connectionProvider.getConnection();
/s,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/s,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
        return delegate.getConnection();
/s,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 134	
         if (mcf.getSpy().booleanValue())
/j,
            spyLogger.debugf("%s [%s] getConnection()",
                             mcf.getJndiName(), Constants.SPY_LOGGER_PREFIX_DATASOURCE);
/ we zien,
18:46:09,956 DEBUG [jboss.jdbc.spy] (default task-59) java:jboss/datasources/PostgreSQLDS [DataSource] getConnection()

         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
this	org.jboss.jca.adapters.jdbc.WrapperDataSource  (id=19326)	
	cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=19330)	
	mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=19355)
XAManagedConnectionFactory@9673c36[xaDataSourceClass=org.postgresql.xa.PGXADataSource xaProps=15bc6b7 userName=null password=**** transactionIsolation=-1]	
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 733
      //Check for pooling!
      if (pool == null || shutdown.get()) / pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@2d40f1f9
/n,
      //it is an explicit spec requirement that equals be used for matching rather than ==.
      if (!pool.getManagedConnectionFactory().equals(mcf))
/n,
      // Pick a managed connection from the pool
      Subject subject = getSubject();
null
      ConnectionListener cl = getManagedConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
      Transaction trackByTransaction = null;
      try
      {
         Transaction tx = transactionManager.getTransaction();
         if (tx != null)
         {
            if (!allowMarkedForRollback)
            {
               if (!TxUtils.isActive(tx))
/n,
      log.tracef("getManagedConnection interleaving=%s , tx=%s", interleaving, trackByTransaction);  
/ TODO LOG      
      return super.getManagedConnection(trackByTransaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 580	
      try
      {
         return pool.getConnection(transaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 578	

      // Get specific managed connection pool key
      Object key = getKey(subject, cri, separateNoTx);
false
/ TODO
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
key=false
subject=null
cri=null
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getManagedConnectionPool(java.lang.Object, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 295	
      try
      {
         ManagedConnectionPool mcp = mcpPools.get(key);
{false=SemaphoreConcurrentLinkedQueueManagedConnectionPool@31d9b87a[pool=PostgreSQLDS]}
         return mcp;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 584	
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);

      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
	  
this	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19401)	
	cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=19330)	
		txIntegration	org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl  (id=19433)	
			tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=19439)\
				delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=19456)	
					tm	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=17826)	
						transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=17841)	

      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionKey() line: 86	
        return delegate.getTransactionKey();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionKey() line: 76	
        if (jtaLogger.logger.isTraceEnabled()) {
/ TODO LOG 
            jtaLogger.logger.trace("TransactionSynchronizationRegistryImple.getTransactionKey");
        }

        TransactionImple transactionImple = null;
        try
        {
            transactionImple = (TransactionImple)tm.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-3a7c19:5ac2072e:124 status: ActionStatus.RUNNING >
        } else {
            return transactionImple.get_uid();
transactionImple	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17840)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17848)	
		objectUid	com.arjuna.ats.arjuna.common.Uid  (id=19537)	0:ffffc0a87b73:-3a7c19:5ac2072e:124
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 587	
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;
/d,
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 659	
      try
      {
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126	
        TransactionImple transactionImple = getTransactionImple();
        return transactionImple.getTxLocalResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);
_txLocalResources={
	org.jboss.jca.core.connectionmanager.transaction.LockKey@2a=java.util.concurrent.locks.ReentrantLock@66476bd4[Locked by thread default task-59], 
	__TX_LISTENERS=[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@6b5bf4e3], test.war#arquillian-forge4-persistence-unit=org.hibernate.jpa.internal.EntityManagerImpl@3139d86d
}
/ 2 entries	,	
/ later	3 entries	,
_txLocalResources={SemaphoreConcurrentLinkedQueueManagedConnectionPool@4743fca5[pool=PostgreSQLDS]=org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@2fe26234[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@62037624 connection handles=0 lastReturned=1522769053092 lastValidated=1522768465078 lastCheckedOut=1522769232242 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@4ae5df32 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@4743fca5[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@520ba3c2[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@62037624 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=TransactionSynchronization@160861266{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:4c status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=false cancel=false}],

org.jboss.jca.core.connectionmanager.transaction.LockKey@2a=java.util.concurrent.locks.ReentrantLock@72af1395[Locked by thread default task-44],

__TX_LISTENERS=[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@4d27047d], test.war#arquillian-forge4-persistence-unit=org.hibernate.jpa.internal.EntityManagerImpl@1227715e
}

key=SemaphoreConcurrentLinkedQueueManagedConnectionPool@31d9b87a[pool=PostgreSQLDS]		
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 660	
      try
      {
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
null
         return null;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 593	
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
null
      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);
trackByTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17840)	
TransactionImple < ac, BasicAction: 0:ffffc0a87b73:-3a7c19:5ac2072e:124 status: ActionStatus.RUNNING >
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	
      // Need a new one for this transaction
      // This must be done outside the tx local lock, otherwise
      // the tx timeout won't work and get connection can do a lot of other work
      // with many opportunities for deadlocks.
      // Instead we do a double check after we got the transaction to see
      // whether another thread beat us to the punch.
      ConnectionListener cl = mcp.getConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 268	
      if (log.isTraceEnabled()) 
/ TODO LOG 
      if (pool.isFull()) 
/n,
this	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=19427)	
	pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19401)	
		permits	org.jboss.jca.core.connectionmanager.pool.api.Semaphore  (id=19443)	
			sync	java.util.concurrent.Semaphore$FairSync  (id=19596)	
				state	20	
				
      long startWait = pool.getInternalStatistics().isEnabled() ? System.currentTimeMillis() : 0L;
0
      try 
      {
         if (pool.getLock().tryAcquire(poolConfiguration.getBlockingTimeout(), TimeUnit.MILLISECONDS)) 
/j,
         {
            if (pool.getInternalStatistics().isEnabled())
/n,
               pool.getInternalStatistics().deltaTotalBlockingTime(System.currentTimeMillis() - startWait);

            // We have a permit to get a connection. Is there one in the pool already?
            ConnectionListenerWrapper clw = null;
            do 
            {
               if (!isRunning()) 
/n,
               if (fifo)
/n,
               {
                  clw = clq.pollFirst();
               }
               else
               {
                  clw = clq.pollLast();
null
               if (clw != null) 
/n,
            while (clq.size() > 0);			   
/n,
            // OK, we couldnt find a working connection from the pool. Make
            // a new one.
            try 
            {
               // No, the pool was empty, so we have to make a new one.
               clw = new ConnectionListenerWrapper(createConnectionEventListener(subject, cri), true, true);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1318	
      long start = pool.getInternalStatistics().isEnabled() ? System.currentTimeMillis() : 0L;
0
      ManagedConnection mc = mcf.createManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 376	
      if (urlProperty != null && !urlProperty.trim().equals("") && xadsSelector == null)
/n,
         initSelector();

      if (xadsSelector == null)
      {
         final Subject copySubject = subject != null ? SecurityActions.createSubject(false, subject) : null;

         if (copySubject != null)
/n,	  
         else
         {
            return getXAManagedConnection(subject, cri);
			
/ Intermezzo

/ lees,
https://docs.jboss.org/author/display/WFLY10/Logging+Configuration

/ Einde Intermezzo 
	  
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 484	
      XAConnection xaConnection = null;
      Properties props = getConnectionProperties(null, subject, cri);
{}
      try
      {
         final String user = props.getProperty("user");	/ null
         final String password = props.getProperty("password"); / null

         xaConnection = (user != null)
            ? getXADataSource().getXAConnection(user, password)
            : getXADataSource().getXAConnection();  
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection() line: 39	
        return getXAConnection(getUser(), getPassword());
/ WH getUser()="eric", getPassword="vi_lang17"
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection(java.lang.String, java.lang.String) line: 55	
        Connection con = super.getConnection(user, password);
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getConnection(java.lang.String, java.lang.String) line: 88	
            Connection con = DriverManager.getConnection(getUrl(), user, password);
			
/ dit is geen XA of zoiets	,

/s,
org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getUrl() line: 974	
        StringBuilder url = new StringBuilder(100);
        url.append("jdbc:postgresql://");
        url.append(serverName);
        if (portNumber != 0) {
            url.append(":").append(portNumber);
        }
        url.append("/").append(databaseName);
jdbc:postgresql://localhost/test

        for (PGProperty property: PGProperty.values())	
/ toen we F3 gaven op PGProperty, werd deze resolved, en zagen we de source,	TODO
        {
            if (property.isPresent(properties))	/ properties={}
/n,
property=PG_DBNAME	,
PG_HOST	,
PG_PORT	,
USER	, 
PASSWORD	,
PROTOCOL_VERSION	,
STRING_TYPE
SSL
SSL_MODE
SSL_FACTORY
SSL_FACTORY_ARG
SSL_HOSTNAME_VERIFIER
SSL_CERT
SSL_KEY
SSL_ROOT_CERT
...
SSL_PASSWORD_CALLBACK
ASSUME_MIN_SERVER_VERSION
APPLICATION_NAME
JAAS_APPLICATION_NAME
...

/j,
LOG_LEVEL
PREPARE_THRESHOLD
PREPARED_STATEMENT_CACHE_QUERIES
PREPARED_STATEMENT_CACHE_SIZE_MIB
DEFAULT_ROW_FETCH_SIZE
BINARY_TRANSFER
COMPATIBLE
READ_ONLY
BINARY_TRANSFER_ENABLE
BINARY_TRANSFER_DISABLE
UNKNOWN_LENGTH
LOG_UNCLOSED_CONNECTIONS
DISABLE_COLUMN_SANITISER
TCP_KEEP_ALIVE
LOGIN_TIMEOUT
CONNECT_TIMEOUT
SOCKET_TIMEOUT
RECEIVE_BUFFER_SIZE
SEND_BUFFER_SIZE
...
       if (property.isPresent(properties))
            {
                if (query.length() != 0)
                {
                    query.append("&");
                }
                query.append(property.getName());
                query.append("=");
                query.append(property.get(properties));
            }
        }
query=loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10

        if (query.length() > 0)
        {
            url.append("?");
            url.append(query);
        }

        return url.toString();
/t,
/s,
java.sql.DriverManager.getConnection(java.lang.String, java.lang.String, java.lang.String) line: 238	
url=
jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10
        java.util.Properties info = new java.util.Properties();

        if (user != null) {			/ eric
            info.put("user", user);
        }
        if (password != null) {			/ vi_lang17
            info.put("password", password);
        }

        return (getConnection(url, info, Reflection.getCallerClass()));
/s,
java.sql.DriverManager.getConnection(java.lang.String, java.util.Properties, java.lang.Class<?>) line: 640	

        println("DriverManager.getConnection(\"" + url + "\")");
/ zie NIET,
        for(DriverInfo aDriver : registeredDrivers) {
[driver[className=org.h2.Driver@15de937a], driver[className=org.postgresql.Driver@752b39c8]]
            if(isDriverAllowed(aDriver.driver, callerCL)) {
/n, bij h2 driver, 
/j, bij pg driver, 
/ TODO
                try {
                    println("    trying " + aDriver.driver.getClass().getName());
                    Connection con = aDriver.driver.connect(url, info);
/s,
org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 234	
/=
    public java.sql.Connection connect(String url, Properties info) throws SQLException
url=jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10
info={user=eric, password=vi_lang17}
        try
        {
            defaults = getDefaultProperties();
{user=ERVELDEN}
        // override defaults with provided properties
        Properties props = new Properties(defaults);
        if (info != null)
        {
            for (Enumeration e = info.propertyNames(); e.hasMoreElements(); )
            {
                String propName = (String)e.nextElement();
                String propValue = info.getProperty(propName);
                if ( propValue == null ) {
                    throw new PSQLException(GT.tr("Properties for the driver contains a non-string value for the key ")+propName,
                                            PSQLState.UNEXPECTED_ERROR);
                }
                props.setProperty( propName,propValue );
            }
        }
        // parse URL and add more properties
        if ((props = parseURL(url, props)) == null)
props={disableColumnSanitiser=false, binaryTransfer=true, gsslib=auto, allowEncodingChanges=false, sspiServiceClass=POSTGRES, prepareThreshold=5, PGPORT=5432, useSpnego=false, PGHOST=localhost, loginTimeout=0, hostRecheckSeconds=10, defaultRowFetchSize=0, loadBalanceHosts=false, unknownLength=2147483647, preparedStatementCacheQueries=256, PGDBNAME=test, binaryTransferDisable=, receiveBufferSize=-1, targetServerType=any, logUnclosedConnections=false, connectTimeout=0, readOnly=false, socketTimeout=0, tcpKeepAlive=false, binaryTransferEnable=, preparedStatementCacheSizeMiB=5, loglevel=0, sendBufferSize=-1, compatible=9.4}
        try
        {
            logger.debug("Connecting with URL: " + url);
/ TODO LOG 
            // Enforce login timeout, if specified, by running the connection
            // attempt in a separate thread. If we hit the timeout without the
            // connection completing, we abandon the connection attempt in
            // the calling thread, but the separate thread will keep trying.
            // Eventually, the separate thread will either fail or complete
            // the connection; at that point we clean up the connection if
            // we managed to establish one after all. See ConnectThread for
            // more details.
            long timeout = timeout(props);
            if (timeout <= 0)
/s,
org.postgresql.Driver.timeout(java.util.Properties) line: 643	
        String timeout = PGProperty.LOGIN_TIMEOUT.get(props);
0
        if (timeout != null) {
            try {
                return (long) (Float.parseFloat(timeout) * 1000);
/t,
org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 282	
            long timeout = timeout(props);
            if (timeout <= 0)
                return makeConnection(url, props);
/s,
org.postgresql.Driver.makeConnection(java.lang.String, java.util.Properties) line: 414	
        return new org.postgresql.jdbc42.Jdbc42Connection(hostSpecs(props),
                                      user(props), database(props),
                                      props, url);
/s,
org.postgresql.jdbc42.Jdbc42Connection.<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 28	
        super(hostSpecs, user, database, info, url);
...
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 113
	
        // Read loglevel arg and set the loglevel based on this value;
        // In addition to setting the log level, enable output to
        // standard out if no other printwriter is set

        int logLevel = Driver.getLogLevel();
0
        Integer connectionLogLevel = PGProperty.LOG_LEVEL.getInteger(info);
0
        if (connectionLogLevel != null) {
            logLevel = connectionLogLevel;
        }
        synchronized (AbstractJdbc2Connection.class) {
            logger = new Logger(nextConnectionID++);
            logger.setLogLevel(logLevel);
        }

        if (logLevel > 0)
/n,
            enableDriverManagerLogging();

			        setDefaultFetchSize(PGProperty.DEFAULT_ROW_FETCH_SIZE.getInt(info));
0
        prepareThreshold = PGProperty.PREPARE_THRESHOLD.getInt(info);
5
        //Print out the driver version number
        if (logger.logInfo())
/n,
            logger.info(Driver.getVersion());

        // Now make the initial connection and set up local state
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
/s,
org.postgresql.core.ConnectionFactory.openConnection(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 57	
        String protoName = PGProperty.PROTOCOL_VERSION.get(info);
null
        for (Object[] version : versions) {
[0]	java.lang.Object[2]  (id=19882)	
	[0]	"3" (id=19886)	
	[1]	org.postgresql.core.v3.ConnectionFactoryImpl  (id=19890)	
[1]	java.lang.Object[2]  (id=19883)	
	[0]	"2" (id=19891)	
	[1]	org.postgresql.core.v2.ConnectionFactoryImpl  (id=19892)	

            String versionProtoName = (String) version[0];
            if (protoName != null && !protoName.equals(versionProtoName))
/n,
                continue;

            ConnectionFactory factory = (ConnectionFactory) version[1];
            ProtocolConnection connection = factory.openConnectionImpl(hostSpecs, user, database, info, logger);
/s,
org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 71	
        String sslmode = PGProperty.SSL_MODE.get(info);
        if (sslmode==null)
        { //Fall back to the ssl property
          requireSSL = trySSL  = PGProperty.SSL.isPresent(info);
false
        //  - the TCP keep alive setting
        boolean requireTCPKeepAlive = PGProperty.TCP_KEEP_ALIVE.getBoolean(info);
false
        int connectTimeout = PGProperty.CONNECT_TIMEOUT.getInt(info) * 1000;

        //  - the targetServerType setting
        HostRequirement targetServerType;
        try {
            targetServerType = HostRequirement.valueOf(info.getProperty("targetServerType", HostRequirement.any.name()));
any
        HostChooser hostChooser = HostChooserFactory.createHostChooser(hostSpecs, targetServerType, info);
        for (Iterator<HostSpec> hostIter = hostChooser.iterator(); hostIter.hasNext(); ) {
            HostSpec hostSpec = hostIter.next();
localhost:5432
        PGStream newStream = null;
        try
        {
            newStream = new PGStream(hostSpec, connectTimeout);
/s,
org.postgresql.core.PGStream.<init>(org.postgresql.util.HostSpec, int) line: 57	
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);
        changeSocket(socket);
/s,
org.postgresql.core.PGStream.changeSocket(java.net.Socket) line: 111	
        // Submitted by Jason Venner <jason@idiom.com>. Disable Nagle
        // as we are selective about flushing output only when we
        // really need to.
        connection.setTcpNoDelay(true);

        // Buffer sizes submitted by Sverre H Huseby <sverrehu@online.no>
        pg_input = new VisibleBufferedInputStream(connection.getInputStream(), 8192);
        pg_output = new BufferedOutputStream(connection.getOutputStream(), 8192);

        if (encoding != null)
/n,
            setEncoding(encoding);
/t,
org.postgresql.core.PGStream.<init>(org.postgresql.util.HostSpec, int) line: 63	
        changeSocket(socket);
/d,
        setEncoding(Encoding.getJVMEncoding("US-ASCII"));

        _int2buf = new byte[2];
        _int4buf = new byte[4];
/t,
org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 132	
            newStream = new PGStream(hostSpec, connectTimeout);
/d,
            // Construct and send an ssl startup packet if requested.
            if (trySSL)
/n,
/ TODO SSL 
                newStream = enableSSL(newStream, requireSSL, info, logger, connectTimeout);
            
            // Set the socket timeout if the "socketTimeout" property has been set.
            int socketTimeout = PGProperty.SOCKET_TIMEOUT.getInt(info); 
0
            if (socketTimeout > 0) {
                newStream.getSocket().setSoTimeout(socketTimeout*1000);
            }

            // Enable TCP keep-alive probe if required.
            newStream.getSocket().setKeepAlive(requireTCPKeepAlive);

            // Try to set SO_SNDBUF and SO_RECVBUF socket options, if requested.
            // If receiveBufferSize and send_buffer_size are set to a value greater
            // than 0, adjust. -1 means use the system default, 0 is ignored since not
            // supported.

            // Set SO_RECVBUF read buffer size
            int receiveBufferSize = PGProperty.RECEIVE_BUFFER_SIZE.getInt(info);
-1
            if (receiveBufferSize > -1) {
                // value of 0 not a valid buffer size value
                if (receiveBufferSize > 0) {
                    newStream.getSocket().setReceiveBufferSize(receiveBufferSize);
                } else {
                    logger.info("Ignore invalid value for receiveBufferSize: " + receiveBufferSize);
                }
            }

            // Set SO_SNDBUF write buffer size 
            int sendBufferSize = PGProperty.SEND_BUFFER_SIZE.getInt(info);
-1
            if (sendBufferSize > -1) {
                if (sendBufferSize > 0) {
                    newStream.getSocket().setSendBufferSize(sendBufferSize);
                } else {
                    logger.info("Ignore invalid value for sendBufferSize: " + sendBufferSize);
                }
            }

            logger.info("Receive Buffer Size is " + newStream.getSocket().getReceiveBufferSize());
            logger.info("Send Buffer Size is " + newStream.getSocket().getSendBufferSize());
/ TODO LOG We zien NIETS,
            List<String[]> paramList = new ArrayList<String[]>();
            paramList.add(new String[] {"user", user});
            paramList.add(new String[] {"database", database});
            paramList.add(new String[] {"client_encoding", "UTF8"});
            paramList.add(new String[] {"DateStyle", "ISO"});
            paramList.add(new String[] {"TimeZone",  createPostgresTimeZone()});
            String assumeMinServerVersion = PGProperty.ASSUME_MIN_SERVER_VERSION.get(info);
null
            if( Utils.parseServerVersionStr(assumeMinServerVersion) >= ServerVersion.v9_0.getVersionNum() ) {
/n,
                // User is explicitly telling us this is a 9.0+ server so set properties here:
                paramList.add(new String[] {"extra_float_digits", "3"});
                String appName = PGProperty.APPLICATION_NAME.get(info);
                if( appName != null ) {
                    paramList.add(new String[] {"application_name", appName});
                }
            } else {
/j,
                // User has not explicitly told us that this is a 9.0+ server so stick to old default:
                paramList.add(new String[] {"extra_float_digits", "2"});
            }

            String currentSchema = PGProperty.CURRENT_SCHEMA.get(info);
null
            if (currentSchema != null)
            {
                paramList.add(new String[] {"search_path", currentSchema});
            }
elementData	java.lang.Object[10]  (id=19977)	
	[0]	java.lang.String[2]  (id=19978)	
		[0]	"user" (id=19844)	
		[1]	"eric" (id=19647)	
	[1]	java.lang.String[2]  (id=19979)	
		[0]	"database" (id=19990)	
		[1]	"test" (id=19865)	
	[2]	java.lang.String[2]  (id=19980)	
		[0]	"client_encoding" (id=19988)	
		[1]	"UTF8" (id=19989)	
	[3]	java.lang.String[2]  (id=19981)	
		[0]	"DateStyle" (id=19986)	
		[1]	"ISO" (id=19987)	
	[4]	java.lang.String[2]  (id=19982)	
		[0]	"TimeZone" (id=19985)	
		[1]	"Europe/Berlin" (id=19972)	
	[5]	java.lang.String[2]  (id=19983)	
		[0]	"extra_float_digits" (id=19984)	
		[1]	"2" (id=19891)	
			
            String[][] params = paramList.toArray(new String[][]{});
            sendStartupPacket(newStream, params, logger);
/s,
    private void sendStartupPacket(PGStream pgStream, String[][] params, Logger logger) throws IOException {
params=[[user, eric], [database, test], [client_encoding, UTF8], [DateStyle, ISO], [TimeZone, Europe/Berlin], [extra_float_digits, 2]]		
        if (logger.logDebug())
/ TODO LOG 
        /*
         * Precalculate message length and encode params.
         */
        int length = 4 + 4;
        byte[][] encodedParams = new byte[params.length * 2][];
        for (int i = 0; i < params.length; ++i)
        {
            encodedParams[i*2] = params[i][0].getBytes("UTF-8");
            encodedParams[i*2 + 1] = params[i][1].getBytes("UTF-8");
            length += encodedParams[i * 2].length + 1 + encodedParams[i * 2 + 1].length + 1;
        }

        length += 1; // Terminating \0

encodedParams=[[117, 115, 101, 114], [101, 114, 105, 99], [100, 97, 116, 97, 98, 97, 115, 101], [116, 101, 115, 116], [99, 108, 105, 101, 110, 116, 95, 101, 110, 99, 111, 100, 105, 110, 103], [85, 84, 70, 56], [68, 97, 116, 101, 83, 116, 121, 108, 101], [73, 83, 79], [84, 105, 109, 101, 90, 111, 110, 101], [69, 117, 114, 111, 112, 101, 47, 66, 101, 114, 108, 105, 110], [101, 120, 116, 114, 97, 95, 102, 108, 111, 97, 116, 95, 100, 105, 103, 105, 116, 115], [50]]
length=112
        /*
         * Send the startup message.
         */
        pgStream.SendInteger4(length);
        pgStream.SendInteger2(3); // protocol major
        pgStream.SendInteger2(0); // protocol minor
        for (byte[] encodedParam : encodedParams) {
            pgStream.Send(encodedParam);
            pgStream.SendChar(0);
        }

        pgStream.SendChar(0);
        pgStream.flush();

		
            if (connection != null)
                return connection;
        }
			
/ TODO Afmaken	,

/ 7		.

/ een andere keer gaf getTransactionOldConnection null,
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 598	
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
null
      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	
      // Need a new one for this transaction
      // This must be done outside the tx local lock, otherwise
      // the tx timeout won't work and get connection can do a lot of other work
      // with many opportunities for deadlocks.
      // Instead we do a double check after we got the transaction to see
      // whether another thread beat us to the punch.
      ConnectionListener cl = mcp.getConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 297
      try 
      {
         if (pool.getLock().tryAcquire(poolConfiguration.getBlockingTimeout(), TimeUnit.MILLISECONDS)) 
         {
            // We have a permit to get a connection. Is there one in the pool already?
            ConnectionListenerWrapper clw = null;
            do 
            {
               if (fifo)
/n,
               {
                  clw = clq.pollFirst();
               }
               else
               {
                  clw = clq.pollLast();
null
               }
               if (clw != null) 
/n,
            while (clq.size() > 0);
/n,
            // OK, we couldnt find a working connection from the pool. Make
            // a new one.
            try 
            {
               // No, the pool was empty, so we have to make a new one.
               clw = new ConnectionListenerWrapper(createConnectionEventListener(subject, cri), true, true);
/=BREAKPOINT
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1318
		
      ManagedConnection mc = mcf.createManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 376	
         else
         {
            return getXAManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 484	
      XAConnection xaConnection = null;
      Properties props = getConnectionProperties(null, subject, cri);
{}
      try
      {
         final String user = props.getProperty("user");
         final String password = props.getProperty("password");

         xaConnection = (user != null)
/n,
            ? getXADataSource().getXAConnection(user, password)
            : getXADataSource().getXAConnection();
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXADataSource() line: 612	
      if (xads == null)
/n,
      return xads;
/t,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 492	
         xaConnection = (user != null)
            ? getXADataSource().getXAConnection(user, password)
            : getXADataSource().getXAConnection();
/pd,
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection() line: 39	
this	org.postgresql.xa.PGXADataSource  (id=19129)	
	databaseName	"test" (id=19730)	
	logger	null	
	password	"vi_lang17" (id=19732)	
	portNumber	0	
	properties	java.util.Properties  (id=19733)	{}
	serverName	"localhost" (id=19737)	
	user	"eric" (id=19738)	
        return getXAConnection(getUser(), getPassword());
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection(java.lang.String, java.lang.String) line: 54	
        Connection con = super.getConnection(user, password);
/s,
org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getConnection(java.lang.String, java.lang.String) line: 88	
        try
        {
            Connection con = DriverManager.getConnection(getUrl(), user, password);
/s,
java.sql.DriverManager.getConnection(java.lang.String, java.lang.String, java.lang.String) line: 238	
url=jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10
user=eric
password=vi_lang17
        java.util.Properties info = new java.util.Properties();

        if (user != null) {
            info.put("user", user);
        }
        if (password != null) {
            info.put("password", password);
        }

        return (getConnection(url, info, Reflection.getCallerClass()));
/s,
java.sql.DriverManager.getConnection(java.lang.String, java.util.Properties, java.lang.Class<?>) line: 640	
        for(DriverInfo aDriver : registeredDrivers) {
            // If the caller does not have permission to load the driver then
            // skip it.
            if(isDriverAllowed(aDriver.driver, callerCL)) {
aDriver=driver[className=org.h2.Driver@49ba5b43]
/n,
/ classLoader kan hem niet load,
/ TODO
        for(DriverInfo aDriver : registeredDrivers) {
            // If the caller does not have permission to load the driver then
            // skip it.
            if(isDriverAllowed(aDriver.driver, callerCL)) {
                try {
                    println("    trying " + aDriver.driver.getClass().getName());
                    Connection con = aDriver.driver.connect(url, info);
/s,
org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 234	
url=jdbc:postgresql://localhost/test?loglevel=0&prepareThreshold=5&preparedStatementCacheQueries=256&preparedStatementCacheSizeMiB=5&defaultRowFetchSize=0&binaryTransfer=true&compatible=9.4&readOnly=false&binaryTransferEnable=&binaryTransferDisable=&unknownLength=2147483647&logUnclosedConnections=false&disableColumnSanitiser=false&tcpKeepAlive=false&loginTimeout=0&connectTimeout=0&socketTimeout=0&receiveBufferSize=-1&sendBufferSize=-1&useSpnego=false&gsslib=auto&sspiServiceClass=POSTGRES&allowEncodingChanges=false&targetServerType=any&loadBalanceHosts=false&hostRecheckSeconds=10
info	java.util.Properties  (id=19752)	
	table	java.util.Hashtable$Entry<K,V>[11]  (id=19776)	
		[7]	java.util.Hashtable$Entry<K,V>  (id=19777)	
			hash	1216985755	
			key	"password" (id=19780)	
			next	null	
			value	"vi_lang17" (id=19732)	
		[8]	java.util.Hashtable$Entry<K,V>  (id=19778)	
			hash	3599307	
			key	"user" (id=19779)	
			next	null	
			value	"eric" (id=19738)	
...
/ TODO
            // Enforce login timeout, if specified, by running the connection
            // attempt in a separate thread. If we hit the timeout without the
            // connection completing, we abandon the connection attempt in
            // the calling thread, but the separate thread will keep trying.
            // Eventually, the separate thread will either fail or complete
            // the connection; at that point we clean up the connection if
            // we managed to establish one after all. See ConnectThread for
            // more details.
            long timeout = timeout(props);
            if (timeout <= 0)
                return makeConnection(url, props);
props={disableColumnSanitiser=false, binaryTransfer=true, gsslib=auto, allowEncodingChanges=false, sspiServiceClass=POSTGRES, prepareThreshold=5, PGPORT=5432, useSpnego=false, PGHOST=localhost, loginTimeout=0, hostRecheckSeconds=10, defaultRowFetchSize=0, loadBalanceHosts=false, unknownLength=2147483647, preparedStatementCacheQueries=256, PGDBNAME=test, binaryTransferDisable=, receiveBufferSize=-1, targetServerType=any, logUnclosedConnections=false, connectTimeout=0, readOnly=false, socketTimeout=0, tcpKeepAlive=false, binaryTransferEnable=, preparedStatementCacheSizeMiB=5, loglevel=0, sendBufferSize=-1, compatible=9.4}
/s,
org.postgresql.Driver.makeConnection(java.lang.String, java.util.Properties) line: 415	
        return new org.postgresql.jdbc42.Jdbc42Connection(hostSpecs(props),
                                      user(props), database(props),
                                      props, url);
...
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 60	
    
    private boolean autoCommit = true;
	
	    // Read loglevel arg and set the loglevel based on this value;
        // In addition to setting the log level, enable output to
        // standard out if no other printwriter is set

        int logLevel = Driver.getLogLevel(); / 0
        Integer connectionLogLevel = PGProperty.LOG_LEVEL.getInteger(info); / 0
        if (connectionLogLevel != null) {
            logLevel = connectionLogLevel;
        }

        synchronized (AbstractJdbc2Connection.class) {
            logger = new Logger(nextConnectionID++);
            logger.setLogLevel(logLevel);
        }
        if (logLevel > 0)
/n,
            enableDriverManagerLogging();
			
        setDefaultFetchSize(PGProperty.DEFAULT_ROW_FETCH_SIZE.getInt(info)); / 0

        prepareThreshold = PGProperty.PREPARE_THRESHOLD.getInt(info);	/ 5
        if (prepareThreshold == -1)
/n,
            forcebinary = true;
        
        boolean binaryTransfer = PGProperty.BINARY_TRANSFER.getBoolean(info);
true
        //Print out the driver version number
        if (logger.logInfo())
/n,
            logger.info(Driver.getVersion());

        // Now make the initial connection and set up local state
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
/s,
org.postgresql.core.ConnectionFactory.openConnection(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 57
        String protoName = PGProperty.PROTOCOL_VERSION.get(info);
null		
        for (Object[] version : versions) {
version=[3, org.postgresql.core.v3.ConnectionFactoryImpl@654a5e2a]

            String versionProtoName = (String) version[0];
            if (protoName != null && !protoName.equals(versionProtoName))
                continue;

            ConnectionFactory factory = (ConnectionFactory) version[1];
            ProtocolConnection connection = factory.openConnectionImpl(hostSpecs, user, database, info, logger);
/s,
org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 71	
        PGStream newStream = null;
        try
        {
            newStream = new PGStream(hostSpec, connectTimeout);
/s,
org.postgresql.core.PGStream.<init>(org.postgresql.util.HostSpec, int) line: 57	
        this.hostSpec = hostSpec;
localhost:5432
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);
        changeSocket(socket);
/s,
org.postgresql.core.PGStream.changeSocket(java.net.Socket) line: 116	
        this.connection = socket;

        // Submitted by Jason Venner <jason@idiom.com>. Disable Nagle
        // as we are selective about flushing output only when we
        // really need to.
        connection.setTcpNoDelay(true);

        // Buffer sizes submitted by Sverre H Huseby <sverrehu@online.no>
        pg_input = new VisibleBufferedInputStream(connection.getInputStream(), 8192);
        pg_output = new BufferedOutputStream(connection.getOutputStream(), 8192);

        if (encoding != null)
/n,
            setEncoding(encoding);
			
			
/ Intermezzo

/ we zijn nog steeds in 
repository.LanguageDao.insertInTx() line: 83	
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
		
/ maar er moet eerst een connectie worden gemaakt	,

/ we zijn in,	
/s,
Thread [default task-43] (Suspended)	
	org.postgresql.core.PGStream.changeSocket(java.net.Socket) line: 116	
	org.postgresql.core.PGStream.<init>(org.postgresql.util.HostSpec, int) line: 62	
	org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 129	
	org.postgresql.core.ConnectionFactory.openConnection(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 65	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 146	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 35	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3g.AbstractJdbc3gConnection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 22	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc4.AbstractJdbc4Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 47	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc42.AbstractJdbc42Connection).<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 21	
	org.postgresql.jdbc42.Jdbc42Connection.<init>(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, java.lang.String) line: 28	
	org.postgresql.Driver.makeConnection(java.lang.String, java.util.Properties) line: 415	
	org.postgresql.Driver.connect(java.lang.String, java.util.Properties) line: 282	
	java.sql.DriverManager.getConnection(java.lang.String, java.util.Properties, java.lang.Class<?>) line: 664	
	java.sql.DriverManager.getConnection(java.lang.String, java.lang.String, java.lang.String) line: 247	
	org.postgresql.xa.PGXADataSource(org.postgresql.ds.common.BaseDataSource).getConnection(java.lang.String, java.lang.String) line: 88	
	org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection(java.lang.String, java.lang.String) line: 54	
	org.postgresql.xa.PGXADataSource(org.postgresql.xa.jdbc3.AbstractJdbc3XADataSource).getXAConnection() line: 39	
	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 492	
	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 416	
	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1320	
	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	
	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 598	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
	org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
	org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
	org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
/cb,
	org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
	org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
	org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
	org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
	org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
	org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
	org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
	repository.LanguageDao.insertInTx() line: 83	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view8.insertInTx() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	


/ Einde Intermezzo

/t,
org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(org.postgresql.util.HostSpec[], java.lang.String, java.lang.String, java.util.Properties, org.postgresql.core.Logger) line: 173	
            newStream = new PGStream(hostSpec, connectTimeout);
/d,
            List<String[]> paramList = new ArrayList<String[]>();
            paramList.add(new String[] {"user", user});
            paramList.add(new String[] {"database", database});
            paramList.add(new String[] {"client_encoding", "UTF8"});
            paramList.add(new String[] {"DateStyle", "ISO"});
            paramList.add(new String[] {"TimeZone",  createPostgresTimeZone()});
            String assumeMinServerVersion = PGProperty.ASSUME_MIN_SERVER_VERSION.get(info);
null
            if( Utils.parseServerVersionStr(assumeMinServerVersion) >= ServerVersion.v9_0.getVersionNum() ) {
/n,
                // User is explicitly telling us this is a 9.0+ server so set properties here:
                paramList.add(new String[] {"extra_float_digits", "3"});
                String appName = PGProperty.APPLICATION_NAME.get(info);
                if( appName != null ) {
                    paramList.add(new String[] {"application_name", appName});
                }
            } else {
                // User has not explicitly told us that this is a 9.0+ server so stick to old default:
                paramList.add(new String[] {"extra_float_digits", "2"});
            }

            String currentSchema = PGProperty.CURRENT_SCHEMA.get(info);
null
            if (currentSchema != null)
/n,
            {
                paramList.add(new String[] {"search_path", currentSchema});
            }

            String[][] params = paramList.toArray(new String[][]{});
[[user, eric], [database, test], [client_encoding, UTF8], [DateStyle, ISO], [TimeZone, Europe/Berlin], [extra_float_digits, 2]]
            sendStartupPacket(newStream, params, logger);
/s,
org.postgresql.core.v3.ConnectionFactoryImpl.sendStartupPacket(org.postgresql.core.PGStream, java.lang.String[][], org.postgresql.core.Logger) line: 369	
        if (logger.logDebug())
/n,
/ TODO LOG 
        /*
         * Precalculate message length and encode params.
         */
        int length = 4 + 4;										/ voor .SendInteger4 en 2 .sendInteger2 hier beneden	,
        byte[][] encodedParams = new byte[params.length * 2][];
        for (int i = 0; i < params.length; ++i)
        {
            encodedParams[i*2] = params[i][0].getBytes("UTF-8");
            encodedParams[i*2 + 1] = params[i][1].getBytes("UTF-8");
            length += encodedParams[i * 2].length + 1 + encodedParams[i * 2 + 1].length + 1;
        }

        length += 1; // Terminating \0

[[117, 115, 101, 114], [101, 114, 105, 99], [100, 97, 116, 97, 98, 97, 115, 101], [116, 101, 115, 116], [99, 108, 105, 101, 110, 116, 95, 101, 110, 99, 111, 100, 105, 110, 103], [85, 84, 70, 56], [68, 97, 116, 101, 83, 116, 121, 108, 101], [73, 83, 79], [84, 105, 109, 101, 90, 111, 110, 101], [69, 117, 114, 111, 112, 101, 47, 66, 101, 114, 108, 105, 110], [101, 120, 116, 114, 97, 95, 102, 108, 111, 97, 116, 95, 100, 105, 103, 105, 116, 115], [50]]
length 112

        /*
         * Send the startup message.
         */
        pgStream.SendInteger4(length);
        pgStream.SendInteger2(3); // protocol major
        pgStream.SendInteger2(0); // protocol minor
        for (byte[] encodedParam : encodedParams) {
            pgStream.Send(encodedParam);
            pgStream.SendChar(0);
        }

        pgStream.SendChar(0);
        pgStream.flush();




		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
/ 7	. 

/ enlist	,

/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/d,
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
	  
/ de cm heeft de tsr,
this	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=17596)	
	transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=17966)	
		interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19061)	
		
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).reconnectManagedConnection(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 928	
      try
      {
         managedConnectionReconnected(cl);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 552	
      try
      {
         if (shouldEnlist(cl.getManagedConnection()))		 
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.shouldEnlist(javax.resource.spi.ManagedConnection) line: 921	
/=
   private boolean shouldEnlist(ManagedConnection mc)
mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=17258)	
	con	com.sun.proxy.$Proxy54  (id=17273)	
	currentXid	null	
	xaConnection	org.postgresql.xa.PGXAConnection  (id=17286)	
	xaResource	org.postgresql.xa.PGXAConnection  (id=17286)	
true
/t,
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 263	
      // This method is a bit convulted, but it has to be such because
      // there is a race condition in the transaction manager where it
      // unlocks during the enlist of the XAResource. It does this
      // to avoid distributed deadlocks and to ensure the transaction
      // timeout can fail a badly behaving resource during the enlist.
      //
      // When two threads in the same transaction are trying to enlist
      // connections they could be from the same resource manager
      // or even the same connection when tracking the connection by transaction.
      //
      // For the same connection, we only want to do the real enlist once.
      // For two connections from the same resource manager we don't
      // want the join before the initial start request.
      //
      // The solution is to build up a list of unenlisted resources
      // in the TransactionSynchronizer and then choose one of the
      // threads that is contending in the transaction to enlist them
      // in order. The actual order doesn't really matter as it is the
      // transaction manager that calculates the enlist flags and determines
      // whether the XAResource was already enlisted.
      //
      // Once there are no unenlisted resources the threads are released
      // to return the result of the enlistments.
      //
      // In practice, a thread just takes a snapshot to try to avoid one
      // thread having to do all the work. If it did not do them all
      // the next waiting thread will do the next snapshot until there
      // there is either no snapshot or no waiting threads.
      //
      // A downside to this design is a thread could have its resource enlisted by
      // an earlier thread while it enlists some later thread's resource.
      // Since they are all a part of the same transaction, this is probably
      // not a real issue.

      // If we are already enlisted there is no reason to check again, as this method
      // could be called multiple times during a transaction lifecycle.
      // We know that we can only be inside this method if we are allowed to
      if (isEnlisted() || getState().equals(ConnectionState.DESTROY) || getState().equals(ConnectionState.DESTROYED))
/n,
/ TODO
         return;

      // No transaction associated with the thread
      TransactionManager tm = getConnectionManager().getTransactionIntegration().getTransactionManager();
this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=17241)	
	cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=17242)	
		txIntegration	org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl  (id=17331)	
			rr	com.arjuna.ats.jbossatx.jta.RecoveryManagerService  (id=17980)	
			terminator	com.arjuna.ats.internal.jbossatx.jta.jca.XATerminator  (id=17981)	
			tm	org.jboss.jca.core.tx.jbossts.TransactionManagerDelegator  (id=17295)						<-
				tm	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=17192)	
					transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=17194)	
			tsr	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=17231)	
			utr	org.jboss.jca.core.tx.jbossts.UserTransactionRegistryImpl  (id=17982)	

      int status = tm.getStatus();
/s,
org.jboss.jca.core.tx.jbossts.TransactionManagerDelegator.getStatus() line: 77	
      return tm.getStatus();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
        return transactionManager.getStatus() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
		TransactionImple theTransaction = TransactionImple.getTransaction();
		else
			return theTransaction.getStatus();
...
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 353	
		int status = javax.transaction.Status.STATUS_NO_TRANSACTION;
		
		if (_theTransaction != null)
		{
			status = StatusConverter.convert(_theTransaction.status());
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 44	
		case ActionStatus.RUNNING:
			return javax.transaction.Status.STATUS_ACTIVE;
...
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 270	
      if (isEnlisted() || getState().equals(ConnectionState.DESTROY) || getState().equals(ConnectionState.DESTROYED))
         return;

      // No transaction associated with the thread
/ want is niet enlisted,
      TransactionManager tm = getConnectionManager().getTransactionIntegration().getTransactionManager();
      int status = tm.getStatus();
/d,
      // Inactive transaction
      Transaction threadTx = tm.getTransaction();
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:4c status: ActionStatus.RUNNING >
      if (threadTx == null || status != Status.STATUS_ACTIVE)
/n,
      log.tracef("Pre-enlist: %s threadTx=%s", this, threadTx);
/ TODO LOG 
      // Our synchronization
      TransactionSynchronization ourSynchronization = null;

      // Serializes enlistment when two different threads are enlisting
      // different connections in the same transaction concurrently
      TransactionSynchronizer synchronizer = null;

      try
      {
         TransactionSynchronizer.lock(threadTx,
                                      getConnectionManager().getTransactionIntegration());
      try
      {
         // Interleaving should have an unenlisted transaction
         // TODO We should be able to do some sharing shouldn't we?
         if (!isTrackByTx() && transactionSynchronization != null)
/n,
         // Check for different transaction
         if (transactionSynchronization != null && !transactionSynchronization.currentTx.equals(threadTx))
/n,
         // Get the synchronizer
         try
         {
            log.tracef("Get synchronizer %s threadTx=%s",this, threadTx);

            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());

         // First time through, create a transaction synchronization
         if (transactionSynchronization == null)
/n,
      finally
      {
         TransactionSynchronizer.unlock(threadTx, getConnectionManager().getTransactionIntegration());

      // Perform the enlistment(s)
      List<Synchronization> unenlisted = synchronizer.getUnenlisted();
null
      if (unenlisted != null)
/n,
[TransactionSynchronization@554471675{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:e7 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=false cancel=false}]
      {
         try
         {
            int size = unenlisted.size();
            for (int i = 0; i < size; ++i)
            {
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
TransactionSynchronization@554471675{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:e7 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=false cancel=false}
               if (sync.enlist())
/s,
/ BRANCH CREATE
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986	
            XAResource resource = getXAResource();
XAResourceWrapperImpl@de37243[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@12134c7f pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]
            if (!currentTx.enlistResource(resource))
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	

/ van jca -> jta,

		return enlistResource(xaRes, null);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 430	
		int status = getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 353	
		int status = javax.transaction.Status.STATUS_NO_TRANSACTION;
		
		if (_theTransaction != null)
		{
			status = StatusConverter.convert(_theTransaction.status());
/s,
				switch (status)
				{
				case ActionStatus.RUNNING:
					return javax.transaction.Status.STATUS_ACTIVE;
				}
/t,		
		if (jtaLogger.logger.isTraceEnabled()) {
/ TODO
            jtaLogger.logger.trace("TransactionImple.getStatus: " + JTAHelper.stringForm(status));
        }

		return status;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 446	
		switch (status)
		{
		case javax.transaction.Status.STATUS_ACTIVE:
			break;

		XAModifier theModifier = null;

		if (params != null)
/n,
		try
		{
			/*
			 * For each transaction we maintain a list of resources registered
			 * with it. Each element on this list also contains a list of
			 * threads which have registered this resource, and what their XID
			 * was for that registration.
			 */

			TxInfo info = null;		 
			/*
			 * Have we seen this specific resource instance before? Do this
			 * trawl first before checking the RM instance later. Saves time.
			 */

			try
			{
				synchronized (this)
				{
					info = (TxInfo) _resources.get(xaRes);
_resources={}
xaRes=XAResourceWrapperImpl@de37243[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@12134c7f pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]
info=null
					if (info == null)
					{
						/*
						 * Null info means it's not in the main resources list,
						 * but may be in the duplicates.
						 */

						info = (TxInfo) _duplicateResources.get(xaRes);
_duplicateResources={}
info=null
			/*
			 * We definitely haven't seen this specific resource instance
			 * before, but that doesn't mean that we haven't seen the RM it is
			 * connected to.
			 */

			Xid xid = null;
			TxInfo existingRM = isNewRM(xaRes);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.isNewRM(javax.transaction.xa.XAResource) line: 1476	
		try
		{
			synchronized (this)
			{
				Enumeration el = _resources.keys();	_resources={}

		
				el = _duplicateResources.keys();	_duplicateResources={}



		return null;
	}
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 589	
/ BRANCH CREATE
			Xid xid = null;
			TxInfo existingRM = isNewRM(xaRes);
/d,
			if (existingRM == null)
			{
				/*
				 * New RM, so create xid with new branch.
				 */

				boolean branchRequired = true;

				synchronized (this)
				{
					if (_resources.size() == 0)// first ever, so no need for
					// branch
					{
						// branchRequired = false;
						branchRequired = true;
					}
				}

				xid = createXid(branchRequired, theModifier, xaRes);
/ BRANCH CREATE
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1529	
        int eisName = 0;
        if(branch) {
            if(_xaResourceRecordWrappingPlugin != null) {
                eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);
/s,
com.arjuna.ats.internal.jbossatx.jta.XAResourceRecordWrappingPluginImpl.getEISName(javax.transaction.xa.XAResource) line: 69	
		if (xaResource instanceof XAResourceWrapper) {
			initialize();
/ is al, 
/ TODO
			String jndiName = ((XAResourceWrapper) xaResource).getJndiName();
java:jboss/datasources/PostgreSQLDS
			Integer key = nameToKey.get(jndiName);
nameToKey={java:jboss/datasources/RemoteExampleDS=3, java:jboss/datasources/ExampleDS=1, java:jboss/datasources/PostgreSQLDS=2}

			return key;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1535	
                eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);
/d,
2
            }
        }
		
/ de xid wordt door de tranaction created	,

		Xid xid = new XidImple(_theTransaction.get_uid(), branch, eisName);	 / branch=true, _theTransaction.get_uid() is de global uid,
/s,
com.arjuna.ats.jta.xa.XidImple.<init>(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 92	
		try {
			_theXid = XATxConverter.getXid(id, branch, eisName);
/s,
    public static final int FORMAT_ID = 131077; // different from JTS ones.
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 59	
        if (branch)
            return getXid(uid, new Uid(), FORMAT_ID, eisName);	/ uid is de global uid, new Uid() is de branch uid, die nu created wordt,
/ BRANCH CREATE
/ TODO we hadden toch al een new Uid() in de tsr (transactionSynchronizationRegistry) 

/s,
com.arjuna.ats.arjuna.common.Uid.<init>() line: 77	
        hostAddr = null;
        process = 0;
        sec = 0;
        other = 0;
        _hashValue = -1;
        _valid = false;
        _stringForm = null;
        _byteForm = null;

        try
        {
            hostAddr = Utility.hostInetAddr(); /* calculated only once */
[0, 281473913989964]
/ TODO
            process = Utility.getpid();
/s,
com.arjuna.ats.arjuna.utils.Utility.getpid() line: 285	
        Process handle = getProcess();
/s,
com.arjuna.ats.arjuna.utils.Utility.getProcess() line: 338	
        return processHandle;
processHandle	com.arjuna.ats.internal.arjuna.utils.UuidProcessId  (id=20831)	
	_theUid	java.util.UUID  (id=20840)	595ad83a-970f-4b9d-856f-46c35e323666
	_pid	-918716933	
/t,
com.arjuna.ats.arjuna.utils.Utility.getpid() line: 285	
        Process handle = getProcess();
/d,
        return ((handle == null) ? -1 : handle.getpid());
/t,
com.arjuna.ats.arjuna.common.Uid.<init>() line: 80	
            hostAddr = Utility.hostInetAddr(); /* calculated only once */
            process = Utility.getpid();
/d,
            sec = Uid.initTime;
1522768461
            other = Uid.getValue();
/s,
com.arjuna.ats.arjuna.common.Uid.getValue() line: 654	
        int value = 0;
        do
        {
            value = uidsCreated.getAndIncrement();
246
        }
        while (value >= MAX_SEQ_VALUE);
/ TODO
/ MAX_SEQ_VALUE=1073741824
		return value;
/t,
com.arjuna.ats.arjuna.common.Uid.<init>() line: 87	
            other = Uid.getValue();
/d,
245
/ TODO
            _valid = true;

            generateHash();
/s,
com.arjuna.ats.arjuna.common.Uid.generateHash() line: 676	
        if (_valid)
        {
            if (true)
                _hashValue = (int) hostAddr[0] ^ (int) hostAddr[1] ^ process
                        ^ sec ^ other;
/t,
    public static final int FORMAT_ID = 131077; // different from JTS ones.
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 60	
        if (branch)
            return getXid(uid, new Uid(), FORMAT_ID, eisName);
/pd,
/s,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, com.arjuna.ats.arjuna.common.Uid, int, java.lang.Integer) line: 78	
/=
    private static XID getXid(Uid uid, Uid branch, int formatId, Integer eisName) throws IllegalStateException
uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7	 / global tx
branch=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5	/ local tx

        XID xid = new XID();
xid	com.arjuna.ats.internal.jta.xa.XID  (id=20863)	

        xid.formatID = formatId;	/ FORMAT_ID	, 131077

        // gtrid is uid byte form followed by as many chars of the node name as will fit.
        byte[] gtridUid = uid.getBytes();

        String nodeName = TxControl.getXANodeName();           
1
        int nodeNameLengthToUse =  nodeName.getBytes().length;
1
        xid.gtrid_length = gtridUid.length+nodeNameLengthToUse;
29
        // src, srcPos, dest, destPos, length
        System.arraycopy(gtridUid, 0, xid.data, 0, gtridUid.length);
        System.arraycopy(nodeName.getBytes(), 0, xid.data, gtridUid.length, nodeNameLengthToUse);
        
        if (branch.notEquals(Uid.nullUid()))
		{
            // bqual is uid byte form plus EIS name.
            byte[] bqualUid = branch.getBytes();

            if (bqualUid.length > XID.MAXBQUALSIZE) {
                throw new IllegalStateException(); // Uid is too long!!!!
/ TODO STACK
            }

            int spareBqualBytes = XID.MAXBQUALSIZE - (bqualUid.length + 4);
32           
            xid.bqual_length = bqualUid.length+4+4;
36
            // src, srcPos, dest, destPos, length
            int offset = xid.gtrid_length;
29
            System.arraycopy (bqualUid, 0, xid.data, offset, bqualUid.length);
            setEisName(xid, eisName);
/s,
com.arjuna.ats.jta.xa.XATxConverter.setEisName(com.arjuna.ats.internal.jta.xa.XID, java.lang.Integer) line: 249	
		int offset = theXid.gtrid_length + Uid.UID_SIZE;
57
		theXid.data[offset + 0] = (byte) (eisName >>> 24);	/ 0  in theXid.data[] op plaats 57
		theXid.data[offset + 1] = (byte) (eisName >>> 16);	/ 0 op plaats 58
		theXid.data[offset + 2] = (byte) (eisName >>> 8);	/ 0 op plaats 59
		theXid.data[offset + 3] = (byte) (eisName >>> 0);	/ 2 op plaats 60
/t,
com.arjuna.ats.jta.xa.XidImple.<init>(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 99	
			_theXid = XATxConverter.getXid(id, branch, eisName);
		
		hashCode = getHash(_theXid);
/s,
com.arjuna.ats.jta.xa.XidImple.getHash(com.arjuna.ats.internal.jta.xa.XID) line: 370	
		final int hash = generateHash(xid.formatID, xid.data, 0,	/ vanaf 0 tot gtrid_length,
				xid.gtrid_length);			
/s,
com.arjuna.ats.jta.xa.XidImple.generateHash(int, byte[], int, int) line: 386	
/=
	protected static int generateHash(int hash, final byte[] bytes,
			final int start, final int length) {
/ hash=131077	, lijkt een initiele hash	,
/ length=29
		for (int count = start; count < length; count++) {
			hash = 31 * hash + bytes[count];
		}
		return hash;			
/t,
com.arjuna.ats.jta.xa.XidImple.getHash(com.arjuna.ats.internal.jta.xa.XID) line: 370	
		final int hash = generateHash(xid.formatID, xid.data, 0,
				xid.gtrid_length);
/d,
		return generateHash(hash, xid.data, xid.gtrid_length, xid.bqual_length);	/ vanaf gtrid_length tot bqual_length			
/t,
/**
 * Implementation of javax.transaction.xa.Xid.
 * 
com.arjuna.ats.jta.xa.XidImple.<init>(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 99
		try {
			_theXid = XATxConverter.getXid(id, branch, eisName);	
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
		hashCode = getHash(_theXid);
/d,		
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1537	
		Xid xid = new XidImple(_theTransaction.get_uid(), branch, eisName);
/d,
/ str repr:
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
			
xid	com.arjuna.ats.jta.xa.XidImple  (id=20825)	
	_theXid	com.arjuna.ats.internal.jta.xa.XID  (id=20863)	
		bqual_length	36	
		data	(id=20864)	byte[]....
		formatID	131077	
		gtrid_length	29	
	hashCode	132232178	
/ de hashCode zit in XidImple, niet in XID,

		return xid;
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-2c619851:5ad7638e:1189, node_name=1, branch_uid=0:ffffc0a82b4c:-2c619851:5ad7638e:1196, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
/t	,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 609	
				xid = createXid(branchRequired, theModifier, xaRes);
/d,
				/*
				 * If another process has (or is about to) create the same
				 * transaction association then we will probably get a failure
				 * during start with XAER_DUPID. We know this must be due to
				 * another server, since we keep track of our own registrations.
				 * So, if this happens we create a new transaction branch and
				 * try again.
				 *
				 * To save time we could always just create branches by default.
				 *
				 * Is there a benefit to a zero branch?
				 */
				while (!associatedWork)
				{
					try
					{
						if (_xaTransactionTimeoutEnabled)
						{
							int timeout = _theTransaction.getTimeout();

							if (timeout > 0) 	 / 604800
								try
								{
									xaRes.setTransactionTimeout(timeout);
XAResourceWrapperImpl@de37243[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@12134c7f pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]
/s,
org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.setTransactionTimeout(int) line: 204	
      return xaResource.setTransactionTimeout(flag);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.setTransactionTimeout(int) line: 395	
      return xaResource.setTransactionTimeout(seconds);
/s,
    /**
     * We don't do transaction timeouts. Returns false.
     */
org.postgresql.xa.PGXAConnection.setTransactionTimeout(int) line: 565	
        return false;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 660	
								try
								{
									xaRes.setTransactionTimeout(timeout);
/d,
								}
								catch (XAException te)
/n,
								{
                                    jtaLogger.i18NLogger.warn_transaction_arjunacore_timeouterror("TransactionImple.enlistResource",XAHelper.xidToString(xid),  XAHelper.printXAErrorCode(te), te);
								}

						int xaStartNormal = ((theModifier == null) ? 
/j,
										XAResource.TMNOFLAGS			/ 0
								: theModifier
										.xaStartParameters(XAResource.TMNOFLAGS));
				 
                        // Pay attention now, this bit is hairy. We need to add a new AbstractRecord (XAResourceRecord)
                        // to the BasicAction, which will thereafter drive its completion. However, the transaction
                        // core is not directly XA aware, so it's our job to start the XAResource. Problem is, if
                        // adding the record fails, BasicAction will never end the resource via the XAResourceRecord,
                        // so we must do so directly.  start may fail due to dupl xid or other reason, and transactions
                        // may rollback async, for which reasons we can't call add before start.
                        // The xid will change on each pass of the loop, so we need to create a new record on each pass.
                        // The add will fail in the case of multiple last resources being disallowed
                        // see JBTM-362 and JBTM-363
                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);
params=null
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createRecord(javax.transaction.xa.XAResource, java.lang.Object[], javax.transaction.xa.Xid) line: 792	
        else
        {
            return new XAResourceRecord(this, xaRes, xid, params);
/s,
	/**
	 * The params represent specific parameters we need to recreate the
	 * connection to the database in the event of a failure. If they're not set
	 * then recovery is out of our control.
	 *
	 * Could also use it to pass other information, such as the readonly flag.
	 */
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.<init>(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple, javax.transaction.xa.XAResource, javax.transaction.xa.Xid, java.lang.Object[]) line: 109	
/=
	public XAResourceRecord(TransactionImple tx, XAResource res, Xid xid,
			Object[] params)
params=null
		super(new Uid(), null, ObjectType.ANDPERSISTENT);
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord(com.arjuna.ats.arjuna.coordinator.AbstractRecord).<init>(com.arjuna.ats.arjuna.common.Uid, java.lang.String, int) line: 588	
		super(otype);
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord(com.arjuna.ats.arjuna.StateManager).<init>(int) line: 801	
        this(ot, ObjectModel.SINGLE);
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord(com.arjuna.ats.arjuna.StateManager).<init>(int, int) line: 806
/=
    protected StateManager (int ot, int om)	
        objectModel = om;
        currentStatus = (((objectModel == ObjectModel.SINGLE) && (ot == ObjectType.RECOVERABLE)) ? ObjectStatus.ACTIVE
                : ObjectStatus.PASSIVE_NEW);
PASSIVE_NEW
        initialStatus = currentStatus; / PASSIVE_NEW
        myType = ot; / ANDPERSISTENT

        objectUid = new Uid();

        if (tsLogger.logger.isTraceEnabled()) {
/n,
            tsLogger.logger.trace("StateManager::StateManager( " + ot + ", " + om + " )");
        }
    }
/t,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord(com.arjuna.ats.arjuna.coordinator.AbstractRecord).<init>(com.arjuna.ats.arjuna.common.Uid, java.lang.String, int) line: 590
/=
	protected AbstractRecord (Uid storeUid, String objType, int otype)
	
		super(otype); / ANDPERSISTENT
/s,
		next = null;
		previous = null;
		uidOfObject = storeUid;	/ 0:ffffc0a82b4c:-36c28205:5ac39a4d:f9
		typeOfObject = objType;	 / null

		if (tsLogger.logger.isTraceEnabled()) {
            tsLogger.logger.trace("AbstractRecord::AbstractRecord ("
                    + storeUid + ", " + otype + ")");
        }
/t,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.<init>(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple, javax.transaction.xa.XAResource, javax.transaction.xa.Xid, java.lang.Object[]) line: 111	
		super(new Uid(), null, ObjectType.ANDPERSISTENT);
/d,


/ we zien objectUid, en uidOfObject, 
/ TODO
		if (jtaLogger.logger.isTraceEnabled()) {
/n,
            jtaLogger.logger.trace("XAResourceRecord.XAResourceRecord ( " + xid + ", " + res + " ), record id=" + order());
        }

		_theXAResource = res;
        if(_xaResourceRecordWrappingPlugin != null) {
/ja,
            _xaResourceRecordWrappingPlugin.transcribeWrapperData(this);
/s,
com.arjuna.ats.internal.jbossatx.jta.XAResourceRecordWrappingPluginImpl.transcribeWrapperData(com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord) line: 63	
		XAResource xaResource = (XAResource) record.value();

		if (xaResource instanceof XAResourceWrapper) {
			XAResourceWrapper xaResourceWrapper = (XAResourceWrapper) xaResource;
			record.setProductName(xaResourceWrapper.getProductName());	/ _productName=PostgreSQL
			record.setProductVersion(xaResourceWrapper.getProductVersion()); / 9.6.5
			record.setJndiName(xaResourceWrapper.getJndiName()); / java:jboss/datasources/PostgreSQLDS
/t,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.<init>(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple, javax.transaction.xa.XAResource, javax.transaction.xa.Xid, java.lang.Object[]) line: 125	
           _xaResourceRecordWrappingPlugin.transcribeWrapperData(this);
        }
/d,
		_recoveryObject = null;
		_tranID = xid; 
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >

/ de XID komt dus in het XAResourceRecord terecht, als _tranID,
/ maar ook de tx komt er in terecht, hier beneden, als _theTransaction	,
/ dit is WH voor recovery; 

/ belangrijk is dat de xid in de XAResource wordt set, straks, bij XAResource.start,

		_valid = true;

		if (params != null)
/n,
		{
			if (params.length >= XACONNECTION)
			{
				if (params[XACONNECTION] instanceof RecoverableXAConnection)
					_recoveryObject = (RecoverableXAConnection) params[XACONNECTION];
			}
		}

		_prepared = false;
		_heuristic = TwoPhaseOutcome.FINISH_OK;

		_theTransaction = tx;			
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >

this	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=20920)	
	_committed	false	
	_heuristic	7	/ 	TwoPhaseOutcome.FINISH_OK
	_jndiName	/ java:jboss/datasources/PostgreSQLDS
	_prepared	false	
	_productName	/ PostgreSQL	
	_productVersion	/ 9.6.5	
	_recovered	false	
	_recoveryObject	null	
	_theTransaction	null	
	_theXAResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=20760)	
XAResourceWrapperImpl[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@12134c7f pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]	
	_tranID	com.arjuna.ats.jta.xa.XidImple  (id=20825)	
_tranID	< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >
	_valid	true	
	activated	false	
	currentlyActivated	false	
	currentStatus	1	
	deferredExceptions	null	
	initialStatus	1	
	modifyingActions	null	
	mutex	java.util.concurrent.locks.ReentrantLock  (id=20923)	
	myType	1	
	next	null	
	objectModel	0	
	objectUid	com.arjuna.ats.arjuna.common.Uid  (id=20924)	/ 0:ffffc0a82b4c:-36c28205:5ac39a4d:fa
	participantStore	null	
	previous	null	
	serializableXAResourceDeserializers	null	
	storeRoot	null	
	typeOfObject	null	
	uidOfObject	com.arjuna.ats.arjuna.common.Uid  (id=20922) / 0:ffffc0a82b4c:-36c28205:5ac39a4d:f9	
	usingActions	null	

/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 661	
                        // Pay attention now, this bit is hairy. We need to add a new AbstractRecord (XAResourceRecord)
                        // to the BasicAction, which will thereafter drive its completion. However, the transaction
                        // core is not directly XA aware, so it's our job to start the XAResource. Problem is, if
                        // adding the record fails, BasicAction will never end the resource via the XAResourceRecord,
                        // so we must do so directly.  start may fail due to dupl xid or other reason, and transactions
                        // may rollback async, for which reasons we can't call add before start.
                        // The xid will change on each pass of the loop, so we need to create a new record on each pass.
                        // The add will fail in the case of multiple last resources being disallowed
                        // see JBTM-362 and JBTM-363
                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);
/d,
                        if(abstractRecord != null) {
                            xaRes.start(xid, xaStartNormal);
							
/ we start de XAResource	, 
/ niet de tx, 

/s,
org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.start(javax.transaction.xa.Xid, int) line: 215	
      xaResource.start(xid, flags);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 245	
      lock();
      try
      {
         try
         {
            checkState();
         }
         catch (SQLException e)
         {
            getLog().errorCheckingState(e);
         }

         try
         {
            xaResource.start(xid, flags);
         }
         catch (XAException e)
/s,
org.postgresql.xa.PGXAConnection.start(javax.transaction.xa.Xid, int) line: 206	
/=
    /**** XAResource interface ****/

    /**
     * Preconditions:
     * 1. flags must be one of TMNOFLAGS, TMRESUME or TMJOIN
     * 2. xid != null
     * 3. connection must not be associated with a transaction
     * 4. the TM hasn't seen the xid before
     *
     * Implementation deficiency preconditions:
     * 1. TMRESUME not supported.
     * 2. if flags is TMJOIN, we must be in ended state,
     *    and xid must be the current transaction
     * 3. unless flags is TMJOIN, previous transaction using the 
     *    connection must be committed or prepared or rolled back
     * 
     * Postconditions:
     * 1. Connection is associated with the transaction
     */
    public void start(Xid xid, int flags) throws XAException {
        if (logger.logDebug())
            debug("starting transaction xid = " + xid);
/ TODO LOG 
        // Check preconditions
        if (flags != XAResource.TMNOFLAGS && flags != XAResource.TMRESUME && flags != XAResource.TMJOIN)
/n,
flags=XAResource.TMNOFLAGS
            throw new PGXAException(GT.tr("Invalid flags"), XAException.XAER_INVAL);

        if (xid == null)
            throw new PGXAException(GT.tr("xid must not be null"), XAException.XAER_INVAL);

        if (state == STATE_ACTIVE)
/n, state=STATE_IDLE
            throw new PGXAException(GT.tr("Connection is busy with another transaction"), XAException.XAER_PROTO);

        // We can't check precondition 4 easily, so we don't. Duplicate xid will be catched in prepare phase.

        // Check implementation deficiency preconditions
        if (flags == TMRESUME)
            throw new PGXAException(GT.tr("suspend/resume not implemented"), XAException.XAER_RMERR);

        // It's ok to join an ended transaction. WebLogic does that.
        if (flags == TMJOIN)
        {
            if (state != STATE_ENDED)
                throw new PGXAException(GT.tr("Transaction interleaving not implemented"), XAException.XAER_RMERR);

            if (!xid.equals(currentXid))
                throw new PGXAException(GT.tr("Transaction interleaving not implemented"), XAException.XAER_RMERR);
        } else if(state == STATE_ENDED)
            throw new PGXAException(GT.tr("Transaction interleaving not implemented"), XAException.XAER_RMERR);

        try
        {
            localAutoCommitMode = conn.getAutoCommit();
true
            conn.setAutoCommit(false);
        }
        catch (SQLException ex)
        {
            throw new PGXAException(GT.tr("Error disabling autocommit"), ex, XAException.XAER_RMERR);
        }

        // Preconditions are met, Associate connection with the transaction
/ dwz geeft de con de xid, de tx id,
        state = STATE_ACTIVE;
        currentXid = xid;				<-
		
/ de XID wordt set in de XAResource,


/ Intermezzo

/ lees,
https://docs.oracle.com/cd/A97630_01/java.920/a96654/xadistra.htm

/ branch:
A distributed transaction, sometimes referred to as a global transaction, is a set of two or more related transactions that must be managed in a coordinated way. The transactions that constitute a distributed transaction might be in the same database, but more typically are in different databases and often in different locations. Each individual transaction of a distributed transaction is referred to as a transaction branch.

/ xid,
The OracleXAResource class has several methods to coordinate a transaction branch with the distributed transaction with which it is associated. This functionality usually involves two-phase COMMIT operations.

A transaction manager, receiving OracleXAResource instances from a middle-tier component such as an application server, typically invokes this functionality.

Each of these methods takes a transaction ID as input, in the form of an Xid instance, which includes a transaction branch ID component and a distributed transaction ID component. Every transaction branch has a unique transaction ID, but transaction branches belonging to the same global transaction have the same global transaction component as part of their transaction IDs.

"XA ID Interface and Oracle Implementation" discusses the OracleXid class and the standard interface upon which it is based.

Following is a description of key XA resource functionality, the methods used, and additional input parameters. Each of these methods throws an XA exception if an error is encountered. See "XA Exception Classes and Methods".



/ Einde Intermezzo	

/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 275
         try
         {
            xaResource.start(xid, flags);
\d,
         }
         synchronized (stateLock)
         {
            currentXid = xid;
            inManagedTransaction = true;
         }
		 
/ Dus de XID wordt set in de XAResource = PGXAConnection (pg), en in de XAManagedConnection (jca)	,
	
	
this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
	currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20825)		/ nu ook hier,
	inManagedTransaction	true	
	xaConnection	org.postgresql.xa.PGXAConnection  (id=20487)	
	xaResource	org.postgresql.xa.PGXAConnection  (id=20487)	
		currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20825)	/ al, zonet,

      finally
      {
         unlock();
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 663	
                            xaRes.start(xid, xaStartNormal);
/d,
                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {
							
/ _theTransaction=BasicAction

/s,	
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).add(com.arjuna.ats.arjuna.coordinator.AbstractRecord) line: 315	
            if (pendingList == null)
/j,
                pendingList = new RecordList();

            result = (pendingList.insert(A) ? AddOutcome.AR_ADDED
/j,
                    : AddOutcome.AR_DUPLICATE);
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 663	
                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {
/j,
                                _resources.put(xaRes, new TxInfo(xid));
								return true; // dive out, no need to set associatedWork = true;
/ Herinner,
			/*
			 * For each transaction we maintain a list of resources registered
			 * with it. Each element on this list also contains a list of
			 * threads which have registered this resource, and what their XID
			 * was for that registration.
			 */
/s,
com.arjuna.ats.internal.jta.xa.TxInfo.<init>(javax.transaction.xa.Xid) line: 52	
        this(xid, TxInfo.ASSOCIATED);
    }
/s,
    public TxInfo (Xid xid, int state)
    {
	_xid = xid;
	_thread = Thread.currentThread();

	setState(state);
    }
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 1005	
            if (!currentTx.enlistResource(resource))
/d,

/ Intermezzo

/ we zien inderdaad de xid NIET bij de tx, maar in de xaresource	,

this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=21584)	
	currentTx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
		_resources	java.util.Hashtable<K,V>  (id=17918)	
			table	java.util.Hashtable$Entry<K,V>[11]  (id=21697)	
				[9]	java.util.Hashtable$Entry<K,V>  (id=21698)	
					key	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=21501)	
						xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21458)	
							con	com.sun.proxy.$Proxy54  (id=21510)	
							currentXid	com.arjuna.ats.jta.xa.XidImple  (id=21606)	
							xaResource	org.postgresql.xa.PGXAConnection  (id=21523)	
								con	org.postgresql.jdbc42.Jdbc42Connection  (id=21527)	
								currentXid	com.arjuna.ats.jta.xa.XidImple  (id=21606)	
					value	com.arjuna.ats.internal.jta.xa.TxInfo  (id=21695)	
						_thread	java.lang.Thread  (id=17724)	
						_xid	com.arjuna.ats.jta.xa.XidImple  (id=21606) / < formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-2c619851:5ad7638e:1189, node_name=1, branch_uid=0:ffffc0a82b4c:-2c619851:5ad7638e:1196, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >	
		_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=17908)	
			_synchs	java.util.TreeSet<E>  (id=19945)	/ TODO
			/ GEEN xid,
			




/ Einde Intermezzo




            if (Tracer.isEnabled())
/ TODO LOG 
            enlisted = true;

            log.tracef("Enlisted resource %s", TxConnectionListener.this);
/ TODO LOG 
            return true;
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 381	
               if (sync.enlist())
/d,

sync	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=21584)	
	currentTx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=17907)	
	enlisted	true	
	recordEnlist	true	


               {
                  synchronizer.addEnlisted(sync);
				  
synchronizer	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=21096)
	enlisted	java.util.ArrayList<E>  (id=21101)	
[TransactionSynchronization@554471675{tx=TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:e7 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]

/ Intermezzo

/ eerder	,
            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());

/ dus synchronizer is een local, maar WH 'n static in class TransactionSynchronizer

/ Einde Intermezzo

         finally
         {
            synchronizer.enlisted();
/s,
   /**
    * This thread has finished enlisting.
    */
   public synchronized void enlisted()
   {
      Thread currentThread = Thread.currentThread();

      if (enlistingThread == null || enlistingThread != currentThread)
      {
/n,
         log.threadIsnotEnlistingThread(currentThread, enlistingThread, 
            new Exception("STACKTRACE"));
         return;
      }

      enlistingThread = null;
      notifyAll();
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 392	
            synchronizer.enlisted();
/d,
         }
      }

      // What was the result of our enlistment?
      log.tracef("Check enlisted %s threadTx=%s", this, threadTx);
/ TODO LOG 
      ourSynchronization.checkEnlisted();
      setEnlisted(true);
this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20713)	
	enlisted	true	
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 562	
            cl.enlist();
/d,
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 753	
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/d,
      // Ask the managed connection for a connection
      Object connection = null;
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 458	
      return getWrappedConnection();
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getWrappedConnection() line: 1193	
      WrappedConnection lc = WRAPPED_CONNECTION_FACTORY.createWrappedConnection(this,
                                                                                mcf.getSpy().booleanValue(),
                                                                                mcf.getJndiName(),
                                                                                mcf.isDoLocking());

this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
	currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20825)	
	xaConnection	org.postgresql.xa.PGXAConnection  (id=20487)	
	xaResource	org.postgresql.xa.PGXAConnection  (id=20487)	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionFactoryJDK7.createWrappedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection, boolean, java.lang.String, boolean) line: 60	
      return new WrappedConnectionJDK7(mc, spy, jndiName, doLocking);
mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
spy	true	
jndiName	"java:jboss/datasources/PostgreSQLDS" (id=20763)	
doLocking	true	
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getWrappedConnection() line: 1197	
      WrappedConnection lc = WRAPPED_CONNECTION_FACTORY.createWrappedConnection(this,
                                                                                mcf.getSpy().booleanValue(),
                                                                                mcf.getJndiName(),
                                                                                mcf.isDoLocking());
/d,

this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
lc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
	doLocking	true	
	jndiName	"java:jboss/datasources/PostgreSQLDS" (id=20763)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
	spy	true	

      synchronized (handles)
      {
         handles.add(lc);
      return lc;
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 773	
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);
/d,
      // Associate managed connection with the connection
      registerAssociation(cl, connection);  connection=org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7@31167b0e
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).registerAssociation(org.jboss.jca.core.connectionmanager.listener.ConnectionListener, java.lang.Object) line: 990	
      cl.registerConnection(c);
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener(org.jboss.jca.core.connectionmanager.listener.AbstractConnectionListener).registerConnection(java.lang.Object) line: 319	
/=
   public void registerConnection(Object handle)
this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20713)	
handle	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
      if (handle != null)
      {
         connectionHandles.add(handle);
		 
this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20713)	
	connectionHandles	java.util.concurrent.CopyOnWriteArraySet<E>  (id=20716)	
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 777	
      // Associate managed connection with the connection
      registerAssociation(cl, connection);
/d,
      if (cachedConnectionManager != null)
      {
         cachedConnectionManager.registerConnection(this, cl, connection);
		 
this	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=20477)	
cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20713)	
connection	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
/s,
org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl.registerConnection(org.jboss.jca.core.api.connectionmanager.listener.ConnectionCacheListener, org.jboss.jca.core.api.connectionmanager.listener.ConnectionListener, java.lang.Object) line: 312	

      KeyConnectionAssociation key = peekMetaAwareObject();
/s,
org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl.peekMetaAwareObject() line: 264	
      LinkedList<KeyConnectionAssociation> stack = currentObjects.get();

      if (stack != null && !stack.isEmpty())
      {
         return stack.getLast();
/t,
org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl.registerConnection(org.jboss.jca.core.api.connectionmanager.listener.ConnectionCacheListener, org.jboss.jca.core.api.connectionmanager.listener.ConnectionListener, java.lang.Object) line: 312	

      KeyConnectionAssociation key = peekMetaAwareObject();
/d,
         ConnectionRecord cr = new ConnectionRecord(cl, connection);
         ConcurrentMap<ConnectionCacheListener, CopyOnWriteArrayList<ConnectionRecord>> cmToConnectionsMap =
            key.getCMToConnectionsMap();
/s,
org.jboss.jca.core.connectionmanager.ccm.KeyConnectionAssociation.getCMToConnectionsMap() line: 104	
      if (cmToConnectionsMap == null)
         cmToConnectionsMap = new ConcurrentHashMap<ConnectionCacheListener, CopyOnWriteArrayList<ConnectionRecord>>();
/t,
org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl.registerConnection(org.jboss.jca.core.api.connectionmanager.listener.ConnectionCacheListener, org.jboss.jca.core.api.connectionmanager.listener.ConnectionListener, java.lang.Object) line: 312	
         ConcurrentMap<ConnectionCacheListener, CopyOnWriteArrayList<ConnectionRecord>> cmToConnectionsMap =
            key.getCMToConnectionsMap();
/d,
         CopyOnWriteArrayList<ConnectionRecord> conns = cmToConnectionsMap.get(cm);
         if (conns == null)
         {
            conns = new CopyOnWriteArrayList<ConnectionRecord>();
            cmToConnectionsMap.put((ConnectionCacheListener)cm, conns);
         }

         conns.add(cr);

this	org.jboss.jca.core.connectionmanager.ccm.CachedConnectionManagerImpl  (id=21348)	
	currentObjects	java.lang.ThreadLocal<T>  (id=21353)	
		.get().getLast()=
key	org.jboss.jca.core.connectionmanager.ccm.KeyConnectionAssociation  (id=21398)	
	cmToConnectionsMap	java.util.concurrent.ConcurrentHashMap<K,V>  (id=21415)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=21417)	
			[14]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=21421)	
				key	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=20477)	
				val	java.util.concurrent.CopyOnWriteArrayList<E>  (id=21416)	
					array	java.lang.Object[1]  (id=21422)	
						[0]	org.jboss.jca.core.connectionmanager.ConnectionRecord  (id=21404)	
							connection	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
							connectionListener	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20713)	
	metaAwareObject	org.jboss.as.connector.deployers.ra.processors.CachedConnectionManagerSetupProcessor$CachedConnectionManagerSetupAction  (id=21374)	
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 780	
         cachedConnectionManager.registerConnection(this, cl, connection);
/d,
      }

      return connection;	  
connection	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
	doLocking	true	
	jndiName	"java:jboss/datasources/PostgreSQLDS" (id=20763)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
	spy	true	
/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 139	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/d,

wc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21925)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21458)	
		currentXid	com.arjuna.ats.jta.xa.XidImple  (id=21606)	
		xaResource	org.postgresql.xa.PGXAConnection  (id=21523)	


         wc.setDataSource(this);	/ dataSource==this heeft pool, maar de conn is daar al uitgehaald WH	,
         wc.setSpy(mcf.getSpy().booleanValue());
         wc.setJndiName(mcf.getJndiName());
         return wc;
wc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
	dataSource	org.jboss.jca.adapters.jdbc.WrapperDataSource  (id=20478)	
	jndiName	"java:jboss/datasources/PostgreSQLDS" (id=20763)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
		currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20825)	
		transactionIsolation	2	
		xaResource	org.postgresql.xa.PGXAConnection  (id=20487)	
/t,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
        return delegate.getConnection();
/d,
/t,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/d,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
				return connectionProvider.getConnection();
/d,
			}
			finally {
				listener.jdbcConnectionAcquisitionEnd();
/ NIETS,
/t,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
			try {
				physicalConnection = jdbcConnectionAccess.obtainConnection();
/d,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7@31167b0e
			finally {
				observer.jdbcConnectionAcquisitionEnd( physicalConnection );
/ 1 observer=org.hibernate.internal.AbstractSessionImpl$JdbcObserverImpl@62c3c987	, maar doet NIETS, want we hebben geen statistics ... TODO

		return physicalConnection;
/t,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
		return acquireConnectionIfNeeded();
	}
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
		return logicalConnection().getPhysicalConnection();
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/pd,

/ connection created,

/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 443	
      if (doLocking)
         lock();
      try
      {
         checkTransaction();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransaction() line: 1917	
      checkStatus();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkStatus() line: 1943	
      if (closed)
         throw new SQLException(bundle.connectionClosed());
      if (mc == null)
         throw new SQLException(bundle.connectionNotAssociated(this.toString()));
      checkTransactionActive();
/s,
   /**
    * Check whether a tranasction is active
    *
    * @throws SQLException if the transaction is not active, preparing, prepared or committing or
    *                      for any error in the transaction manager
    */
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransactionActive() line: 1928

this	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=21292)	
	dataSource	org.jboss.jca.adapters.jdbc.WrapperDataSource  (id=20478) 
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	/ zonet created, 
	
      if (dataSource == null)
         return;
      dataSource.checkTransactionActive();
/s,
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 228	
      if (!mcf.isJTA().booleanValue())
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnectionFactory).isJTA() line: 1041	
      return jta;

this	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=20484)	
	jta	java.lang.Boolean  (id=21104) true	
	
/ MCF = managed connection factory,

/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 233	
      if (!mcf.isJTA().booleanValue())
/d,
/n,
         return;

      try
      {
         int status = Status.STATUS_NO_TRANSACTION;

         if (mcf.getTransactionSynchronizationRegistry() != null)
            status = mcf.getTransactionSynchronizationRegistry().getTransactionStatus();
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnectionFactory).getTransactionSynchronizationRegistry() line: 1060	
      return jdbcRA.getTransactionSynchronizationRegistry();
/s,
org.jboss.jca.adapters.jdbc.JDBCResourceAdapter.getTransactionSynchronizationRegistry() line: 105	
      // Non-JTA datasources doesn't need a BootstrapContext instance
      if (bc != null)
      {
         return bc.getTransactionSynchronizationRegistry();
		 
this	org.jboss.jca.adapters.jdbc.JDBCResourceAdapter  (id=21648)	
	bc	org.jboss.as.connector.services.bootstrap.NamedBootstrapContext  (id=21657)	
		name	"default" (id=21659)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20701)	
/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 236	
         if (mcf.getTransactionSynchronizationRegistry() != null)
            status = mcf.getTransactionSynchronizationRegistry().getTransactionStatus();
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionStatus() line: 91	
        return delegate.getTransactionStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionStatus() line: 157	
        try
        {
            return tm.getStatus();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
        return transactionManager.getStatus() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1057	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:e7 status: ActionStatus.RUNNING

/ Intermezzo

/ we zien dat BasicAction.Current() de global jta tx is,

			currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20825)
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >	

/ Einde Intermezzo

		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
			if (tx == null)
				tx = new TransactionImple(current);
		}

		return tx;
		
/ Intermezzo

/ wrappers	, delegate,

/ we zijn in stack,

com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1057	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionStatus() line: 157	
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getTransactionStatus() line: 91	
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 236	

/ Einde Intermezzo

/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 169	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/d,
		if (theTransaction == null)
			return javax.transaction.Status.STATUS_NO_TRANSACTION;
		else
			return theTransaction.getStatus();
			
/ Intermezzo

/ we zien dat theTransaction de global jta tx is: dat zien we als we hem print (toString()) bovenin	, maar ook in _theTransaction.objectUid,
/ maar in de resources zien we de branch uid, 
			
theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=20665)
TransactionImple < ac, BasicAction: 0:ffffc0a82b4c:-36c28205:5ac39a4d:e7 status: ActionStatus.RUNNING >	
	_resources	java.util.Hashtable<K,V>  (id=20784)	
		table	java.util.Hashtable$Entry<K,V>[11]  (id=21748)	
			[8]	java.util.Hashtable$Entry<K,V>  (id=21751)	
				key	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=20760)	
					xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20489)	
						currentXid	com.arjuna.ats.jta.xa.XidImple  (id=20825)
							_theXid	com.arjuna.ats.internal.jta.xa.XID  (id=20863)	
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:e7, node_name=1, branch_uid=0:ffffc0a82b4c:-36c28205:5ac39a4d:f5, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >						
						xaResource	org.postgresql.xa.PGXAConnection  (id=20487)	
				value	com.arjuna.ats.internal.jta.xa.TxInfo  (id=21094)	
					_state	0	
					_thread	java.lang.Thread  (id=94)	
					_xid	com.arjuna.ats.jta.xa.XidImple  (id=20825)	
						_theXid	com.arjuna.ats.internal.jta.xa.XID  (id=20863)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=20667)	
		objectUid	com.arjuna.ats.arjuna.common.Uid  (id=20824) 
0:ffffc0a82b4c:-36c28205:5ac39a4d:e7										/ global jta tx,
	_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=21110)	
				[6]	java.util.HashMap$Node<K,V>  (id=22064)	
					key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=20483)	
					value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20713)	
				[10]	java.util.HashMap$Node<K,V>  (id=22067)	
					key	org.jboss.jca.core.connectionmanager.transaction.LockKey  (id=22120)	
					value	java.util.concurrent.locks.ReentrantLock  (id=22121)	
				[13]	java.util.HashMap$Node<K,V>  (id=22069)	
					next	java.util.HashMap$Node<K,V>  (id=22103)	
						key	"test.war#arquillian-forge4-persistence-unit" (id=22137)	
						value	org.hibernate.jpa.internal.EntityManagerImpl  (id=20695)	
					value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=22104)	

/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 349	
		int status = javax.transaction.Status.STATUS_NO_TRANSACTION;
		
		if (_theTransaction != null)
		{
			status = StatusConverter.convert(_theTransaction.status());
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 44	
		switch (status)
		{
		case ActionStatus.RUNNING:
			return javax.transaction.Status.STATUS_ACTIVE;
...
/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.checkTransactionActive() line: 238	
         if (mcf.getTransactionSynchronizationRegistry() != null)
            status = mcf.getTransactionSynchronizationRegistry().getTransactionStatus();
/d,
         // Only allow states that will actually succeed
         if (status != Status.STATUS_ACTIVE && status != Status.STATUS_PREPARING &&
             status != Status.STATUS_PREPARED && status != Status.STATUS_COMMITTING)
/n,
         {
            throw new SQLException(bundle.transactionCannotProceed(TxUtils.getStatusAsString(status)));
         }			
...
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransaction() line: 1918	
      checkStatus();
/d,
      mc.checkTransaction();						
   /**
    * The <code>checkTransaction</code> method makes sure the adapter follows the JCA
    * autocommit contract, namely all statements executed outside a container managed transaction
    * or a component managed transaction should be autocommitted. To avoid continually calling
    * setAutocommit(enable) before and after container managed transactions, we keep track of the state
    * and check it before each transactional method call.
    * @exception SQLException Thrown if an error occurs
    */
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).checkTransaction() line: 900	
/=
   void checkTransaction() throws SQLException
   {
      synchronized (stateLock)
      {
         if (inManagedTransaction)
            return;
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 450	
         checkTransaction();
/d,
         try
         {
            if (spy)
               spyLogger.debugf("%s [%s] prepareStatement(%s)",
                                jndiName, Constants.SPY_LOGGER_PREFIX_CONNECTION, sql);

            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 704	


/ Intermezzo

/ we zijn nog in,

org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	

		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
			return performSave( entity, generatedId, persister, false, anything, source, true );
			
/ we zijn nu nog in persister.getIdentifierGenerator().generate( source, entity )	,

/ Einde Intermezzo

      else
      {
         return doPrepareStatement(sql, resultSetType, resultSetConcurrency);
sql=select nextval ('hibernate_sequence')
resultSetType=ResultSet.TYPE_FORWARD_ONLY,
resultSetConcurrency=ResultSet.CONCUR_READ_ONLY),
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);
/s,
    /**** XAConnection interface ****/
    /*
     * A java.sql.Connection proxy class to forbid calls to transaction
     * control methods while the connection is used for an XA transaction.
     */
    private class ConnectionHandler implements InvocationHandler
    {
	private Connection con;

        public Object invoke(Object proxy, Method method, Object[] args)
/=
org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 148	
	    if (state != STATE_IDLE)
/n,
            {
                String methodName = method.getName();
                if (methodName.equals("commit") ||
                    methodName.equals("rollback") ||
                    methodName.equals("setSavePoint") ||
                    (methodName.equals("setAutoCommit") && (Boolean) args[0]))
                {
		    throw new PSQLException(GT.tr("Transaction control methods setAutoCommit(true), commit, rollback and setSavePoint not allowed while an XA transaction is active."),
					    PSQLState.OBJECT_NOT_IN_STATE);
                }
            }
                return method.invoke(con, args);
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 261	
                else if (methodName.equals("prepareCall"))
/n,
                {
                    Statement st = (Statement)method.invoke(con, args);
                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{CallableStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));
                }
                else if (methodName.equals("prepareStatement"))
/j,
                {
                    Statement st = (Statement)method.invoke(con, args); 				/ vertaalt jdbc query naar native query,
                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{PreparedStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));
                }
                else
/n,
                {
                    return method.invoke(con, args);
                }
/s,
/ wat je moet doen is als je in een Java method valt, meteen 'step out',
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).prepareStatement(java.lang.String, int, int) line: 281	
        checkClosed();
        return prepareStatement(sql, resultSetType, resultSetConcurrency, getHoldability());
/s,
    /**
     * Retrieves the current holdability of <code>ResultSet</code> objects
     * created using this <code>Connection</code> object.
     *
     * @return the holdability, one of
     *    <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
     *    <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @throws SQLException if a database access occurs
     * @see #setHoldability
     * @see ResultSet
     * @since 1.4
     */
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).getHoldability() line: 86	
        return rsHoldability;	/ ResultSet.CLOSE_CURSORS_AT_COMMIT;
/t,
/s,
org.postgresql.jdbc42.Jdbc42Connection.prepareStatement(java.lang.String, int, int, int) line: 39	
        checkClosed();
        return new Jdbc42PreparedStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
...
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 194

/ Intermezzo

/ zie

org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 346
org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 178	

/ we zijn in,

org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 194	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc3.AbstractJdbc3Statement).<init>(org.postgresql.jdbc3.AbstractJdbc3Connection, java.lang.String, boolean, int, int, int) line: 49	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc3g.AbstractJdbc3gStatement).<init>(org.postgresql.jdbc3.AbstractJdbc3Connection, java.lang.String, boolean, int, int, int) line: 29	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc4.AbstractJdbc4Statement).<init>(org.postgresql.jdbc4.AbstractJdbc4Connection, java.lang.String, boolean, int, int, int) line: 33	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.AbstractJdbc42Statement).<init>(org.postgresql.jdbc42.AbstractJdbc42Connection, java.lang.String, boolean, int, int, int) line: 27	
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.Jdbc42Statement).<init>(org.postgresql.jdbc42.AbstractJdbc42Connection, java.lang.String, boolean, int, int, int) line: 31	
org.postgresql.jdbc42.Jdbc42PreparedStatement.<init>(org.postgresql.jdbc42.Jdbc42Connection, java.lang.String, boolean, int, int, int) line: 21	
org.postgresql.jdbc42.Jdbc42PreparedStatement.<init>(org.postgresql.jdbc42.Jdbc42Connection, java.lang.String, int, int, int) line: 16	
org.postgresql.jdbc42.Jdbc42Connection.prepareStatement(java.lang.String, int, int, int) line: 40	
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).prepareStatement(java.lang.String, int, int) line: 282	
sun.reflect.GeneratedMethodAccessor21.invoke(java.lang.Object, java.lang.Object[]) line: not available	
sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 346	
com.sun.proxy.$Proxy54.prepareStatement(java.lang.String, int, int) line: not available	
sun.reflect.GeneratedMethodAccessor21.invoke(java.lang.Object, java.lang.Object[]) line: not available	
sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 178	
com.sun.proxy.$Proxy54.prepareStatement(java.lang.String, int, int) line: not available	
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 743	
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94	
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	

/ Einde Intermezzo

        this.connection = connection;
this	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
	protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22616)	
		pgStream	org.postgresql.core.PGStream  (id=22794)	
			connection	java.net.Socket  (id=22804)	
			pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=22808)	
			pg_output	java.io.BufferedOutputStream  (id=22809)	

        this.lastSimpleQuery = null;

        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).borrowQuery(java.lang.String, boolean) line: 100	
        Object key = isCallable ? new CallableQueryKey(sql) : sql;
/n,
select nextval ('hibernate_sequence')
	
this	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
	statementCache	org.postgresql.util.LruCache<Key,Value>  (id=22628)	
		cache	org.postgresql.util.LruCache$1  (id=22633)	
			size	1	
			table	java.util.HashMap$Node<K,V>[16]  (id=22641)	
				[10]	java.util.LinkedHashMap$Entry<K,V>  (id=22640)	
					key	"insert into Language (name, version, id) values (?, ?, ?)" (id=22647)	
					value	org.postgresql.core.CachedQuery  (id=22648)	
						key	"insert into Language (name, version, id) values (?, ?, ?)" (id=22647)	
						query	org.postgresql.core.v3.SimpleQuery  (id=22651)	
							nativeQuery	org.postgresql.core.NativeQuery  (id=22657)	
								bindPositions	(id=22664)	
									[0]	49				/ TODO
									[1]	53	
									[2]	57	
								nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=22665)

       return statementCache.borrow(key);
/s,
org.postgresql.util.LruCache<Key,Value>.borrow(Key) line: 94	
        Value value = cache.remove(key);
        if (value == null)
/j,
            return createAction.create(key); / key="select nextval ('hibernate_sequence')"	
/s,
org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 35	
        String sql = key == null ? null : key.toString();
        String parsedSql = AbstractJdbc2Statement.replaceProcessing(sql, true, connection.getStandardConformingStrings());
/ connection.getStandardConformingStrings()==true
/s,
    /*
     * Filter the SQL string of Java SQL Escape clauses.
     *
     * Currently implemented Escape clauses are those mentioned in 11.3
     * in the specification. Basically we look through the sql string for
     * {d xxx}, {t xxx}, {ts xxx}, {oj xxx} or {fn xxx} in non-string sql 
     * code. When we find them, we just strip the escape part leaving only
     * the xxx part.
     * So, something like "select * from x where d={d '2001-10-09'}" would
     * return "select * from x where d= '2001-10-09'".
     */
    static String replaceProcessing(String p_sql, boolean replaceProcessingEnabled, boolean standardConformingStrings) throws SQLException
/ TODO
/t,
org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 38	
        String parsedSql = AbstractJdbc2Statement.replaceProcessing(sql, true, connection.getStandardConformingStrings());
/d,
select nextval ('hibernate_sequence')

        if (key instanceof CallableQueryKey)
/n,
        {
            JdbcCallParseInfo callInfo = Parser.modifyJdbcCall(parsedSql, connection.getStandardConformingStrings(), serverVersionNum, connection.getProtocolVersion());
            parsedSql = callInfo.getSql();
            isFunction = callInfo.isFunction();
            outParmBeforeFunc = callInfo.isOutParmBeforeFunc();
        } else
/j,
        {
            isFunction = false;
            outParmBeforeFunc = false;
        }
        Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql);
/s,
    /**
     * Parses JDBC query into PostgreSQL's native format. Several queries might be given if separated by semicolon.
     * @param query jdbc query to parse
     * @param standardConformingStrings whether to allow backslashes to be used as escape characters in single quote literals
     * @param withParameters whether to replace ?, ? with $1, $2, etc
     * @param splitStatements whether to split statements by semicolon
     * @return list of native queries
     */
    public static List<NativeQuery> parseJdbcSql(String query, boolean standardConformingStrings, boolean withParameters, boolean splitStatements)
		...
/t,
org.postgresql.core.v3.QueryExecutorImpl.parseQuery(java.lang.String, boolean) line: 117	
        List<NativeQuery> queries = Parser.parseJdbcSql(query, protoConnection.getStandardConformingStrings(), withParameters, true);
/d,
queries	java.util.Collections$SingletonList<E>  (id=17319)	
	element	org.postgresql.core.NativeQuery  (id=17321)	
		bindPositions	(id=17324)
[]		
		nativeSql	"select nextval ('hibernate_sequence')" (id=17325)
		
        if (queries.size() == 1) {
            return new SimpleQuery(queries.get(0), protoConnection);
/t,
org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 50	
        Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql);
/d,
query	org.postgresql.core.v3.SimpleQuery  (id=17333)	
	nativeQuery	org.postgresql.core.NativeQuery  (id=17321)	
		bindPositions	(id=17324)	
		nativeSql	"select nextval ('hibernate_sequence')" (id=17325)	
	protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=17314)	

        return new CachedQuery(key, query, isFunction, outParmBeforeFunc);
/t,
org.postgresql.util.LruCache<Key,Value>.borrow(Key) line: 94	
        if (value == null)
            return createAction.create(key);
/d,
/t,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).borrowQuery(java.lang.String, boolean) line: 100	
        return statementCache.borrow(key);
/d,
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 198	
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
/d,
cachedQuery	org.postgresql.core.CachedQuery  (id=22851)	
	key	"select nextval ('hibernate_sequence')" (id=22561)	
	query	org.postgresql.core.v3.SimpleQuery  (id=22853)	
		nativeQuery	org.postgresql.core.NativeQuery  (id=22854)	
			nativeSql	"select nextval ('hibernate_sequence')" (id=22855)	
/ TODO 
/ Zit NIET in connection.statementCache,

        this.preparedQuery = cachedQuery;
        this.preparedParameters = preparedQuery.query.createParameterList();
/s,
org.postgresql.core.v3.SimpleQuery.createParameterList() line: 33	
        if (nativeQuery.bindPositions.length == 0)
            return NO_PARAMETERS; / org.postgresql.core.v3.SimpleParameterList@44848d03
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 215	

        forceBinaryTransfers |= connection.getForceBinary();
false
        resultsettype = rsType;	/ ResultSet.TYPE_FORWARD_ONLY
        concurrency = rsConcurrency;	/ ResultSet.CONCUR_READ_ONLY
        setFetchSize(connection.getDefaultFetchSize());
        setPrepareThreshold(connection.getPrepareThreshold());
/ eerder:
        setDefaultFetchSize(PGProperty.DEFAULT_ROW_FETCH_SIZE.getInt(info));	/ 0
        prepareThreshold = PGProperty.PREPARE_THRESHOLD.getInt(info);	/ 5
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 347	
                else if (methodName.equals("prepareStatement"))
                {
                    Statement st = (Statement)method.invoke(con, args); / vertaalt jdbc query naar native query,
/d,
st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=17301)	
	connection	org.postgresql.jdbc42.Jdbc42Connection  (id=17185)	
	preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=17335)	
		paramTypes	(id=17351)	
		paramValues	java.lang.Object[0]  (id=17352)	
	preparedQuery	org.postgresql.core.CachedQuery  (id=17341)	
		key	"select nextval ('hibernate_sequence')" (id=17305)	
		query	org.postgresql.core.v3.SimpleQuery  (id=17333)	
			nativeQuery	org.postgresql.core.NativeQuery  (id=17321)	
				bindPositions	(id=17324)	
				nativeSql	"select nextval ('hibernate_sequence')" (id=17325)	
			protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=17314)	

                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{PreparedStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));
/s,
    /**
     * Instead of declaring classes implementing Statement, PreparedStatement,
     * and CallableStatement, which would have to be updated for every JDK rev,
     * use a dynamic proxy to handle all calls through the Statement
     * interfaces. This is the part that requires JDK 1.3 or higher, though
     * JDK 1.2 could be supported with a 3rd-party proxy package.
     *
     * The StatementHandler is required in order to return the proper
     * Connection proxy for the getConnection method.
     */
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.<init>(org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection, org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler, java.sql.Statement) line: 399	
	...
...
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/pd,
/ TODO SQL Is de query nu compiled in postgres?
/ Intermezzo

/ lees,
https://www.postgresql.org/docs/9.3/static/sql-prepare.html

/ Einde Intermezzo
/s,
      return new WrappedPreparedStatementJDK7(this, statement, spy, jndiName, doLocking);
	  
this	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=22571)	
	mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22582)	
		xaResource	org.postgresql.xa.PGXAConnection  (id=22878)		 / welke wordt used: xaResource of con	?
		/ alle methods,
		con	com.sun.proxy.$Proxy54  (id=22587)	
			h	org.postgresql.xa.PGXAConnection$ConnectionHandler  (id=22591)
				this$0	org.postgresql.xa.PGXAConnection  (id=22878)			 / welke wordt used: this$0 of con	?
				con	com.sun.proxy.$Proxy54  (id=22596)	
					/ alle methods,
					h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler  (id=22599)	
						con	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
							protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22616)	
								pgStream	org.postgresql.core.PGStream  (id=22794)	
statement	com.sun.proxy.$Proxy91  (id=22881)
	/ alle methods,
	h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=22876)	
...
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).<init>(org.jboss.jca.adapters.jdbc.WrappedConnection, java.sql.Statement, boolean, java.lang.String, boolean, java.lang.String) line: 108	
/=
   protected WrappedStatement(final WrappedConnection lc, Statement s, final boolean spy, final String jndiName,
                              final boolean doLocking, final String spyLoggingCategory)
      this.lc = lc;
      this.s = s;
      this.spy = spy;
      this.jndiName = jndiName;
      this.doLocking = doLocking;
      this.spyLoggingCategory = spyLoggingCategory;
      this.timeoutSet = 0;

      if (defaultFetchSize != null)
/n,
/ TODO
      lc.registerStatement(this);	
/s,
      if (trackStatements == BaseWrapperManagedConnectionFactory.TRACK_STATEMENTS_FALSE_INT)
/ TODO
/n,
         return;

      synchronized (this)
      {
         if (statements == null)
/j,
            statements = new HashMap<WrappedStatement, Throwable>(1);

         if (trackStatements == BaseWrapperManagedConnectionFactory.TRACK_STATEMENTS_TRUE_INT)
/n,
            statements.put(ws, new Throwable("STACKTRACE"));
         else
/j,
            statements.put(ws, null);
      }
...
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/d,
...
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/d,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 173	
					preparedStatement = doPrepare();
/d,
				finally {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementEnd();
/s,
org.hibernate.internal.AbstractSessionImpl$JdbcObserverImpl.jdbcPrepareStatementEnd() line: 565	
			for ( ConnectionObserver observer : observers ) {
				observer.statementPrepared();
/s,
org.hibernate.internal.ConnectionObserverStatsBridge.statementPrepared() line: 42	
		if ( sessionFactory.getStatistics().isStatisticsEnabled() ) {
/n,
			sessionFactory.getStatisticsImplementor().prepareStatement();
/t,
org.hibernate.internal.AbstractSessionImpl$JdbcObserverImpl.jdbcPrepareStatementEnd() line: 567	
				observer.statementPrepared();
/d,
			}
			getEventListenerManager().jdbcPrepareStatementEnd();
/s,
org.hibernate.engine.internal.SessionEventListenerManagerImpl.jdbcPrepareStatementEnd() line: 98	
		if ( listenerList == null ) {
/j,
			return;
		}
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 178	
				finally {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementEnd();
				}
/d,
				postProcess( preparedStatement );
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).postProcess(java.sql.PreparedStatement) line: 189	
			jdbcCoordinator.getResourceRegistry().register( preparedStatement, true );

this	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=21939)	
	logicalConnection	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl  (id=22570)	
		resourceRegistry	org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl  (id=23498)
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.register(java.sql.Statement, boolean) line: 59	
		log.tracef( "Registering statement [%s]", statement );
/ TODO LOG
		if ( xref.containsKey( statement ) ) {
/n,
xref={}
			throw new HibernateException( "JDBC Statement already registered" );
		}
		xref.put( statement, null );

		if ( cancelable ) {
/j,
			lastQuery = statement;
		}
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 179	
				postProcess( preparedStatement );
/d,
				return preparedStatement;
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96	
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
/d,
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.getResultSetReturn() line: 242	
		if ( resultSetExtractor == null ) {
			resultSetExtractor = new ResultSetReturnImpl( this );
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.<init>(org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 47	
		this.jdbcCoordinator = jdbcCoordinator;

		final JdbcServices jdbcServices = jdbcCoordinator.getJdbcSessionOwner()
				.getJdbcSessionContext()
				.getServiceRegistry()
				.getService( JdbcServices.class );
/s,
org.hibernate.service.internal.SessionFactoryServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 188	
		R service = serviceRole.cast( initializedServiceByRole.get( serviceRole ) );
serviceRole=interface org.hibernate.engine.jdbc.spi.JdbcServices
service=org.hibernate.engine.jdbc.internal.JdbcServicesImpl@65d11f1d

this	org.hibernate.service.internal.SessionFactoryServiceRegistryImpl  (id=17545)	
	initializedServiceByRole	org.hibernate.service.internal.ConcurrentServiceBinding<K,V>  (id=17548)	
		treeRoot	org.hibernate.service.internal.ConcurrentServiceBinding$Node<K,V>  (id=17552)	
/=
<interface org.hibernate.envers.boot.internal.EnversService, org.hibernate.envers.boot.internal.EnversServiceImpl@103e234e>
L-> <interface org.hibernate.event.service.spi.EventListenerRegistry, org.hibernate.event.service.internal.EventListenerRegistryImpl@6f8df014>
	L-> <interface org.hibernate.boot.registry.classloading.spi.ClassLoaderService, org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl@442a39ce>
		L-> <interface org.hibernate.secure.spi.JaccService, org.hibernate.secure.internal.DisabledJaccServiceImpl@713e75c7>
			L-> <interface org.hibernate.engine.query.spi.NativeQueryInterpreter, org.hibernate.engine.query.internal.NativeQueryInterpreterStandardImpl@10fb1cfd>
		R-> <interface org.hibernate.boot.cfgxml.spi.CfgXmlAccessService, org.hibernate.boot.cfgxml.internal.CfgXmlAccessServiceImpl@107643a6>
	R-> <interface org.hibernate.stat.spi.StatisticsImplementor, Statistics[start time=1525070440550,sessions opened=0,sessions closed=0,transactions=0,successful transactions=0,optimistic lock failures=0,flushes=0,connections obtained=0,statements prepared=0,statements closed=0,second level cache puts=0,second level cache hits=0,second level cache misses=0,entities loaded=0,entities updated=0,entities inserted=0,entities deleted=0,entities fetched=0,collections loaded=0,collections updated=0,collections removed=0,collections recreated=0,collections fetched=0,naturalId queries executed to database=0,naturalId cache puts=0,naturalId cache hits=0,naturalId cache misses=0,naturalId max query time=0,queries executed to database=0,query cache puts=0,query cache hits=0,query cache misses=0,update timestamps cache puts=0,update timestamps cache hits=0,update timestamps cache misses=0,max query time=0]>
		L-> <interface org.hibernate.engine.jndi.spi.JndiService, org.hibernate.engine.jndi.internal.JndiServiceImpl@587fc2f>
		R-> <interface org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform, org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform@7153115>
R-> <interface org.hibernate.persister.spi.PersisterFactory, org.hibernate.persister.internal.PersisterFactoryImpl@4fc1c9fe>
	L-> <interface org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl@6d88d8d3>
		L-> <interface org.hibernate.integrator.spi.IntegratorService, org.hibernate.integrator.internal.IntegratorServiceImpl@575437c9>
		R-> <interface org.hibernate.engine.config.spi.ConfigurationService, org.hibernate.engine.config.internal.ConfigurationServiceImpl@79e729af>
	R-> <interface org.hibernate.engine.spi.CacheImplementor, org.hibernate.internal.CacheImpl@38288154>
		L-> <interface org.hibernate.engine.jdbc.connections.spi.ConnectionProvider, org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl@134d98c2>
		R-> <interface org.hibernate.engine.jdbc.spi.JdbcServices, org.hibernate.engine.jdbc.internal.JdbcServicesImpl@65d11f1d>
		
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.<init>(org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 49	
		final JdbcServices jdbcServices = jdbcCoordinator.getJdbcSessionOwner()
				.getJdbcSessionContext()
				.getServiceRegistry()
				.getService( JdbcServices.class );
/d,
		this.dialect = jdbcServices.getDialect();
/s,
org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getDialect() line: 77	
		if ( jdbcEnvironment != null ) {
			return jdbcEnvironment.getDialect();
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.<init>(org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 51	
		this.dialect = jdbcServices.getDialect();
/d,
org.hibernate.dialect.PostgreSQLDialect

		this.sqlStatementLogger = jdbcServices.getSqlStatementLogger();
		this.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();
/t,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.getResultSetReturn() line: 244	
			resultSetExtractor = new ResultSetReturnImpl( this );
/d,
		}
		return resultSetExtractor;
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96	
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/pd,
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 58	
		// IMPL NOTE : SQL logged by caller
		if ( isTypeOf( statement, CallableStatement.class ) ) { 	
/ komt in org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke,
/n,
/ TODO SQL Doe eens	,
			// We actually need to extract from Callable statement.  Although
			// this seems needless, Oracle can return an
			// OracleCallableStatementWrapper that finds its way to this method,
			// rather than extract(CallableStatement).  See HHH-8022.
			final CallableStatement callableStatement = (CallableStatement) statement;
			return extract( callableStatement );
		}
		try {
			final ResultSet rs;
			try {
				jdbcExecuteStatementStart();
/s,
org.hibernate.internal.AbstractSessionImpl$JdbcObserverImpl.jdbcExecuteStatementStart() line: 572	
			getEventListenerManager().jdbcExecuteStatementStart();
/s,
org.hibernate.engine.internal.SessionEventListenerManagerImpl.jdbcExecuteStatementStart() line: 110	
		if ( listenerList == null ) {
			return;
		}
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 70	
				jdbcExecuteStatementStart();
/d,
				rs = statement.executeQuery();
				

/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 491	
      if (doLocking)
         lock();
      try
      {
         checkTransaction();
         try 
         {
            checkConfiguredQueryTimeout();

            if (spy)
               spyLogger.debugf("%s [%s] executeQuery()",
                                jndiName, spyLoggingCategory);

            ResultSet resultSet = ps.executeQuery();
			
this	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=22882)	
	ps	com.sun.proxy.$Proxy91  (id=22881
		h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=22876)	
		
/s,
com.sun.proxy.$Proxy91.executeQuery() line: not available	
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 406	
            final String methodName = method.getName();
executeQuery
            // Delegate the call to the proxied Statement.
            try
            {
                return method.invoke(st, args);
				
this	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=22876)	
	st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=22617)	
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeQuery() line: 350	
/ deze call is GEEN call op een proxy,
        if (!executeWithFlags(0))
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 465	
        execute(preparedQuery.query, preparedParameters, flags);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 562
	
        // Only use named statements after we hit the threshold. Note that only
        // named statements can be transferred in binary format.
        if (preparedQuery != null && preparedQuery.query == queryToExecute)
/j,
        {
            preparedQuery.increaseExecuteCount();
1
            if ((m_prepareThreshold == 0 || preparedQuery.getExecuteCount() < m_prepareThreshold) && !forceBinaryTransfers)
/j, 1<5
                flags |= QueryExecutor.QUERY_ONESHOT;
        }
preparedQuery	org.postgresql.core.CachedQuery  (id=22851)	
	executeCount	1	
	key	"select nextval ('hibernate_sequence')" (id=22561)	
	query	org.postgresql.core.v3.SimpleQuery  (id=22853)	
		nativeQuery	org.postgresql.core.NativeQuery  (id=22854)	
			nativeSql	"select nextval ('hibernate_sequence')" (id=22855)	

        if (connection.getAutoCommit())
/n,
            flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;

        // updateable result sets do not yet support binary updates
        if (concurrency != ResultSet.CONCUR_READ_ONLY)
/n,
            flags |= QueryExecutor.QUERY_NO_BINARY_TRANSFER;

        if (queryToExecute.isEmpty())
/n,
        {
            flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;
        }

        if (!queryToExecute.isStatementDescribed() && forceBinaryTransfers) {
/s,
org.postgresql.core.v3.SimpleQuery.isStatementDescribed() line: 207	
/=
    // Have we sent a Describe Statement message for this query yet?
    // Note that we might not have need to, so this may always be false.
    public boolean isStatementDescribed() {
        return statementDescribed;
false
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 610	
        StatementResultHandler handler = new StatementResultHandler();
        result = null;
        try
        {
            startTimer();	
/ timeout=0 bij ons, dus doet NIETS,
/ TODO
            connection.getQueryExecutor().execute(queryToExecute,
                                                  queryParameters,
                                                  handler,
                                                  maxrows,
                                                  fetchSize,
                                                  flags);
        }
this	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=22617)	
	connection	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
		protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22616)	
			executor	org.postgresql.core.v3.QueryExecutorImpl  (id=22791)	

/s,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 157	
        waitOnLock();
/ TODO
        if (logger.logDebug())
/ TODO LOG 
        boolean describeOnly = (QUERY_DESCRIBE_ONLY & flags) != 0; / flags=1=QueryExecutor.QUERY_ONESHOT
false
       ((V3ParameterList)parameters).convertFunctionOutParameters();
/ NIETS bij ons,
/ TODO
        // Check parameters are all set..
        if (!describeOnly)
/j,
            ((V3ParameterList)parameters).checkAllParametersSet();

query	org.postgresql.core.v3.SimpleQuery  (id=22853)	
	nativeQuery	org.postgresql.core.NativeQuery  (id=22854)	
		nativeSql	"select nextval ('hibernate_sequence')" (id=22855)	

                handler = sendQueryPreamble(handler, flags);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendQueryPreamble(org.postgresql.core.ResultHandler, int) line: 353
/=
    private ResultHandler sendQueryPreamble(final ResultHandler delegateHandler, int flags) throws IOException {
	
        // First, send CloseStatements for finalized SimpleQueries that had statement names assigned.
        processDeadParsedQueries();
        processDeadPortals();

        // Send BEGIN on first statement in transaction.
        if ((flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) != 0 ||
                protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE)	/ ProtocolConnection.TRANSACTION_OPEN
/j,
            return delegateHandler;

/ we hoeven GEEN BEGIN te sturen, want we zitten al in een connection,

/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 170	
                handler = sendQueryPreamble(handler, flags);
/d,
                ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendQuery(org.postgresql.core.v3.V3Query, org.postgresql.core.v3.V3ParameterList, int, int, int, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler) line: 1116	
        // Now the query itself.
        SimpleQuery[] subqueries = query.getSubqueries();
/ SimpleQuery.getSubqueries() returns null, 
        SimpleParameterList[] subparams = parameters.getSubparams();
/ SimpleParameterList.getSubparams() returns null	,

        // We know this is deprecated, but still respect it in case anyone's using it.
        // PgJDBC its self no longer does.
        @SuppressWarnings("deprecation")
        boolean disallowBatching = (flags & QueryExecutor.QUERY_DISALLOW_BATCHING) != 0;
false
        if (subqueries == null)
/j,
        {
            flushIfDeadlockRisk(query, disallowBatching, trackingHandler, flags);
/s,
   /*
     * To prevent client/server protocol deadlocks, we try to manage the
     * estimated recv buffer size and force a sync +flush and process results if
     * we think it might be getting too full.
     *
     * See the comments above MAX_BUFFERED_RECV_BYTES's declaration for details.
     */
org.postgresql.core.v3.QueryExecutorImpl.flushIfDeadlockRisk(org.postgresql.core.Query, boolean, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler, int) line: 1070	
        // Assume all statements need at least this much reply buffer space,
        // plus params
        estimatedReceiveBufferBytes += NODATA_QUERY_RESPONSE_SIZE_BYTES;	/ 250

        if (sq.isStatementDescribed()) {
/n,
/ TODO

        if (disallowBatching		/ false
                || estimatedReceiveBufferBytes >= MAX_BUFFERED_RECV_BYTES) {			/ false: 250 >= 64000
/n,
            logger.debug("Forcing Sync, receive buffer full or batching disallowed");
            sendSync();
            processResults(trackingHandler, flags);
            estimatedReceiveBufferBytes = 0;
        }
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendQuery(org.postgresql.core.v3.V3Query, org.postgresql.core.v3.V3ParameterList, int, int, int, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler) line: 1129	
        if (subqueries == null)
        {
            flushIfDeadlockRisk(query, disallowBatching, trackingHandler, flags);
/d,
             // If we saw errors, don't send anything more.
            if (!trackingHandler.hasErrors())
                sendOneQuery((SimpleQuery)query, (SimpleParameterList)parameters, maxRows, fetchSize, flags);
/s,
/**
 * QueryExecutor implementation for the V3 protocol.
 */
public class QueryExecutorImpl implements QueryExecutor {
    // sendOneQuery sends a single statement via the extended query protocol.
    // Per the FE/BE docs this is essentially the same as how a simple query runs
    // (except that it generates some extra acknowledgement messages, and we
    // can send several queries before doing the Sync)
    //
    //   Parse     S_n from "query string with parameter placeholders"; skipped if already done previously or if oneshot
    //   Bind      C_n from S_n plus parameters (or from unnamed statement for oneshot queries)
    //   Describe  C_n; skipped if caller doesn't want metadata
    //   Execute   C_n with maxRows limit; maxRows = 1 if caller doesn't want results
    // (above repeats once per call to sendOneQuery)
    //   Sync      (sent by caller)
    //
    private void sendOneQuery(SimpleQuery query, SimpleParameterList params, int maxRows, int fetchSize, int flags) throws IOException {
/=
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1519	

/ Intermezzo

/ lees,
https://www.postgresql.org/docs/9.1/static/protocol.html
https://stackoverflow.com/questions/8624036/postgresql-cursors
https://www.postgresql.org/docs/9.1/static/protocol-flow.html

test=> \set AUTOCOMMIT off
test=> declare list_parts cursor for select *from parts;
DECLARE CURSOR
test=> fetch next from list_parts;
 sub_part | part | quantity
----------+------+----------
 1a       | 1    |        2
(1 row)


test=> fetch next from list_parts;
 sub_part | part | quantity
----------+------+----------
          | 1a   |        5
(1 row)
...
test=> close list_parts;
CLOSE CURSOR
/ OK	,

/ een declare cursor mag alleen in een tx, 
/ dat is wel logisch	, omdat er meerdere dingen achter elkaar worden gedaan,

/ je kunt ipv (of samen met) \set autocommit ook begin; use, let op ; achter begin,

test=> begin;
BEGIN
test=> declare list_parts cursor for select *from parts;
DECLARE CURSOR
test=> fetch next from list_parts;
 sub_part | part | quantity
----------+------+----------
 1a       | 1    |        2
(1 row)


test=> fetch next from list_parts;
 sub_part | part | quantity
----------+------+----------
          | 1a   |        5
(1 row)
...
test=> close list_parts;
CLOSE CURSOR
test=> end;			/ mag ook! gebruikelijker is commit;
COMMIT






/ Einde Intermezzo

        boolean noResults = (flags & QueryExecutor.QUERY_NO_RESULTS) != 0;
false
        boolean noMeta = (flags & QueryExecutor.QUERY_NO_METADATA) != 0;
false
        boolean describeOnly = (flags & QueryExecutor.QUERY_DESCRIBE_ONLY) != 0;
false
        boolean usePortal = (flags & QueryExecutor.QUERY_FORWARD_CURSOR) != 0 && !noResults && !noMeta && fetchSize > 0 && !describeOnly;
false
        boolean oneShot = (flags & QueryExecutor.QUERY_ONESHOT) != 0 && !usePortal;
true
        boolean noBinaryTransfer = (flags & QUERY_NO_BINARY_TRANSFER) != 0;
false
        boolean forceDescribePortal = (flags & QUERY_FORCE_DESCRIBE_PORTAL) != 0;
false
        else if (!usePortal)
/j,
        {
            rows = maxRows;       // Not using a portal -- fetchSize is irrelevant
        }
        sendParse(query, params, oneShot);
query=SimpleQuery select nextval ('hibernate_sequence')
params=SimpleParameterList
oneShot=true
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendParse(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, boolean) line: 1175	
        int[] typeOIDs = params.getTypeOIDs();
[]
        if (query.isPreparedFor(typeOIDs))
			return;
/s,
org.postgresql.core.v3.SimpleQuery.isPreparedFor(int[]) line: 124	
        if (statementName == null)
/j,
            return false; // Not prepared.
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendParse(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, boolean) line: 1179	
        if (query.isPreparedFor(typeOIDs))
\d,
\n,
            return;

        // Clean up any existing statement, as we can't use it.
        query.unprepare();
        processDeadParsedQueries();

        // Remove any cached Field values. The re-parsed query might report different
        // fields because input parameter types may result in different type inferences
        // for unspecified types.
        query.setFields(null);

        String statementName = null;
        if (!oneShot)
/n,
        {
            // Generate a statement name to use.
            statementName = "S_" + (nextUniqueID++);

            // And prepare the new statement.
            // NB: Must clone the OID array, as it's a direct reference to
            // the SimpleParameterList's internal array that might be modified
            // under us.
            query.setStatementName(statementName);
            query.setStatementTypes((int[])typeOIDs.clone());
        }
        byte[] encodedStatementName = query.getEncodedStatementName();
null
        String nativeSql = query.getNativeSql();
		
query	org.postgresql.core.v3.SimpleQuery  (id=22853)	
	nativeQuery	org.postgresql.core.NativeQuery  (id=22854)	
		nativeSql	"select nextval ('hibernate_sequence')" (id=22855)	

        //
        // Send Parse.
        //

        byte[] queryUtf8 = Utils.encodeUTF8(nativeSql);
[115, 101, 108, 101, 99, 116, 32,...

        // Total size = 4 (size field)
        //            + N + 1 (statement name, zero-terminated)
        //            + N + 1 (query, zero terminated)
        //            + 2 (parameter count) + N * 4 (parameter types)
        int encodedSize = 4
                      + (encodedStatementName == null ? 0 : encodedStatementName.length) + 1
                      + queryUtf8.length + 1
                      + 2 + 4 * params.getParameterCount();
45
        pgStream.SendChar('P'); // Parse	/=         pg_output.write(val);
        pgStream.SendInteger4(encodedSize);
/s,
    /**
     * Sends a 4-byte integer to the back end
     *
     * @param val the integer to be sent
     * @exception IOException if an I/O error occurs
     */
    public void SendInteger4(int val) throws IOException
    {
        _int4buf[0] = (byte)(val >>> 24);
        _int4buf[1] = (byte)(val >>> 16);
        _int4buf[2] = (byte)(val >>> 8);
        _int4buf[3] = (byte)(val);
        pg_output.write(_int4buf);
    }
/ WH big endian	,
/t,
        if (encodedStatementName != null)
            pgStream.Send(encodedStatementName);
        pgStream.SendChar(0);   // End of statement name
        pgStream.Send(queryUtf8); // Query string			/=         pg_output.write(buf);
        pgStream.SendChar(0);       // End of query string.
        pgStream.SendInteger2(params.getParameterCount());       // # of parameter types specified
        for (int i = 1; i <= params.getParameterCount(); ++i)
            pgStream.SendInteger4(params.getTypeOID(i));

        pendingParseQueue.add(query);
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1552	

/ lees,
http://enterprisesystemsmedia.com/article/a-closer-look-at-cics-ejb-java-support-under-cics-ts-2.3#sr=g&m=o&cp=or&ct=-tmc&st=(opu%20qspwjefe)&ts=1523545930

/ Intermezzo

/**
 * V3 Query implementation for a single-statement query.
 * This also holds the state of any associated server-side
 * named statement. We use a PhantomReference managed by
 * the QueryExecutor to handle statement cleanup.
 * 
 * @author Oliver Jowett (oliver@opencloud.com)
 */
class SimpleQuery implements V3Query {

    /**
     * The stored fields from previous execution or describe of a prepared 
     * statement. Always null for non-prepared statements.
     */
    private Field[] fields;
    private boolean needUpdateFieldFormats;
    private boolean hasBinaryFields;
    private boolean portalDescribed;
    private boolean statementDescribed;
    private PhantomReference cleanupRef;
    private int[] preparedTypes;
	
/ Einde Intermezzo

/s,
org.postgresql.core.v3.SimpleQuery.hasUnresolvedTypes() line: 136	
        if (preparedTypes == null)
            return true;
/ TODO	,
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1555	
        boolean queryHasUnknown = query.hasUnresolvedTypes();
/d,
true
        boolean paramsHasUnknown = params.hasUnresolvedTypes();
false
/ TODO
        boolean describeStatement = describeOnly || (!oneShot && paramsHasUnknown && queryHasUnknown && !query.isStatementDescribed());
false
        if (!describeStatement && paramsHasUnknown && !queryHasUnknown)
        {
            int queryOIDs[] = query.getStatementTypes();
            int paramOIDs[] = params.getTypeOIDs();
            for (int i=0; i<paramOIDs.length; i++) {
                // Only supply type information when there isn't any
                // already, don't arbitrarily overwrite user supplied
                // type information.
                if (paramOIDs[i] == Oid.UNSPECIFIED) {
                    params.setResolvedType(i+1, queryOIDs[i]);
                }
            }
        }
        if (describeStatement) {
/n,
            sendDescribeStatement(query, params, describeOnly);
            if (describeOnly)
                return;
        }
		
        // Construct a new portal if needed.
        Portal portal = null;
        if (usePortal)
        {
            String portalName = "C_" + (nextUniqueID++);
            portal = new Portal(query, portalName);
        }

        sendBind(query, params, portal, noBinaryTransfer);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendBind(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, org.postgresql.core.v3.Portal, boolean) line: 1254	
        String statementName = query.getStatementName();
null
        byte[] encodedStatementName = query.getEncodedStatementName();
null
        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName());
null
        if (logger.logDebug())
/ TODO LOG 

        // Total size = 4 (size field) + N + 1 (destination portal)
        //            + N + 1 (statement name)
        //            + 2 (param format code count) + N * 2 (format codes)
        //            + 2 (param value count) + N (encoded param value size)
        //            + 2 (result format code count, 0)
        long encodedSize = 0;
        for (int i = 1; i <= params.getParameterCount(); ++i)
/n,
        Field[] fields = query.getFields();
null
        if (!noBinaryTransfer && query.needUpdateFieldFormats()) {
/n,
            for (Field field : fields) {
                if (useBinary(field)) {
                    field.setFormat(Field.BINARY_FORMAT);
                    query.setHasBinaryFields(true);
                }
            }
        }
		
        // This is not the number of binary fields, but the total number
        // of fields if any of them are binary or zero if all of them
        // are text.
        int numBinaryFields = !noBinaryTransfer && query.hasBinaryFields() ? fields.length : 0;
/s,
org.postgresql.core.v3.SimpleQuery.hasBinaryFields() line: 188	
        return hasBinaryFields;	/ false
/d,
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendBind(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, org.postgresql.core.v3.Portal, boolean) line: 1298	
        // This is not the number of binary fields, but the total number
        // of fields if any of them are binary or zero if all of them
        // are text.
        int numBinaryFields = !noBinaryTransfer && query.hasBinaryFields() ? fields.length : 0;
/d,
0
        encodedSize = 4
                      + (encodedPortalName == null ? 0 : encodedPortalName.length) + 1
                      + (encodedStatementName == null ? 0 : encodedStatementName.length) + 1
                      + 2 + params.getParameterCount() * 2
                      + 2 + encodedSize
                      + 2 + numBinaryFields * 2;
12		
        // backend's MaxAllocSize is the largest message that can
        // be received from a client.  If we have a bigger value
        // from either very large parameters or incorrent length
        // descriptions of setXXXStream we do not send the bind
        // messsage.
        //
        if (encodedSize > 0x3fffffff)
        {
            throw new PGBindException(new IOException(GT.tr("Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.", encodedSize)));
        }
/ TODO EXC wat gebeurt er bij een throw new PGBindException	?

        pgStream.SendChar('B');                  // Bind				/ zonet, .SendChar('P') bij parse,
        pgStream.SendInteger4((int)encodedSize);      // Message size
        if (encodedPortalName != null)
            pgStream.Send(encodedPortalName);    // Destination portal name.
        pgStream.SendChar(0);                    // End of portal name.
        if (encodedStatementName != null)
            pgStream.Send(encodedStatementName); // Source statement name.
        pgStream.SendChar(0);                    // End of statement name.

        pgStream.SendInteger2(params.getParameterCount());      // # of parameter format codes
        for (int i = 1; i <= params.getParameterCount(); ++i)
            pgStream.SendInteger2(params.isBinary(i) ? 1 : 0);  // Parameter format code

        pgStream.SendInteger2(params.getParameterCount());      // # of parameter values

        // If an error occurs when reading a stream we have to
        // continue pumping out data to match the length we
        // said we would.  Once we've done that we throw
        // this exception.  Multiple exceptions can occur and
        // it really doesn't matter which one is reported back
        // to the caller.
        //
        PGBindException bindException = null;

        for (int i = 1; i <= params.getParameterCount(); ++i)
        {
            if (params.isNull(i))
                pgStream.SendInteger4( -1);                      // Magic size of -1 means NULL
            else
            {
                pgStream.SendInteger4(params.getV3Length(i));   // Parameter size
                try
                {
                    params.writeV3Value(i, pgStream);                 // Parameter value
                }
                catch (PGBindException be)
                {
                    bindException = be;
                }
            }
        }

        pgStream.SendInteger2(numBinaryFields);   // # of result format codes
        for (int i = 0; i < numBinaryFields; ++i) {
            pgStream.SendInteger2(fields[i].getFormat());
        }

        pendingBindQueue.add(portal == null ? UNNAMED_PORTAL : portal);

        if (bindException != null)
        {
            throw bindException;
        }
    }
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1590	
        sendBind(query, params, portal, noBinaryTransfer);
/d,
		if (!noMeta && !describeStatement) {
/j,
			/*
			 * don't send describe if we already have cached the row description
			 * from previous executions
			 * 
			 * XXX Clearing the fields / unpreparing the query (in sendParse) is
			 * incorrect, see bug #267. We might clear the cached fields in a
			 * later execution of this query if the bind parameter types change,
			 * but we're assuming here that they'll still be valid when we come
			 * to process the results of this query, so we don't send a new
			 * describe here. We re-describe after the fields are cleared, but
			 * the result of that gets processed after processing the results
			 * from earlier executions that we didn't describe because we didn't
			 * think we had to.
			 * 
			 * To work around this, force a Describe at each execution in
			 * batches where this can be a problem. It won't cause more round
			 * trips so the performance impact is low, and it'll ensure that the
			 * field information available when we decoded the results. This
			 * is undeniably a hack, but there aren't many good alternatives.
			 */
			if (query.getFields() == null || forceDescribePortal) {
/j,
				sendDescribePortal(query, portal);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendDescribePortal(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.Portal) line: 1389	
        if (logger.logDebug())
/ TODO LOG
        {
            logger.debug(" FE=> Describe(portal=" + portal + ")");
        }

        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName());

        // Total size = 4 (size field) + 1 (describe type, 'P') + N + 1 (portal name)
        int encodedSize = 4 + 1 + (encodedPortalName == null ? 0 : encodedPortalName.length) + 1;
6
        pgStream.SendChar('D');               // Describe
        pgStream.SendInteger4(encodedSize); // message size
        pgStream.SendChar('P');               // Describe (Portal)
        if (encodedPortalName != null)
            pgStream.Send(encodedPortalName); // portal name to close
        pgStream.SendChar(0);                 // end of portal name

        pendingDescribePortalQueue.add(query);
        query.setPortalDescribed(true);
    }
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1616	
				sendDescribePortal(query, portal);
/d,
        sendExecute(query, portal, rows);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendExecute(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.Portal, int) line: 1441	

/ Intermezzo

    private final Deque<SimpleQuery> pendingParseQueue = new ArrayDeque<SimpleQuery>();
    private final Deque<Portal> pendingBindQueue = new ArrayDeque<Portal>();
    private final Deque<ExecuteRequest> pendingExecuteQueue = new ArrayDeque<ExecuteRequest>();
    private final Deque<DescribeRequest> pendingDescribeStatementQueue = new ArrayDeque<DescribeRequest>();
    private final Deque<SimpleQuery> pendingDescribePortalQueue = new ArrayDeque<SimpleQuery>();
/ TODO Wat doen deze queues	?

/ Einde Intermezzo

        if (logger.logDebug())
        {
            logger.debug(" FE=> Execute(portal=" + portal + ",limit=" + limit + ")");
        }

        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName());
        int encodedSize = (encodedPortalName == null ? 0 : encodedPortalName.length);

        // Total size = 4 (size field) + 1 + N (source portal) + 4 (max rows)
        pgStream.SendChar('E');              // Execute
        pgStream.SendInteger4(4 + 1 + encodedSize + 4);  // message size
        if (encodedPortalName != null)
            pgStream.Send(encodedPortalName); // portal name
        pgStream.SendChar(0);                 // portal name terminator
        pgStream.SendInteger4(limit);       // row limit

        pendingExecuteQueue.add(new ExecuteRequest(query, portal));
/ TODO 
Waarom	?
    }		
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendQuery(org.postgresql.core.v3.V3Query, org.postgresql.core.v3.V3ParameterList, int, int, int, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler) line: 1157	
        if (subqueries == null)
        {
            flushIfDeadlockRisk(query, disallowBatching, trackingHandler, flags);

             // If we saw errors, don't send anything more.
            if (!trackingHandler.hasErrors())
                sendOneQuery((SimpleQuery)query, (SimpleParameterList)parameters, maxRows, fetchSize, flags);
/d,
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 172	
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/d,
                sendSync();
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendSync() line: 1168	
        if (logger.logDebug())
            logger.debug(" FE=> Sync");

        pgStream.SendChar('S');     // Sync
        pgStream.SendInteger4(4); // Length
        pgStream.flush();
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 173	
                sendSync();
/d,

/ Intermezzo

/ bij .SendChar send we 
'P' parse
'B' bind
'D' 'P' describe portal
'S' sync

/ bij .ReceiveChar zien we,
            case 'A':  // Asynchronous Notify
            case '1':    // Parse Complete (response to Parse)
            case 't':    // ParameterDescription
            case '2':    // Bind Complete  (response to Bind)
            case '3':    // Close Complete (response to Close)
            case 'n':    // No Data        (response to Describe)
            case 's':    // Portal Suspended (end of Execute)
            case 'C':  // Command Status (end of Execute)
            case 'D':  // Data Transfer (ongoing Execute response)
            case 'E':  // Error Response (response to pretty much everything; backend then skips until Sync)
            case 'I':  // Empty Query (end of Execute)
            case 'N':  // Notice Response
            case 'S':    // Parameter Status
            case 'T':  // Row Description (response to Describe)
            case 'Z':    // Ready For Query (eventual response to Sync)
            case 'G':  // CopyInResponse
            case 'H':  // CopyOutResponse
            case 'c':  // CopyDone
            case 'd':  // CopyData			
            default:			


/ Einde Intermezzo


                processResults(handler, flags);
/s,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1700	
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case '1':    // Parse Complete (response to Parse)
                pgStream.ReceiveInteger4(); // len, discarded

                SimpleQuery parsedQuery = pendingParseQueue.removeFirst();	/ removed select nextval ('hibernate_sequence') -> []
                String parsedStatementName = parsedQuery.getStatementName();
null
                if (logger.logDebug())
                    logger.debug(" <=BE ParseComplete [" + parsedStatementName + "]");

                registerParsedQuery(parsedQuery, parsedStatementName); / NIETS want parsedStatementName=null
                break;
/ volgende,
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            case '2':    // Bind Complete  (response to Bind)
                pgStream.ReceiveInteger4(); // len, discarded

                Portal boundPortal = pendingBindQueue.removeFirst(); / removes unnamed -> []
                if (logger.logDebug())
                    logger.debug(" <=BE BindComplete [" + boundPortal + "]");

                registerOpenPortal(boundPortal);	/ NIETS, want boundPortal=UNNAMED_PORTAL
                break;
/ volgende,
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case 'T':  // Row Description (response to Describe)
                Field[] fields = receiveFields();	/ [Field(,INT8,8,T)]
                tuples = new ArrayList();

                SimpleQuery query = pendingDescribePortalQueue.removeFirst();	/ removes select nextval ('hibernate_sequence') -> []
                query.setFields(fields);

                if (doneAfterRowDescNoData) {
/n,
                    DescribeRequest describeData = pendingDescribeStatementQueue.removeFirst();
                    SimpleQuery currentQuery = describeData.query;
                    currentQuery.setFields(fields);

                    handler.handleResultRows(currentQuery, fields, tuples, null);
                    tuples = null;
                }
                break;
/ volgende,
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
             case 'D':  // Data Transfer (ongoing Execute response)
                byte[][] tuple = null;
                try {
                    tuple = pgStream.ReceiveTupleV3(); / [[57, 55]]
                } catch(OutOfMemoryError oome) {
                    if (!noResults) {
                        handler.handleError(new PSQLException(GT.tr("Ran out of memory retrieving query results."), PSQLState.OUT_OF_MEMORY, oome));
                    }
                }		
                if (!noResults)
/j,
                {
                    if (tuples == null)
                        tuples = new ArrayList();
                    tuples.add(tuple);
                }
/ volgende,
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
			case 'C':  // Command Status (end of Execute)
                // Handle status.
                String status = receiveCommandStatus();	/ SELECT 1
				
                doneAfterRowDescNoData = false;

                {
                    ExecuteRequest executeData = pendingExecuteQueue.removeFirst();	/ org.postgresql.core.v3.ExecuteRequest@3ace36a9
                    SimpleQuery currentQuery = executeData.query;	/ select nextval ('hibernate_sequence')
                    Portal currentPortal = executeData.portal;	/ null

                    Field[] fields = currentQuery.getFields();	/ [Field(,INT8,8,T)]
				
					if (fields != null || tuples != null) {
						// There was a resultset.
						handler.handleResultRows(currentQuery, fields, tuples,
								null);
/s,
org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler.handleResultRows(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 267	

fields	org.postgresql.core.Field[1]  (id=23751)	/ [Field(,INT8,8,T)]
	[0]	org.postgresql.core.Field  (id=23752)	
		BINARY_FORMAT	1	
		TEXT_FORMAT	0	
		autoIncrement	false	
		columnLabel	"nextval" (id=23760)	
		columnName	"" (id=23761)	
		format	0	
		length	8	
		mod	-1	
		nullable	2	
		oid	20	
		positionInTable	0	
		schemaName	"" (id=23761)	
		tableName	"" (id=23761)	
		tableOid	0	
tuples	java.util.ArrayList<E>  (id=23755)	/ [[[B@44d0c6d3]
	elementData	java.lang.Object[10]  (id=23811)	
		[0]	(id=23762)	
			[0]	(id=23763)	
				[0]	57	
				[1]	55	
           try
            {
                ResultSet rs = AbstractJdbc2Statement.this.createResultSet(fromQuery, fields, tuples, cursor);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.Jdbc42Statement).createResultSet(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 42	
        Jdbc42ResultSet newResult = new Jdbc42ResultSet(originalQuery,
                                                        this,
                                                        fields,
                                                        tuples,
                                                        cursor,
                                                        getMaxRows(),		/ 0
                                                        getMaxFieldSize(),	/ 0	
                                                        getResultSetType(),	/ 1003
                                                        getResultSetConcurrency(), / 1007	
                                                        getResultSetHoldability()); / 2
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).<init>(org.postgresql.core.Query, org.postgresql.core.BaseStatement, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor, int, int, int, int) line: 147	
        // Fail-fast on invalid null inputs
        if (tuples == null)
            throw new NullPointerException("tuples must be non-null");
        if (fields == null)
            throw new NullPointerException("fields must be non-null");

        this.originalQuery = originalQuery;	/ SimpleQuery	,
        this.connection = (BaseConnection) statement.getConnection();
this	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
	connection	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
		protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22616)	
			pgStream	org.postgresql.core.PGStream  (id=22794)	

        this.statement = statement;
        this.fields = fields;
        this.rows = tuples;
        this.cursor = cursor;
        this.maxRows = maxRows;
        this.maxFieldSize = maxFieldSize;
        this.resultsettype = rsType;
        this.resultsetconcurrency = rsConcurrency;
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.Jdbc42Statement).createResultSet(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 49	
        Jdbc42ResultSet newResult = new Jdbc42ResultSet(originalQuery,
                                                        this,
                                                        fields,
                                                        tuples,
                                                        cursor,
                                                        getMaxRows(),
                                                        getMaxFieldSize(),
                                                        getResultSetType(),
                                                        getResultSetConcurrency(),
                                                        getResultSetHoldability());
/d,
        newResult.setFetchSize(getFetchSize());	/ 0 	TODO
        newResult.setFetchDirection(getFetchDirection());	/ 1000
        return newResult;
    }
/t,
org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler.handleResultRows(org.postgresql.core.Query, org.postgresql.core.Field[], java.util.List, org.postgresql.core.ResultCursor) line: 268	
                ResultSet rs = AbstractJdbc2Statement.this.createResultSet(fromQuery, fields, tuples, cursor);
/d,
				append(new ResultWrapper(rs));
				
this	org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler  (id=23675)	
	results	org.postgresql.jdbc2.ResultWrapper  (id=23938)	
		rs	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
			rows	java.util.ArrayList<E>  (id=23755)	
				elementData	java.lang.Object[10]  (id=23811)	
					[0]	(id=23762)	
						[0]	(id=23763)	
							[0]	57	
							[1]	55	

/t,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1861	
					if (fields != null || tuples != null) {
						// There was a resultset.
						handler.handleResultRows(currentQuery, fields, tuples,
								null);
/d,
						tuples = null;
					break;
/ volgende,
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case 'Z':    // Ready For Query (eventual response to Sync)
                receiveRFQ();
/s,
org.postgresql.core.v3.QueryExecutorImpl.receiveRFQ() line: 2244	

        if (pgStream.ReceiveInteger4() != 5)
/n,
            throw new IOException("unexpected length of ReadyForQuery message");

        char tStatus = (char)pgStream.ReceiveChar();
/ 'T'
       if (logger.logDebug())
/n,
            logger.debug(" <=BE ReadyForQuery(" + tStatus + ")");
/ TODO LOG 
        // Update connection state.
        switch (tStatus)
        {
        case 'I':
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);	/ blijft 
            break;
        case 'T':
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_OPEN);
            break;
/t,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1996	
                receiveRFQ();
/d,
                endQuery = true;

                // Reset the statement name of Parses that failed.
                while (!pendingParseQueue.isEmpty())
/n,
                {
                    SimpleQuery failedQuery = pendingParseQueue.removeFirst();
                    failedQuery.unprepare();
                }

                pendingParseQueue.clear();              // No more ParseComplete messages expected.
                pendingDescribeStatementQueue.clear();  // No more ParameterDescription messages expected.
                pendingDescribePortalQueue.clear();     // No more RowDescription messages expected.
                pendingBindQueue.clear();               // No more BindComplete messages expected.
                pendingExecuteQueue.clear();            // No more query executions expected.
                break;
/t,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 2061	

        while (!endQuery)
/n,
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {	

/ we zagen, 
'1'
'2'
'D'
'T'
'C'
'Z'		

/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 174	
            try
            {
                handler = sendQueryPreamble(handler, flags);
                ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
                sendSync();
                processResults(handler, flags);
/d,
                estimatedReceiveBufferBytes = 0;
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 624	
        try
        {
            startTimer();
            connection.getQueryExecutor().execute(queryToExecute,
                                                  queryParameters,
                                                  handler,
                                                  maxrows,
                                                  fetchSize,
                                                  flags);
/d,
        }
        finally
        {
            killTimerTask();
        }


        result = firstUnclosedResult = handler.getResults();	/= results
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 470	
        execute(preparedQuery.query, preparedParameters, flags);
/d,
        return (result != null && result.getResultSet() != null);
		
this	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=22617)	
	result	org.postgresql.jdbc2.ResultWrapper  (id=23938)	
		rs	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeQuery() line: 353	
        if (!executeWithFlags(0))
/n,
            throw new PSQLException(GT.tr("No results were returned by the query."), PSQLState.NO_DATA);

        if (result.getNext() != null)	/ ResultWrapper.next	,
/n,
            throw new PSQLException(GT.tr("Multiple ResultSets were returned by the query."), PSQLState.TOO_MANY_RESULTS);

        return (ResultSet) result.getResultSet();
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 453	
            // Delegate the call to the proxied Statement.
            try
            {
                return method.invoke(st, args);
/d,
            } catch (final InvocationTargetException ite) {
                final Throwable te = ite.getTargetException();
                if (te instanceof SQLException)
                    fireConnectionError((SQLException) te); // Tell listeners about exception if it's fatal
                throw te;
            }		
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 504	
            ResultSet resultSet = ps.executeQuery();
/d,
            return registerResultSet(resultSet);
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).<init>(org.jboss.jca.adapters.jdbc.WrappedStatement, java.sql.ResultSet, boolean, java.lang.String, boolean) line: 105	
      if (resultSet != null)
         resultSet = wrapResultSet(resultSet, spy, jndiName, doLocking);
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7.wrapResultSet(java.sql.ResultSet, boolean, java.lang.String, boolean) line: 64	
      return new WrappedResultSetJDK7(this, resultSet, spy, jndiName, doLocking);

this	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=22882)	
resultSet	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
spy	true	
jndiName	"java:jboss/datasources/PostgreSQLDS" (id=22911)	
doLocking	true	

      if (lc.getTrackStatements() == BaseWrapperManagedConnectionFactory.TRACK_STATEMENTS_FALSE_INT)
/n,
         return resultSet;

      WrappedResultSet wrapped = (WrappedResultSet) resultSet;
      
      synchronized (this)
      {
         if (resultSets == null)
/j,
            resultSets = new HashMap<WrappedResultSet, Throwable>(1);
         
         if (lc.getTrackStatements() == BaseWrapperManagedConnectionFactory.TRACK_STATEMENTS_TRUE_INT)
/n,
            resultSets.put(wrapped, new Throwable("STACKTRACE"));
         else
/j,            resultSets.put(wrapped, null);
      }
      return resultSet;
   }
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 515	
            ResultSet resultSet = ps.executeQuery();
            return registerResultSet(resultSet);
/d,
         }
         catch (Throwable t)
         {
            throw checkException(t);
         }
      }
      finally
      {
         if (doLocking)
/j,
            unlock();	  
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 73	
		try {
			final ResultSet rs;
			try {
				jdbcExecuteStatementStart();
				rs = statement.executeQuery();
/d,
			}
			finally {
				jdbcExecuteStatementEnd();
/s,
		jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteStatementEnd();
/ maar listenerList==null
/ TODO
/t,
			}
			postExtract( rs, statement );
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.postExtract(java.sql.ResultSet, java.sql.Statement) line: 231	
		if ( rs != null ) {
			jdbcCoordinator.getResourceRegistry().register( rs, st );
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.register(java.sql.ResultSet, java.sql.Statement) line: 198	
		log.tracef( "Registering result set [%s]", resultSet );
/ TODO LOG 
		if ( statement == null ) {
/n,
			try {
				statement = resultSet.getStatement();
			}
			catch (SQLException e) {
				throw convert( e, "unable to access Statement from ResultSet" );
			}
		}
		if ( statement != null ) {
			// Keep this at DEBUG level, rather than warn.  Numerous connection pool implementations can return a
			// proxy/wrapper around the JDBC Statement, causing excessive logging here.  See HHH-8210.
			if ( log.isDebugEnabled() && !xref.containsKey( statement ) ) {
/ TODO LOG
				log.debug( "ResultSet statement was not registered (on register)" );
			}
			Set<ResultSet> resultSets = xref.get( statement );
xref={org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@5cca9423=null}
			if ( resultSets == null ) {
/j,
				resultSets = new HashSet<ResultSet>();
				xref.put( statement, resultSets );
{org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@5cca9423=[]}
			}
			resultSets.add( resultSet );
xref={org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@5cca9423=[org.postgresql.jdbc42.Jdbc42ResultSet@afe1a3b]}
		}
		else {
			unassociatedResultSets.add( resultSet );
		}
	}
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 76	
			postExtract( rs, statement );
/d,
			return rs;
		}
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 98	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/d,
						try {
							rs.next();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).next() line: 2689	
      if (doLocking)
         lock();
      try
      {
         checkState();
         try
         {
            if (spy)
               spyLogger.debugf("%s [%s] next()",
                                jndiName, Constants.SPY_LOGGER_PREFIX_RESULTSET);

            return resultSet.next();
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).next() line: 1979	
        if (current_row + 1 >= rows.size())	/ current_row=-1
/n,		
        else
        {
            current_row++;
        }

        initRowBuffer();
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).initRowBuffer() line: 3116	
        this_row = (byte[][]) rows.get(current_row);
		
/ we zien dus dat in een ResultSet een rows [] is, en een current_row, die door .next() wordt ++	,
		
this	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
	this_row	(id=23762)	/ [[57, 55]]
		[0]	(id=23763)	
			[0]	57	
			[1]	55
			
        // We only need a copy of the current row if we're going to
        // modify it via an updatable resultset.
        if (resultsetconcurrency == ResultSet.CONCUR_UPDATABLE) {	/ ResultSet.CONCUR_READ_ONLY
/n,
            rowBuffer = new byte[this_row.length][];
            System.arraycopy(this_row, 0, rowBuffer, 0, this_row.length);
        } else {
j,
            rowBuffer = null;
        }        			
/t,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).next() line: 1980	
        initRowBuffer();
/d,
this	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
	this_row	(id=23762)	/ [[57, 55]]
	
        return true;
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).next() line: 2698	
            return resultSet.next();
/d,
         }
         catch (Throwable t)
         {
            throw checkException(t);
         }
      }
      finally
      {
         if (doLocking)
            unlock();
      }		
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 99
/=	
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
/d,
rs	org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7  (id=24071)	
	resultSet	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
		this_row	(id=23762)	

							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );/ Long.class
/s,
org.hibernate.id.IdentifierGeneratorHelper.getIntegralDataTypeHolder(java.lang.Class) line: 191	
		if ( integralType == Long.class
				|| integralType == Integer.class
				|| integralType == Short.class ) {
			return new BasicHolder( integralType );
/s,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.<init>(java.lang.Class) line: 264	
/=
	public static class BasicHolder implements IntegralDataTypeHolder {
		private final Class exactType;
		private long value = Long.MIN_VALUE;

		public BasicHolder(Class exactType) {
			this.exactType = exactType;
			if ( exactType != Long.class && exactType != Integer.class && exactType != Short.class ) {
/n,
				throw new IdentifierGenerationException( "Invalid type for basic integral holder : " + exactType );
			}
		}
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 100	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
/d,
value	org.hibernate.id.IdentifierGeneratorHelper$BasicHolder  (id=24146)	
	exactType	java.lang.Class<T> (java.lang.Long) (id=21343)	
	value	-9223372036854775808	

							value.initialize( rs, 1 );	/ 1 is de columnIndex, dus de ResultSet is een aantal rows en 1 column,
/s,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.initialize(java.sql.ResultSet, long) line: 280	
			long value = resultSet.getLong( 1 );
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).getLong(int) line: 1540	
      if (doLocking)
         lock();
      try
      {
         checkState();
         try
         {
            if (spy)
               spyLogger.debugf("%s [%s] getLong(%s)",
                                jndiName, Constants.SPY_LOGGER_PREFIX_RESULTSET,
                                columnIndex);

            return resultSet.getLong(columnIndex);
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).getLong(int) line: 2188
	        if (isBinary(columnIndex)) {
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).isBinary(int) line: 2939	
        return fields[column - 1].getFormat() == Field.BINARY_FORMAT;
/s,
org.postgresql.core.Field.getFormat() line: 124	
        return format; / TEXT_FORMAT				/ en is daarom utf-8 of ascii encoded, binary data is niet encoded,

    //The V3 protocol defines two constants for the format of data
    public static final int TEXT_FORMAT = 0;
    public static final int BINARY_FORMAT = 1;
    private int format = TEXT_FORMAT;   // In the V3 protocol each field has a format		/ default 	,

/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).getLong(int) line: 1552	

        if (isBinary(columnIndex)) {
/n,
            int col = columnIndex - 1;
            int oid = fields[col].getOID();	/ 20 bij ons,
            if (oid == Oid.INT8) {
                return ByteConverter.int8(this_row[col], 0);
            }
            return readLongValue(this_row[col], oid, Long.MIN_VALUE,
                                 Long.MAX_VALUE, "long");
        }

        Encoding encoding = connection.getEncoding();	/ utf-8 is alleen bij text format, klopt	,
		
this	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
	connection	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
		protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22616)	
			pgStream	org.postgresql.core.PGStream  (id=22794)	
				connection	java.net.Socket  (id=22804)	
				encoding	org.postgresql.core.Encoding  (id=22805)	UTF-8	
	
        if (encoding.hasAsciiNumbers()) {
/=
    /**
     * Returns true if this encoding has characters
     * '-' and '0'..'9' in exactly same posision as ascii.
     *  
     * @return true if the bytes can be scanned directly for ascii numbers.
     */
    public boolean hasAsciiNumbers() {
        return fastASCIINumbers;	/ true
		
            try {
                return getFastLong(columnIndex);	/ columnIndex=1
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).getFastLong(int) line: 2237	
        byte[] bytes = this_row[columnIndex - 1];
[57, 55]
        while (start < bytes.length) {
            byte b = bytes[start++]; 	/ 57 /= ascii
            if (b < '0' || b > '9') {
                throw FAST_NUMBER_FAILED;
            }
            
            val *= 10;		/ 0
            val += b - '0';	/ 9
        }
        while (start < bytes.length) {
            byte b = bytes[start++]; 	/ 55 /= ascii
            if (b < '0' || b > '9') {
                throw FAST_NUMBER_FAILED;
            }
            
            val *= 10;		/ 90
            val += b - '0';	/ 97
        }
		return val;
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).getLong(int) line: 1561	

            return resultSet.getLong(columnIndex);
/d,
         }
         catch (Throwable t)
         {
            throw checkException(t);
         }
      }
      finally
      {
         if (doLocking)
            unlock();
      }
/t,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.initialize(java.sql.ResultSet, long) line: 281	
			long value = resultSet.getLong( 1 );
/d,
97
			if ( resultSet.wasNull() ) {
				value = defaultValue;
			}
			return initialize( value );	/ this.value=value
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 101	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
							value.initialize( rs, 1 );
/d,
							if ( LOG.isDebugEnabled() ) {
								LOG.debugf( "Sequence value obtained: %s", value.makeValue() );
							}
							return value;
						}
						finally {
							try {
								session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.getResourceRegistry() line: 304	
		return this.logicalConnection.getResourceRegistry();
/t,
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.release(java.sql.ResultSet, java.sql.Statement) line: 102	
		log.tracef( "Releasing result set [%s]", resultSet );
/ TODO LOG 
		if ( statement != null ) {
			final Set<ResultSet> resultSets = xref.get( statement ); 
xref={org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@5cca9423=[org.postgresql.jdbc42.Jdbc42ResultSet@afe1a3b]}
			if ( resultSets == null ) {
/n,
				log.unregisteredStatement();
			}
			else {
/j,
				resultSets.remove( resultSet ); / [org.postgresql.jdbc42.Jdbc42ResultSet@afe1a3b]
				if ( resultSets.isEmpty() ) {
/j,
					xref.remove( statement );	/ xref={}
		close( resultSet );
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).close() line: 313	
      if (spy)
         spyLogger.debugf("%s [%s] close()",
                          jndiName, Constants.SPY_LOGGER_PREFIX_RESULTSET);

      if (closed.get())
         return;

      if (spy)
      {
         try
         {
            if (statement.isClosed())
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).isClosed() line: 1269	
      if (spy)
         spyLogger.debugf("%s [%s] isClosed()",
                          jndiName, spyLoggingCategory);

      if (s == null)
         return true;

      try
      {
         return s.isClosed(); / s= com.sun.proxy.$Proxy91 Pooled statement wrapping physical statement select nextval ('hibernate_sequence')
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 406	
            final String methodName = method.getName();	/ "isClosed"
            // All the rest is from the Statement interface
            if (methodName.equals("isClosed"))
            {
                return st == null || st.isClosed();
				
this	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=22617)	
	isClosed	false	
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).close() line: 325	
            if (statement.isClosed())
/d,
      closed.set(true);			/ closed is een AtomicBoolean	,
      statement.unregisterResultSet(this);
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).unregisterResultSet(org.jboss.jca.adapters.jdbc.WrappedResultSet) line: 1557	
      synchronized (this)
      {
         if (resultSets != null)			/ {org.postgresql.jdbc42.Jdbc42ResultSet@afe1a3b=null}
            resultSets.remove(resultSet);	/ {}
      }
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).close() line: 327	
      statement.unregisterResultSet(this);
/d,
      internalClose();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).internalClose() line: 5994	
      closed.set(true);
      resultSet.close();
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc4.AbstractJdbc4ResultSet).close() line: 63	
        try
        {
            super.close();
        }
        finally
        {
            ((AbstractJdbc4Statement) statement).checkCompletion();
        }
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).close() line: 1986	
        //release resources held (memory for tuples)
        rows = null;        

this	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
	rows	java.util.ArrayList<E>  (id=23755)	
		elementData	java.lang.Object[10]  (id=23811)	
			[0]	(id=23762)	/ [[57, 55]]

        if (cursor != null) {
/n,
/ TODO
            cursor.close();
            cursor = null;
        }
		
/ lees,
https://db.apache.org/derby/docs/10.0/manuals/develop/develop66.html
https://db.apache.org/derby/docs/10.6/devguide/cdevconcepts41275.html

/t,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc4.AbstractJdbc4ResultSet).close() line: 63	
        try
        {
            super.close();
/d,
        }
        finally
        {
            ((AbstractJdbc4Statement) statement).checkCompletion();
/ NIETS want closeOnCompletion==false
        }
...
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 116	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
							value.initialize( rs, 1 );
							if ( LOG.isDebugEnabled() ) {
								LOG.debugf( "Sequence value obtained: %s", value.makeValue() );
							}
							return value;
						}
						finally {
							try {
								session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
/d,
							}
							catch( Throwable ignore ) {
								// intentionally empty
							}
						}
					}
					finally {
						session.getJdbcCoordinator().getResourceRegistry().release( st );
						session.getJdbcCoordinator().afterStatementExecution();
					}

				}
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.release(java.sql.Statement) line: 82	
		else {
			final Set<ResultSet> resultSets = xref.get( statement );
			if ( resultSets != null ) {
				closeAll( resultSets );
			}
			xref.remove( statement ); / xref={}
		}
		close( statement );
/s,
/ CLOSE
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.close(java.sql.Statement) line: 154	
		try {
			// if we are unable to "clean" the prepared statement,
			// we do not close it
			try {
				if ( statement.getMaxRows() != 0 ) {
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).getMaxRows() line: 617	
      if (doLocking)
         lock();
      try
      {
         checkState();
         try
         {
            if (spy)
               spyLogger.debugf("%s [%s] getMaxRows()", jndiName, spyLoggingCategory);
         
            return s.getMaxRows();
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 440	
            try
            {
                return method.invoke(st, args); / public abstract int java.sql.Statement.getMaxRows() throws java.sql.SQLException
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).getMaxRows() line: 715	
    /*
     * The maxRows limit is set to limit the number of rows that
     * any ResultSet can contain.  If the limit is exceeded, the
     * excess rows are silently dropped.
     *
     * @return the current maximum row limit; zero means unlimited
     * @exception SQLException if a database access error occurs
     */
    public int getMaxRows() throws SQLException
    {
        checkClosed();
        return maxrows;	/ 0	/ unlimited,
    }
...
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).getMaxRows() line: 626	
            return s.getMaxRows();
/d,
         }
         catch (Throwable t)
         {
            throw checkException(t);
         }
      }
      finally
      {
         if (doLocking)
            unlock();
      }
/t,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.close(java.sql.Statement) line: 157	
			try {
				if ( statement.getMaxRows() != 0 ) {
/d,
/n,
					statement.setMaxRows( 0 );
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).getQueryTimeout() line: 758	
/=
    /*
     * The queryTimeout limit is the number of seconds the driver
     * will wait for a Statement to execute.  If the limit is
     * exceeded, a SQLException is thrown.
     *
     * @return the current query timeout limit in seconds; 0 = unlimited
     * @exception SQLException if a database access error occurs
     */
    public int getQueryTimeout() throws SQLException
    {
        checkClosed();
        return timeout;	/ 0
    }
/t,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.close(java.sql.Statement) line: 169	
			try {
				if ( statement.getMaxRows() != 0 ) {
					statement.setMaxRows( 0 );
				}
				if ( statement.getQueryTimeout() != 0 ) {
/n,
					statement.setQueryTimeout( 0 );
				}
			}
			catch (SQLException sqle) {
				// there was a problem "cleaning" the prepared statement
				if ( log.isDebugEnabled() ) {
					log.debugf( "Exception clearing maxRows/queryTimeout [%s]", sqle.getMessage() );
				}
				// EARLY EXIT!!!
				return;
			}
			statement.close();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).close() line: 154	
      closed.set(true);				/ AtomicBoolean
      lc.unregisterStatement(this);
	  
this	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=22882)	
	lc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=22571)	
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).unregisterStatement(org.jboss.jca.adapters.jdbc.WrappedStatement) line: 2018	
      synchronized (this)
      {
         if (statements != null)
            statements.remove(ws); / {org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@5cca9423=null} -> {}
      }	  
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).close() line: 154	
      closed.set(true);				/ AtomicBoolean
      lc.unregisterStatement(this);
/d,	  
      internalClose();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).internalClose() line: 1484	
      closed.set(true);
      try
      {
         closeResultSets();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).closeResultSets() line: 1574	
      synchronized (this)
      {
         if (resultSets == null	/ {}
/n,
            return;

         for (Iterator<Map.Entry<WrappedResultSet, Throwable>> i = resultSets.entrySet().iterator(); i.hasNext();)
/n,
         resultSets.clear(); / is al {}
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 406	
      closed.set(true);
      try
      {
         closeResultSets();
/d,
      }
      finally
      {
         s.close();
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 432	
            if (methodName.equals("close"))
            {
                if (st == null || st.isClosed())
                    return null;
                con = null;
                final Statement oldSt = st;
                st = null;
                oldSt.close();
/s,
    /*
     * In many cases, it is desirable to immediately release a
     * Statement's database and JDBC resources instead of waiting
     * for this to happen when it is automatically closed. The
     * close method provides this immediate release.
     *
     * <p><B>Note:</B> A Statement is automatically closed when it is
     * garbage collected.  When a Statement is closed, its current
     * ResultSet, if one exists, is also closed.
     *
     * @exception SQLException if a database access error occurs (why?)
     */
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).close() line: 896	
        // closing an already closed Statement is a no-op.
        if (isClosed)
            return ;

        killTimerTask();
        
        closeForNextExecution();
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).closeForNextExecution() line: 542	
        // Every statement execution clears any previous warnings.
        clearWarnings();
		
this	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=22617)	
	firstUnclosedResult	org.postgresql.jdbc2.ResultWrapper  (id=23938)	
		rs	org.postgresql.jdbc42.Jdbc42ResultSet  (id=23830)	
			connection	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
			rows	null	
			this_row	(id=23762)	[[57, 55]]


        // Close any existing resultsets associated with this statement.
        while (firstUnclosedResult != null)
        {
            ResultSet rs = firstUnclosedResult.getResultSet();
            if (rs != null)
            {
                rs.close();
/s,
org.postgresql.jdbc42.Jdbc42ResultSet(org.postgresql.jdbc2.AbstractJdbc2ResultSet).close() line: 1986	
        //release resources held (memory for tuples)
        rows = null;    	/ al,    
        if (cursor != null) {
            cursor.close();
            cursor = null;
        }
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).closeForNextExecution() line: 545	
            ResultSet rs = firstUnclosedResult.getResultSet();
            if (rs != null)
            {
                rs.close();
/d,
            }
            firstUnclosedResult = firstUnclosedResult.getNext();
null
/ geen volgende while loop,

        result = null;
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).close() line: 900	
        closeForNextExecution();
/d,
        if (preparedQuery != null)
            ((AbstractJdbc2Connection) connection).releaseQuery(preparedQuery);
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).releaseQuery(org.postgresql.core.CachedQuery) line: 106	
        statementCache.put(cachedQuery.key, cachedQuery);

this	org.postgresql.jdbc42.Jdbc42Connection  (id=22615)	
	statementCache	org.postgresql.util.LruCache<Key,Value>  (id=22628)	
		cache	org.postgresql.util.LruCache$1  (id=22633)	
{insert into Language (name, version, id) values (?, ?, ?)=org.postgresql.core.CachedQuery@5d23db65, 
select nextval ('hibernate_sequence')=org.postgresql.core.CachedQuery@5fbdd294}
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).close() line: 900	
        closeForNextExecution();
/d,
        if (preparedQuery != null)
            ((AbstractJdbc2Connection) connection).releaseQuery(preparedQuery);
/d,
        isClosed = true;
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 438	
            if (methodName.equals("close"))
            {
                if (st == null || st.isClosed())
                    return null;
                con = null;
                final Statement oldSt = st;
                st = null;
                oldSt.close();
/d,
                return null;
            }
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).internalClose() line: 1492	
      try
      {
         closeResultSets();
      }
      finally
      {
         s.close();
/d,
      }
      timeoutSet = 0;
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).close() line: 179	
      closed.set(true);
      lc.unregisterStatement(this);
      internalClose();
/d,
/t,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.close(java.sql.Statement) line: 177	
			statement.close();
			
/ Einde CLOSE
/d,
		if ( lastQuery == statement ) {
			lastQuery = null;
		}
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 117	
					finally {
						session.getJdbcCoordinator().getResourceRegistry().release( st );
/d,
						session.getJdbcCoordinator().afterStatementExecution();
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.afterStatementExecution() line: 281	
		LOG.tracev( "Starting after statement execution processing [{0}]", getConnectionReleaseMode() );
		if ( getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_STATEMENT ) {
			if ( ! releasesEnabled ) {
				LOG.debug( "Skipping aggressive release due to manual disabling" );
				return;
			}
			if ( hasRegisteredResources() ) {
				LOG.debug( "Skipping aggressive release due to registered resources" );
				return;
			}
			getLogicalConnection().afterStatement();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.afterStatement() line: 125	
		super.afterStatement();

		if ( connectionReleaseMode == ConnectionReleaseMode.AFTER_STATEMENT ) {
			if ( getResourceRegistry().hasRegisteredResources() ) {
				log.debug( "Skipping aggressive release of JDBC Connection after-statement due to held resources" );
			}
			else {
				log.debug( "Initiating JDBC connection release from afterStatement" );
				releaseConnection();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.releaseConnection() line: 170	
		try {
			if ( !physicalConnection.isClosed() ) {
/j,
				sqlExceptionHelper.logAndClearWarnings( physicalConnection );
			}
			jdbcConnectionAccess.releaseConnection( physicalConnection );

/ Intermezzo

/ we zijn in,
/s	,
repository.LanguageDao.insertInTx() line: 83	
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
        try {
            transactionIsRequired();
            getEntityManager().persist(entity);
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
		try {
			internalGetSession().persist( entity );
...
/s,
org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
		firePersist( new PersistEvent( entityName, object, this ) );
/s,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
			listener.onPersist( event );
...
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
			case TRANSIENT: {
				entityIsTransient( event, createCache );
				break;
			}
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
		final EventSource source = event.getSession();
		final Object entity = source.getPersistenceContext().unproxy( event.getObject() );

		if ( createCache.put( entity, entity ) == null ) {
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/s
///////////////////////////////////////////////////////////////
/ CONSTRUCTION
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/s,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
		// IMPL NOTE : this method is called concurrently and is
		// not synchronized. It is very important to work on the
		// local variable: the field lastSourceValue is not
		// reliable as it might be mutated by multipled threads.
		// The lastSourceValue field is only accessed by tests,
		// so this is not a concern.
		IntegralDataTypeHolder value = callback.getNextValue();
/s,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 117	
/=
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
						try {
							rs.next();
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
							value.initialize( rs, 1 );
							if ( LOG.isDebugEnabled() ) {
								LOG.debugf( "Sequence value obtained: %s", value.makeValue() );
							}
							return value;
						}
						finally {
							try {
								session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
							}
							catch( Throwable ignore ) {
								// intentionally empty
							}
						}
					}
					finally {
						session.getJdbcCoordinator().getResourceRegistry().release( st );
						session.getJdbcCoordinator().afterStatementExecution();					<-
					}

				}
				catch ( SQLException sqle) {
					throw session.getFactory().getSQLExceptionHelper().convert(
							sqle,
							"could not get next sequence value",
							sql
					);
				}
			}



/ Einde Intermezzo
			
/t,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 41	
		// IMPL NOTE : this method is called concurrently and is
		// not synchronized. It is very important to work on the
		// local variable: the field lastSourceValue is not
		// reliable as it might be mutated by multipled threads.
		// The lastSourceValue field is only accessed by tests,
		// so this is not a concern.
		IntegralDataTypeHolder value = callback.getNextValue();
/d,
BasicHolder[java.lang.Long[122]]	/ eerst was het 97	,

		if ( incrementSize > 0 ) {
			while ( value.lt( 1 ) ) {
/n,
				value = callback.getNextValue();
			}
		}
		lastSourceValue = value;
		return value.makeValue();          
/s,
org.hibernate.id.IdentifierGeneratorHelper$BasicHolder.makeValue() line: 369	
			if ( exactType == Long.class ) {
				return value;
			}
/t,
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/d,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/d,
			return performSave( entity, generatedId, persister, false, anything, source, true );

this	org.hibernate.jpa.event.internal.core.JpaPersistEventListener  (id=18803)	
entity	domain.Language  (id=18907)	
anything	java.util.IdentityHashMap<K,V>  (id=18910)	
persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
generatedId	java.lang.Long  (id=18905)	122
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 158	
		if ( !useIdentityColumn ) {
			key = source.generateEntityKey( id, persister ); / id=122
/s,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).generateEntityKey(java.io.Serializable, org.hibernate.persister.entity.EntityPersister) line: 338	
		return new EntityKey( id, persister );
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 168	
			key = source.generateEntityKey( id, persister );
/d,
			Object old = source.getPersistenceContext().getEntity( key );
null
			persister.setIdentifier( entity, id, source );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).setIdentifier(java.lang.Object, java.io.Serializable, org.hibernate.engine.spi.SessionImplementor) line: 4617	
		getEntityTuplizer().setIdentifier( entity, id, session );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).setIdentifier(java.lang.Object, java.io.Serializable, org.hibernate.engine.spi.SessionImplementor) line: 253	
		else if ( idSetter != null ) {
			idSetter.set( entity, id, getFactory() );	/ calls: 	field.set( target, value ); / target = entity = Language Java, id=Long 122
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 174	

			persister.setIdentifier( entity, id, source );
/d,
		}
		else {
			key = null;
		}

		if ( invokeSaveLifecycle( entity, persister, source ) ) {
/n,
		return performSaveOrReplicate(
				entity,
				key,
				persister,
				useIdentityColumn,
				anything,
				source,
				requiresImmediateIdAccess
		);
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 229	

		Serializable id = key == null ? null : key.getIdentifier(); / Long 122

		boolean inTxn = source.isTransactionInProgress();
/s,
org.hibernate.internal.SessionImpl.isTransactionInProgress() line: 500	
		checkTransactionSynchStatus();
/s,
org.hibernate.internal.SessionImpl.checkTransactionSynchStatus() line: 2218	
		pulseTransactionCoordinator();
/s,
org.hibernate.internal.SessionImpl.pulseTransactionCoordinator() line: 2224	
		if ( !isClosed() ) {
			transactionCoordinator.pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 137	
		if ( !autoJoinTransactions ) {
			return;
		}

		if ( synchronizationRegistered ) {
/j,
			return;
		}

		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
			log.trace( "JTA platform says we cannot currently resister synchronization; skipping" );
			return;
		}

		joinJtaTransaction();
...
/t,
org.hibernate.internal.SessionImpl.isTransactionInProgress() line: 501	
		checkTransactionSynchStatus();
/d,
		return !isClosed() && transactionCoordinator.getTransactionDriverControl()
				.getStatus() == TransactionStatus.ACTIVE && transactionCoordinator.isJoined();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl.getStatus() line: 421	
			return jtaTransactionAdapter.getStatus();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.getStatus() line: 90	
		try {
			return StatusTranslator.translate( transactionManager.getStatus() );
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
        return transactionManager.getStatus() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
		TransactionImple theTransaction = TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1064	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:a8 status: ActionStatus.RUNNING
		if (current != null)
		{
			final Uid txid = current.get_uid();
0:ffff0a26785d:22d14db8:5ae6b6ab:a8
			tx = (TransactionImple) _transactions.get(txid);
TransactionImple < ac, BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:a8 status: ActionStatus.RUNNING >
			if (tx == null)
				tx = new TransactionImple(current);
		}

		return tx;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 169
		TransactionImple theTransaction = TransactionImple.getTransaction();
/d,	
		else
			return theTransaction.getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 353	
			status = StatusConverter.convert(_theTransaction.status());	/ _theTransaction.status()==0==RUNNING
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 44	
		switch (status)
		{
		case ActionStatus.RUNNING:
/j,
			return javax.transaction.Status.STATUS_ACTIVE;
...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.getStatus() line: 90	
			return StatusTranslator.translate( transactionManager.getStatus() );
/pd,
/s,
org.hibernate.resource.transaction.backend.jta.internal.StatusTranslator.translate(int) line: 23	
		TransactionStatus transactionStatus = null;
		switch ( status ) {
			case Status.STATUS_ACTIVE:
/j,
				transactionStatus = TransactionStatus.ACTIVE;
				break;
		return tranactionStatus;
...
/t,
org.hibernate.internal.SessionImpl.isTransactionInProgress() line: 502	
		return !isClosed() && transactionCoordinator.getTransactionDriverControl()
				.getStatus() == TransactionStatus.ACTIVE
/d,				
/j,
				&& transactionCoordinator.isJoined();	/= synchronizationRegistered==true	
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 230	

		boolean inTxn = source.isTransactionInProgress();
/j,
		boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;
/n,
		// Put a placeholder in entries, so we don't recurse back and try to save() the
		// same object again. QUESTION: should this be done before onSave() is called?
		// likewise, should it be done before onUpdate()?
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);

/ Intermezzo

/ later,
		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
		
/ Einde Intermezzo

/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 509	
		/*
			IMPORTANT!!!

			The following instanceof checks and castings are intentional.

			DO NOT REFACTOR to make calls through the EntityEntryFactory interface, which would result
			in polymorphic call sites which will severely impact performance.

			When a virtual method is called via an interface the JVM needs to resolve which concrete
			implementation to call.  This takes CPU cycles and is a performance penalty.  It also prevents method
			in-ling which further degrades performance.  Casting to an implementation and making a direct method call
			removes the virtual call, and allows the methods to be in-lined.  In this critical code path, it has a very
			large impact on performance to make virtual method calls.
		*/
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/s,
org.hibernate.engine.internal.MutableEntityEntryFactory.createEntityEntry(org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean, org.hibernate.engine.spi.PersistenceContext) line: 48	
		return new MutableEntityEntry(
				status,		/ Status.SAVING
				loadedState,	/ null
				rowId,		/ null
				id,	/ 122
				version,	/ null
				lockMode,	/ LockMode.WRITE
				existsInDatabase,	/ false
				persister,	/ SingleTableEntityPersister(domain.Language)
				disableVersionIncrement,	/ false
				lazyPropertiesAreUnfetched,	/ false
				persistenceContext	/ PersistenceContext[entityKeys=[],collectionKeys=[]]
		);
/s,
org.hibernate.engine.internal.MutableEntityEntry(org.hibernate.engine.internal.AbstractEntityEntry).<init>(org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean, org.hibernate.engine.spi.PersistenceContext) line: 113	
		setCompressedValue( EnumState.STATUS, status );
/s,
org.hibernate.engine.internal.MutableEntityEntry(org.hibernate.engine.internal.AbstractEntityEntry).setCompressedValue(org.hibernate.engine.internal.AbstractEntityEntry.EnumState<E>, E) line: 500	
/=
	protected <E extends Enum<E>> void setCompressedValue(EnumState<E> state, E value) {

value	org.hibernate.engine.spi.Status  (id=19671)	
	DELETED	org.hibernate.engine.spi.Status  (id=19674)	
	GONE	org.hibernate.engine.spi.Status  (id=19675)	
	LOADING	org.hibernate.engine.spi.Status  (id=19676)	
	MANAGED	org.hibernate.engine.spi.Status  (id=19677)	
	READ_ONLY	org.hibernate.engine.spi.Status  (id=19702)	
	SAVING	org.hibernate.engine.spi.Status  (id=19671)	
	name	"SAVING" (id=19672)	
	ordinal	5	

state	org.hibernate.engine.internal.AbstractEntityEntry$EnumState<E>  (id=19693)	
	LOCK_MODE	org.hibernate.engine.internal.AbstractEntityEntry$EnumState<E>  (id=19695)	
		enumConstants	org.hibernate.LockMode[12]  (id=19731)
[NONE, READ, UPGRADE, UPGRADE_NOWAIT, UPGRADE_SKIPLOCKED, WRITE, FORCE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT]
		mask	15	/ 0xf
		offset	0	
		unsetMask	65520	0xfff0
	STATUS	org.hibernate.engine.internal.AbstractEntityEntry$EnumState<E>  (id=19693)
		enumConstants	org.hibernate.engine.spi.Status[6]  (id=19697)
[MANAGED, READ_ONLY, DELETED, GONE, LOADING, SAVING]	
		mask	240		0xf0
		offset	4	
		unsetMask	65295	/ 0xff0f
	PREVIOUS_STATUS	org.hibernate.engine.internal.AbstractEntityEntry$EnumState<E>  (id=19696
		enumConstants	org.hibernate.engine.spi.Status[6]  (id=19733)
[MANAGED, READ_ONLY, DELETED, GONE, LOADING, SAVING]	
		mask	3840	/ 0xf00
		offset	8	
		unsetMask	61695	0xf0ff

/ Intermezzo

	protected static class EnumState<E extends Enum<E>> {

		protected static final EnumState<LockMode> LOCK_MODE = new EnumState<LockMode>( 0, LockMode.class );
		protected static final EnumState<Status> STATUS = new EnumState<Status>( 4, Status.class );
		protected static final EnumState<Status> PREVIOUS_STATUS = new EnumState<Status>( 8, Status.class );

		protected final int offset;
		protected final E[] enumConstants;
		protected final int mask;
		protected final int unsetMask;

		private EnumState(int offset, Class<E> enumType) {
			final E[] enumConstants = enumType.getEnumConstants();

			// In case any of the enums cannot be stored in 4 bits anymore, we'd have to re-structure the compressed
			// state int
			if ( enumConstants.length > 15 ) {
				throw new AssertionFailure( "Cannot store enum type " + enumType.getName() + " in compressed state as"
						+ " it has too many values." );
			}

			this.offset = offset;
			this.enumConstants = enumConstants;

			// a mask for reading the four bits, starting at the right offset
			this.mask = 0xF << offset;

			// a mask for setting the four bits at the right offset to 0
			this.unsetMask = 0xFFFF & ~mask;
		}



/ Einde Intermezzo

		// reset the bits for the given property to 0
		compressedState &= state.getUnsetMask();
		// store the numeric representation of the enum value at the right offset
		compressedState |= ( state.getValue( value ) << state.getOffset() );	/ 0x60	, omdat STATUS=6 en mask=0xf0
/t,
org.hibernate.engine.internal.MutableEntityEntry(org.hibernate.engine.internal.AbstractEntityEntry).<init>(org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean, org.hibernate.engine.spi.PersistenceContext) line: 118	
		setCompressedValue( EnumState.STATUS, status );
this
	compressedState 0x60
		// not useful strictly speaking but more explicit
		setCompressedValue( EnumState.PREVIOUS_STATUS, null );
		// only retain loaded state if the status is not Status.READ_ONLY
		if ( status != Status.READ_ONLY ) {
			this.loadedState = loadedState;
		}
		this.id=id;	/ 122
		this.rowId=rowId;
		setCompressedValue( BooleanState.EXISTS_IN_DATABASE, existsInDatabase ); / existsInDatabase=false
this.compressedState=96, nu gaan we verder met bit <13, als je met 0 begint bit index 13	, 0x2000, en we set 0 op die positie, want false,
		this.version=version;
		setCompressedValue( EnumState.LOCK_MODE, lockMode ); / lockMode=WRITE=
this.compressedState=102	, / TODO
		setCompressedValue( BooleanState.IS_BEING_REPLICATED, disableVersionIncrement ); / 102
		setCompressedValue( BooleanState.LOADED_WITH_LAZY_PROPERTIES_UNFETCHED, lazyPropertiesAreUnfetched );	/ 102
		this.persister=persister;
		this.persistenceContext = persistenceContext;

/ Intermezzo

	/**
	 * Represents a boolean flag stored within a number value, using one bit at a specified offset.
	 *
	 * @author Gunnar Morling
	 */
	protected enum BooleanState {

/ we hadden eerder de achterste 12 bits set, nu gaan we verder, 
/ waarom slaan we 0x1000 over	?
/ TODO
		EXISTS_IN_DATABASE(13), 	/ offset=13	, mask=0x2000=1<<13	, unsetMask=0xdfff=57343
		IS_BEING_REPLICATED(14),
		LOADED_WITH_LAZY_PROPERTIES_UNFETCHED(15);

		private final int offset;
		private final int mask;
		private final int unsetMask;

		private BooleanState(int offset) {
			this.offset = offset;
			this.mask = 0x1 << offset;
			this.unsetMask = 0xFFFF & ~mask;
		}

		private int getValue(boolean value) {
			return value ? 1 : 0;
		}

		/**
		 * Returns the offset within the number value at which this boolean flag is stored.
		 */
		private int getOffset() {
			return offset;
		}

		/**
		 * Returns the bit mask for reading this flag from the number value storing it.
		 */
		private int getMask() {
			return mask;
		}

		/**
		 * Returns the bit mask for resetting this flag from the number value storing it.
		 */
		private int getUnsetMask() {
			return unsetMask;
		}
	}



/ Einde Intermezzo			

/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 542	
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/d,
		entityEntryContext.addEntityEntry( entity, e );
/s,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 77	
		// IMPORTANT!!!!!
		//		add is called more than once of some entities.  In such cases the first
		//		call is simply setting up a "marker" to avoid infinite looping from reentrancy

		// any addition (even the double one described above) should invalidate the cross-ref array
		dirty = true;

		assert AbstractEntityEntry.class.isInstance( entityEntry );

		// We only need to check a mutable EntityEntry is associated with the same PersistenceContext.
		// Immutable EntityEntry can be associated with multiple PersistenceContexts, so no need to check.
		// ImmutableEntityEntry#getPersistenceContext() throws an exception (HHH-10251).
		if ( entityEntry.getPersister().isMutable() ) {
			assert AbstractEntityEntry.class.cast( entityEntry ).getPersistenceContext() == persistenceContext;
		}

		// Determine the appropriate ManagedEntity instance to use based on whether the entity is enhanced or not.
		// Throw an exception if entity is a mutable ManagedEntity that is associated with a different
		// PersistenceContext.
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null
/n,
					? nonEnhancedEntityXref.get( entity )
					: null;
		}
/t,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 92	
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
null
		final boolean alreadyAssociated = managedEntity != null;
		if ( !alreadyAssociated ) {
/j,
			if ( ManagedEntity.class.isInstance( entity ) ) {
/n,
entity=Language Java
			else {
				if ( nonEnhancedEntityXref == null ) {
					nonEnhancedEntityXref = new IdentityHashMap<Object, ManagedEntity>();
				}
				managedEntity = new ManagedEntityImpl( entity );
				nonEnhancedEntityXref.put( entity, managedEntity );

		// associate the EntityEntry with the entity
		managedEntity.$$_hibernate_setEntityEntry( entityEntry );
entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=19670)	
	compressedState	102	
	id	java.lang.Long  (id=18905)	/ 122
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	

/ 122 is de branch id 	, 
/ TODO
		// finally, set up linking and count
		if ( tail == null ) {
/j,
this	org.hibernate.engine.internal.EntityEntryContext  (id=20111)	

			assert head == null;
			// Protect against stale data in the ManagedEntity and nullify previous/next references.
			managedEntity.$$_hibernate_setPreviousManagedEntity( null );
			managedEntity.$$_hibernate_setNextManagedEntity( null );
			head = managedEntity;
			tail = head;
			count = 1;
		}
/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 544	
		entityEntryContext.addEntityEntry( entity, e );
/d,
this	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
	entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=20111)	
		nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=20114)	
{Language name: Java=org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl@2798c489}

		setHasNonReadOnlyEnties( status );
/ TODO
		return e;
MutableEntityEntry EntityEntry[domain.Language#122](SAVING)
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 249	
		// Put a placeholder in entries, so we don't recurse back and try to save() the
		// same object again. QUESTION: should this be done before onSave() is called?
		// likewise, should it be done before onUpdate()?
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
/d,
		cascadeBeforeSave( source, persister, entity, anything );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).cascadeBeforeSave(org.hibernate.event.spi.EventSource, org.hibernate.persister.entity.EntityPersister, java.lang.Object, java.lang.Object) line: 426	
		// cascade-save to many-to-one BEFORE the parent is saved
		source.getPersistenceContext().incrementCascadeLevel();
		try {
			Cascade.cascade(
					getCascadeAction(), /= 		return PERSIST_SKIPLAZY;
					CascadePoint.BEFORE_INSERT_AFTER_DELETE,
					source,
					persister,
					entity,
					anything
			);
		}
/ NIETS,
		finally {
			source.getPersistenceContext().decrementCascadeLevel();
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 251	
		cascadeBeforeSave( source, persister, entity, anything );
/d,
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
		
/ deze haalt H. uit entity, met reflectie op het type van entity	, er is dus geen SQL hier,
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 4680	
		return getEntityTuplizer().getPropertyValuesToInsert( object, mergeMap, session );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer.getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 237	
		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).shouldGetAllProperties(java.lang.Object) line: 491	
		return !hasUninitializedLazyProperties( entity );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer.hasUninitializedLazyProperties(java.lang.Object) line: 322	
		if ( getEntityMetamodel().hasLazyProperties() ) {
/n,
/t,
org.hibernate.tuple.entity.PojoEntityTuplizer.getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 241	
		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
/n,
		else {
			return super.getPropertyValuesToInsert( entity, mergeMap, session );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 518	
		final int span = entityMetamodel.getPropertySpan();
2
		final Object[] result = new Object[span];

		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
		}
		return result;
...
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 252	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/d,
[Java, 0]
		Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@42bfddbf, org.hibernate.type.IntegerType@138ca94b]	
/=
persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=18953)	
		propertyTypes	org.hibernate.type.Type[2]  (id=20242)	

		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).substituteValuesIfNecessary(java.lang.Object, java.io.Serializable, java.lang.Object[], org.hibernate.persister.entity.EntityPersister, org.hibernate.engine.spi.SessionImplementor) line: 388	
		boolean substitute = source.getInterceptor().onSave( 	/= 		return false;
				entity,
				id,
				values,
				persister.getPropertyNames(), / persister.entityMetamodel.propertyNames=[name, version]
				persister.getPropertyTypes()
		);
		
		//keep the existing version number in the case of replicate!
		if ( persister.isVersioned() ) {	 / persister.entityMetamodel.versioned
/j,
			substitute = Versioning.seedVersion(
					values,
					persister.getVersionProperty(), / persister.entityMetamodel.versionPropertyIndex==1
					persister.getVersionType(),
					source
			) || substitute;
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getVersionType() line: 4223	
		return (VersionType) locateVersionType();
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).locateVersionType() line: 4227	
		return entityMetamodel.getVersionProperty() == null ?
/s,
org.hibernate.tuple.entity.EntityMetamodel.getVersionProperty() line: 915	
properties=[Attribute(name=name, type=string [non-identifier]), Attribute(name=version, type=integer [non-identifier])]
		else {
			return ( VersionProperty ) properties[ versionPropertyIndex ]; / versionPropertyIndex==1
...
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).locateVersionType() line: 4227	
		return entityMetamodel.getVersionProperty() == null ?
/n,
				null :
				entityMetamodel.getVersionProperty().getType();
				
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=18953)	
		properties	org.hibernate.tuple.NonIdentifierAttribute[2]  (id=20280)	
			[0]	org.hibernate.tuple.entity.EntityBasedBasicAttribute  (id=20308)	
				attributeInformation	org.hibernate.tuple.BaselineAttributeInformation  (id=20430)	
				attributeName	"name" (id=20300)	
				attributeNumber	0	
				attributeType	org.hibernate.type.StringType  (id=20244)	
				sessionFactory	org.hibernate.internal.SessionFactoryImpl  (id=18569)	
				source	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
			[1]	org.hibernate.tuple.entity.VersionProperty  (id=20309)	
				attributeInformation	org.hibernate.tuple.BaselineAttributeInformation  (id=20333)	
				attributeName	"version" (id=20301)	
				attributeNumber	1	
				attributeType	org.hibernate.type.IntegerType  (id=20245)	
				sessionFactory	org.hibernate.internal.SessionFactoryImpl  (id=18569)	
				source	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
				unsavedValue	org.hibernate.engine.spi.VersionValue$2  (id=20334)	
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).substituteValuesIfNecessary(java.lang.Object, java.io.Serializable, java.lang.Object[], org.hibernate.persister.entity.EntityPersister, org.hibernate.engine.spi.SessionImplementor) line: 401	
		//keep the existing version number in the case of replicate!
		if ( persister.isVersioned() ) {
			substitute = Versioning.seedVersion(
					values,
					persister.getVersionProperty(),
					persister.getVersionType(),
/d,
					source
			) || substitute;
		}
/s,
	/**
	 * Create an initial optimistic locking value according the {@link VersionType}
	 * contract for the version property <b>if required</b> and inject it into
	 * the snapshot state.
	 *
org.hibernate.engine.internal.Versioning.seedVersion(java.lang.Object[], int, org.hibernate.type.VersionType, org.hibernate.engine.spi.SessionImplementor) line: 64	
		final Object initialVersion = fields[versionProperty];
versionProperty=1
initialVersion=0	/ uit [Java,0]
...
		return false;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).substituteValuesIfNecessary(java.lang.Object, java.io.Serializable, java.lang.Object[], org.hibernate.persister.entity.EntityPersister, org.hibernate.engine.spi.SessionImplementor) line: 405
		boolean substitute = source.getInterceptor().onSave(
				entity,
				id,
				values,
				persister.getPropertyNames(),
				persister.getPropertyTypes()
		);
false		
		//keep the existing version number in the case of replicate!
		if ( persister.isVersioned() ) {
			substitute = Versioning.seedVersion(
					values,
					persister.getVersionProperty(),
					persister.getVersionType(),
					source
			)
false			|| 
			substitute;
false
		}
		return substitute;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 256	
		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source );
/d,
false
		if ( persister.hasCollections() ) {
/n,
persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=18953)	
		hasCollections	false	

		if ( substitute ) {
/n,
			persister.setPropertyValues( entity, values );

		TypeHelper.deepCopy(
				values,	/ [Java,0]
				types, / [org.hibernate.type.StringType@42bfddbf, org.hibernate.type.IntegerType@138ca94b]
				persister.getPropertyUpdateability(),
				values,
				source
		);	
persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=18953)	
		propertyUpdateability	(id=20287)	[true,true]
/s,
org.hibernate.type.TypeHelper.deepCopy(java.lang.Object[], org.hibernate.type.Type[], boolean[], java.lang.Object[], org.hibernate.engine.spi.SessionImplementor) line: 44
/=
	public static void deepCopy(
			final Object[] values,
			final Type[] types,
			final boolean[] copy,
			final Object[] target,
			final SessionImplementor session) {
		for ( int i = 0; i < types.length; i++ ) {
			if ( copy[i] ) {
				if ( values[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY
					|| values[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
					target[i] = values[i];
				}
				else {
					target[i] = types[i].deepCopy( values[i], session
						.getFactory() );
				}
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 272	
		TypeHelper.deepCopy(
				values,
				types,
				persister.getPropertyUpdateability(),
				values,
				source
		);
/d,
values=[Java,0]

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).addInsertAction(java.lang.Object[], java.io.Serializable, java.lang.Object, org.hibernate.persister.entity.EntityPersister, boolean, org.hibernate.event.spi.EventSource, boolean) line: 313	
	
/ Intermezzo

Thread [default task-66] (Suspended)	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).addInsertAction(java.lang.Object[], java.io.Serializable, java.lang.Object, org.hibernate.persister.entity.EntityPersister, boolean, org.hibernate.event.spi.EventSource, boolean) line: 313	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 272	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 178	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 121	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
	org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
	org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
	org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
	org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
	org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
	repository.LanguageDao.insertInTx() line: 83	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view6.insertInTx() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	

/ Einde Intermezzo	

		else {
			Object version = Versioning.getVersion( values, persister );
0
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
insert	org.hibernate.action.internal.EntityInsertAction  (id=20644)	
	areTransientReferencesNullified	false	
	cacheEntry	null	
	entityName	"domain.Language" (id=18909)	
	id	java.lang.Long  (id=18905)	
	instance	domain.Language  (id=18907)	
		serialVersionUID	1	
		id	java.lang.Long  (id=18905)	
		name	"Java" (id=18957)	
		version	0	
	isExecuted	false	
	isVersionIncrementDisabled	false	
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
	session	org.hibernate.internal.SessionImpl  (id=18789)	
	state	java.lang.Object[2]  (id=20234)	
		[0]	"Java" (id=18957)	
		[1]	java.lang.Integer  (id=20239)	
	version	java.lang.Integer  (id=20239)	

			source.getActionQueue().addAction( insert );
/s,
org.hibernate.engine.spi.ActionQueue.addAction(org.hibernate.action.internal.EntityInsertAction) line: 240	
		addInsertAction( action );
/s,
	private void addInsertAction(AbstractEntityInsertAction insert) {
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
		if ( nonNullableTransientDependencies == null ) {
/j,
			LOG.tracev( "Adding insert with no non-nullable, transient entities: [{0}]", insert );
			addResolvedEntityInsertAction( insert );
/s,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 269	
		else {
			LOG.trace( "Adding resolved non-early insert action." );
			addAction( AbstractEntityInsertAction.class, insert );
/s,
org.hibernate.engine.spi.ActionQueue.addAction(java.lang.Class<T>, T) line: 289

EXECUTABLE_LISTS_MAP=
{class org.hibernate.action.internal.OrphanRemovalAction=org.hibernate.engine.spi.ActionQueue$1@7b18f33f, class org.hibernate.action.internal.AbstractEntityInsertAction=org.hibernate.engine.spi.ActionQueue$2@17c2fed8, class org.hibernate.action.internal.EntityUpdateAction=org.hibernate.engine.spi.ActionQueue$3@6479133, class org.hibernate.action.internal.QueuedOperationCollectionAction=org.hibernate.engine.spi.ActionQueue$4@30dab1b, class org.hibernate.action.internal.CollectionRemoveAction=org.hibernate.engine.spi.ActionQueue$5@3f30314e, class org.hibernate.action.internal.CollectionUpdateAction=org.hibernate.engine.spi.ActionQueue$6@3f043c4e, class org.hibernate.action.internal.CollectionRecreateAction=org.hibernate.engine.spi.ActionQueue$7@570fc94, class org.hibernate.action.internal.EntityDeleteAction=org.hibernate.engine.spi.ActionQueue$8@6bcbca52}


/ Intermezzo

public class ActionQueue {
	static {
		EXECUTABLE_LISTS_MAP = new LinkedHashMap<Class<? extends Executable>,ListProvider>( 8 );

		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;
					}
					ExecutableList<AbstractEntityInsertAction> init(ActionQueue instance) {
						if ( instance.isOrderInsertsEnabled() ) {
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									new InsertActionSorter()
							);
						}
						else {
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									false
							);
						}
					}
				}
		);
/ in het totaal 8 puts	,

	private static abstract class ListProvider<T extends Executable & Comparable & Serializable> {
		abstract ExecutableList<T> get(ActionQueue instance);
		abstract ExecutableList<T> init(ActionQueue instance);
		ExecutableList<T> getOrInit( ActionQueue instance ) {
			ExecutableList<T> list = get( instance );
			if ( list == null ) {
				list = init( instance );
			}
			return list;
		}
	}
}

/ Einde Intermezzo
	
		EXECUTABLE_LISTS_MAP.get( executableClass ).getOrInit( this ).add( action );
/s,
org.hibernate.engine.spi.ActionQueue$2(org.hibernate.engine.spi.ActionQueue$ListProvider<T>).getOrInit(org.hibernate.engine.spi.ActionQueue) line: 1124	
			ExecutableList<T> list = get( instance );
/s,
org.hibernate.engine.spi.ActionQueue$2.get(org.hibernate.engine.spi.ActionQueue) line: 117	
/=
		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;
null
/t,
org.hibernate.engine.spi.ActionQueue$2(org.hibernate.engine.spi.ActionQueue$ListProvider<T>).getOrInit(org.hibernate.engine.spi.ActionQueue) line: 1125	
			ExecutableList<T> list = get( instance );
/d,
null
			if ( list == null ) {
				list = init( instance );
/s,
org.hibernate.engine.spi.ActionQueue$2.init(org.hibernate.engine.spi.ActionQueue) line: 120	
/=
		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;
					}
					ExecutableList<AbstractEntityInsertAction> init(ActionQueue instance) {
						if ( instance.isOrderInsertsEnabled() ) {
/s,
org.hibernate.engine.spi.ActionQueue.isOrderInsertsEnabled() line: 765	
		return session.getFactory().getSessionFactoryOptions().isOrderInsertsEnabled();
false
/t,
						else {
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									false
							);
/t,
			}
			return list;
/t,
org.hibernate.engine.spi.ActionQueue.addAction(java.lang.Class<T>, T) line: 289	
		EXECUTABLE_LISTS_MAP.get( executableClass ).getOrInit( this ).add( action );
/pd,
this	org.hibernate.engine.spi.ActionQueue  (id=18788)	
	insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=20780)	
/s,
org.hibernate.engine.spi.ExecutableList<E>.add(E) line: 211	
		final E previousLast = sorter != null || executables.isEmpty() ? null : executables.get( executables.size() - 1 );
		boolean added = executables.add( executable ); / executables is an ArrayList,

		Serializable[] querySpaces = executable.getPropertySpaces();
/s,
org.hibernate.action.internal.EntityInsertAction(org.hibernate.action.internal.EntityAction).getPropertySpaces() line: 131	
		return persister.getPropertySpaces();
/s,
org.hibernate.persister.entity.SingleTableEntityPersister.getPropertySpaces() line: 513	
		return spaces;
[Language]
/ TODO
/t,
org.hibernate.engine.spi.ExecutableList<E>.add(E) line: 234	
		Serializable[] querySpaces = executable.getPropertySpaces();
/d,
		if ( this.querySpaces != null && querySpaces != null ) {
/j,
			Collections.addAll( this.querySpaces, querySpaces );
[Language]
		}
		return added;		
true
/t,
org.hibernate.engine.spi.ActionQueue.addAction(java.lang.Class<T>, T) line: 289	
		EXECUTABLE_LISTS_MAP.get( executableClass ).getOrInit( this ).add( action );
/d,
/t,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 279	
			addAction( AbstractEntityInsertAction.class, insert );
/d,
		}
		insert.makeEntityManaged();
/s,
org.hibernate.action.internal.EntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction).makeEntityManaged() line: 124	
		nullifyTransientReferencesIfNotAlready();
/ TODO
		final Object version = Versioning.getVersion( getState(), getPersister() );
0
		getSession().getPersistenceContext().addEntity(
				getInstance(),	/ Language Java
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),	/ Status.MANAGED
				getState(),	/ [Java,0]
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);
/s,
org.hibernate.action.internal.EntityInsertAction.getEntityKey() line: 70	
		return getSession().generateEntityKey( getId(), getPersister() ); / getId()==id==122	,
/s,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).generateEntityKey(java.io.Serializable, org.hibernate.persister.entity.EntityPersister) line: 338	
		return new EntityKey( id, persister );
/t,
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntity(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], org.hibernate.engine.spi.EntityKey, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 463	

/ Intermezzo

/ Eerder deden we,
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
		
/ Einde Intermezzo

		addEntity( entityKey, entity );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntity(org.hibernate.engine.spi.EntityKey, java.lang.Object) line: 385	
		entitiesByKey.put( key, entity );
/t,
		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(), / 122
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 511	
		/*
			IMPORTANT!!!

			The following instanceof checks and castings are intentional.

			DO NOT REFACTOR to make calls through the EntityEntryFactory interface, which would result
			in polymorphic call sites which will severely impact performance.

			When a virtual method is called via an interface the JVM needs to resolve which concrete
			implementation to call.  This takes CPU cycles and is a performance penalty.  It also prevents method
			in-ling which further degrades performance.  Casting to an implementation and making a direct method call
			removes the virtual call, and allows the methods to be in-lined.  In this critical code path, it has a very
			large impact on performance to make virtual method calls.
		*/
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
		entityEntryContext.addEntityEntry( entity, e );
/s,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 77	
	// IMPORTANT!!!!!
		//		add is called more than once of some entities.  In such cases the first
		//		call is simply setting up a "marker" to avoid infinite looping from reentrancy

		// any addition (even the double one described above) should invalidate the cross-ref array
		dirty = true;

		// Determine the appropriate ManagedEntity instance to use based on whether the entity is enhanced or not.
		// Throw an exception if entity is a mutable ManagedEntity that is associated with a different
		// PersistenceContext.
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null
					? nonEnhancedEntityXref.get( entity )
					: null;
		}
/t,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 92	
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=20116)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=19670)	
	entityInstance	domain.Language  (id=18907)	
	next	null	
	previous	null	
		if ( !alreadyAssociated ) {
/n,

entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=20839)	
	$assertionsDisabled	true	
	DEFAULT_DELETED_STATE	null	
	cachedEntityKey	null	
	compressedState	22	
	id	java.lang.Long  (id=18905)		/ 122
	loadedState	java.lang.Object[2]  (id=20234)		/ [Java,0]
	next	null	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
	rowId	null	
	version	java.lang.Integer  (id=20239)	
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=20116)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=19670)	
		$assertionsDisabled	true	
		DEFAULT_DELETED_STATE	null	
		cachedEntityKey	null	
		compressedState	102	
		id	java.lang.Long  (id=18905)	/ 122
		loadedState	null	
		next	null	
		persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
		persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
		rowId	null	
		version	null	
	entityInstance	domain.Language  (id=18907)	

		// associate the EntityEntry with the entity
		managedEntity.$$_hibernate_setEntityEntry( entityEntry );
/ vervang de entityEntry,
/ dus WH	,
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=20116)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=20839)	
		$assertionsDisabled	true	
		DEFAULT_DELETED_STATE	null	
		cachedEntityKey	null	
		compressedState	22	
		id	java.lang.Long  (id=18905)		/ 122
		loadedState	java.lang.Object[2]  (id=20234)		/ [Java,0]
		next	null	
		persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
		persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
		rowId	null	
		version	java.lang.Integer  (id=20239)	


		if ( alreadyAssociated ) {
			// if the entity was already associated with the context, skip the linking step.
			return;
		}
/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 544	
		entityEntryContext.addEntityEntry( entity, e );
/d,
this	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
	entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=20111)	
		nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=20114)	
			table	java.lang.Object[64]  (id=20145)	
				[42]	domain.Language  (id=18907)	
				[43]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=20116)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=20839)	
						$assertionsDisabled	true	
						DEFAULT_DELETED_STATE	null	
						cachedEntityKey	null	
						compressedState	22	
						id	java.lang.Long  (id=18905)	
						loadedState	java.lang.Object[2]  (id=20234)	
						next	null	
						persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
						persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=18911)	
						rowId	null	
						version	java.lang.Integer  (id=20239)	
					entityInstance	domain.Language  (id=18907)	
		return e;
/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntity(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], org.hibernate.engine.spi.EntityKey, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 464	
		addEntity( entityKey, entity );
		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(),
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);
/d,
/t,
org.hibernate.action.internal.EntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction).makeEntityManaged() line: 126	
		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),
				getState(),
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);
/d,
/t,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 280	
		insert.makeEntityManaged();
/d,
/t,
org.hibernate.engine.spi.ActionQueue.addInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 254	
		if ( nonNullableTransientDependencies == null ) {
			addResolvedEntityInsertAction( insert );
/d,
/t,
org.hibernate.engine.spi.ActionQueue.addAction(org.hibernate.action.internal.EntityInsertAction) line: 242	
		addInsertAction( action );
/d,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).addInsertAction(java.lang.Object[], java.io.Serializable, java.lang.Object, org.hibernate.persister.entity.EntityPersister, boolean, org.hibernate.event.spi.EventSource, boolean) line: 326	
		else {
			Object version = Versioning.getVersion( values, persister );
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
			source.getActionQueue().addAction( insert );
/d,
			return insert;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 278	
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/d,
		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntry(java.lang.Object) line: 433	
		return entityEntryContext.getEntityEntry( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
		
/ managed betekent managed door H.	, de entry als key met daarachter de entityEntry=data die de db ingaat 	, is er,
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null
					? nonEnhancedEntityXref.get( entity )
					: null;
		}

/ Intermezzo

this	org.hibernate.engine.internal.StatefulPersistenceContext  (id=18950)	
	entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=20111)	
		nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=20114)	
			table	java.lang.Object[64]  (id=20145)
				[43]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=20116)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=20839)	
						id	java.lang.Long  (id=18905)	
						loadedState	java.lang.Object[2]  (id=20234)	[Java,0]
						version	java.lang.Integer  (id=20239)
					entityInstance	domain.Language  (id=18907)	

/ In de entityEntry zit de data die daadwerkelijk de database ingaat	,
						
/ Einde Intermezzo

/t,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 227	
		// locate a ManagedEntity for the entity, but only if it is associated with the same PersistenceContext.
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
		// and get/return the EntityEntry from the ManagedEntry
		return managedEntity == null
				? null
				: managedEntity.$$_hibernate_getEntityEntry();	/= return entityEntry= data die de db ingaat,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 295	
		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
/d,
		if ( newEntry != original ) {
/j,
original	org.hibernate.engine.internal.MutableEntityEntry  (id=19670)	
	compressedState	102		/ SAVING
	id	java.lang.Long  (id=18905)	
	loadedState	null	
	version	null	
newEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=20839)	
	compressedState	22		/ MANAGED
	id	java.lang.Long  (id=18905)	
	loadedState	java.lang.Object[2]  (id=20234)	
	version	java.lang.Integer  (id=20239)	

			EntityEntryExtraState extraState = newEntry.getExtraState( EntityEntryExtraState.class );
			if ( extraState == null ) {
				newEntry.addExtraState( original.getExtraState( EntityEntryExtraState.class ) );
/ TODO
		return id;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 121
	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
			return performSave( entity, generatedId, persister, false, anything, source, true );
/d,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 191	
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 133	
		switch ( entityState ) {
			case TRANSIENT: {
				entityIsTransient( event, createCache );
/d,
				break;
			}
/t,
org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 776	
		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
			listener.onPersist( event );
/d,
/t,
org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 754	
	@Override
	public void persist(String entityName, Object object) throws HibernateException {
		firePersist( new PersistEvent( entityName, object, this ) )
/d,
/t,
	@Override
	public void persist(Object object) throws HibernateException {
		persist( null, object );
	}
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1153	
		try {
			internalGetSession().persist( entity );
/d,
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 582	
        try {
            transactionIsRequired();
            getEntityManager().persist(entity);
/d,
/t,
repository.LanguageDao.insertInTx() line: 84	
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
/d,
		l=new Language();
		l.setName("Java");
		em1.persist(l);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 579	
            transactionIsRequired();
            getEntityManager().persist(entity);
/s,
    // JPA 7.9.1 if invoked without a JTA transaction and a transaction scoped persistence context is used,
    // will throw TransactionRequiredException for any calls to entity manager remove/merge/persist/refresh.
    private void transactionIsRequired() {
        if (!this.isExtendedPersistenceContext() && !this.isInTx()) {	/ this.isExtendedPersistenceContext()==false
            throw JpaLogger.ROOT_LOGGER.transactionRequired();
        }
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.isInTx() line: 105	
        return TransactionUtil.isInTx(transactionManager);

this	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=21347)	
	transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18755)	
	transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=18794)	
/s,
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 56	
/=
public class TransactionUtil {
    public static boolean isInTx(TransactionManager transactionManager) {
        Transaction tx = getTransaction(transactionManager);
        if (tx == null || !TxUtils.isActive(tx))
            return false;
        return true;			/ straks als we hier terugkomen	, komen we hier uit,
    }		
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getTransaction(javax.transaction.TransactionManager) line: 93	
        try {
            return transactionManager.getTransaction();	/ transactionManager is een arjuna ding,
        } catch (SystemException e) {
            throw JpaLogger.ROOT_LOGGER.errorGettingTransaction(e);
        }
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
        return transactionManager.getTransaction() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52	
		return TransactionImple.getTransaction();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1062	
/=
public class TransactionImple implements javax.transaction.Transaction,
		com.arjuna.ats.jta.transaction.Transaction
{
	public static final TransactionImple getTransaction()
	{
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:a8 status: ActionStatus.RUNNING
		if (current != null)
		{
			final Uid txid = current.get_uid();
0:ffff0a26785d:22d14db8:5ae6b6ab:a8

			tx = (TransactionImple) _transactions.get(txid);
TransactionImple < ac, BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:a8 status: ActionStatus.RUNNING >
			if (tx == null)
				tx = new TransactionImple(current);
		}

		return tx;
	}	
...
/t,
this	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=21347)	
	transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18755)	
	transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=18794)	
/s,
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 56	
/=
public class TransactionUtil {
    public static boolean isInTx(TransactionManager transactionManager) {
        Transaction tx = getTransaction(transactionManager);
/d,
        if (tx == null || !TxUtils.isActive(tx))
/s,
org.jboss.tm.TxUtils.isActive(javax.transaction.Transaction) line: 77	
      try
      {
         int status = tx.getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getStatus() line: 353	
		int status = javax.transaction.Status.STATUS_NO_TRANSACTION;
		
		if (_theTransaction != null)
		{
			status = StatusConverter.convert(_theTransaction.status()); 
/ _theTransaction=BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:a8 status: ActionStatus.RUNNING
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).status() line: 387	
        int s = ActionStatus.INVALID;

            s = actionStatus;		/ RUNNING
/t,
/s,
com.arjuna.ats.internal.jta.utils.arjunacore.StatusConverter.convert(int) line: 53	
		switch (status)
		{
		case ActionStatus.RUNNING:
			return javax.transaction.Status.STATUS_ACTIVE;
...
/t,
/s,
org.jboss.as.jpa.transaction.TransactionUtil.isInTx(javax.transaction.TransactionManager) line: 56	
/=
public class TransactionUtil {
    public static boolean isInTx(TransactionManager transactionManager) {
        Transaction tx = getTransaction(transactionManager);
        if (tx == null || !TxUtils.isActive(tx))
/d,
/n,
            return false;
/j,
        return true;	
    }
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
        try {
            transactionIsRequired();
/d,
            getEntityManager().persist(entity);	
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getEntityManager() line: 87	
        boolean isInTx;

        isInTx = TransactionUtil.isInTx(transactionManager);

        if (isInTx) {
            entityManager = getOrCreateTransactionScopedEntityManager(emf, puScopedName, properties, synchronizationType);
/s,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 155	

        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
puScopedName=test.war#arquillian-forge4-persistence-unit-1
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getTransactionScopedEntityManager(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 69	
/=
public class TransactionUtil {
    /**
     * Get current persistence context.  Only call while a transaction is active in the current thread.
     *
     * @param puScopedName
     * @return
     */
    public static EntityManager getTransactionScopedEntityManager(String puScopedName, TransactionSynchronizationRegistry tsr) {
        return getEntityManagerInTransactionRegistry(puScopedName, tsr);
    }
/s,
org.jboss.as.jpa.transaction.TransactionUtil.getEntityManagerInTransactionRegistry(java.lang.String, javax.transaction.TransactionSynchronizationRegistry) line: 116	
/=
public class TransactionUtil {
        return (EntityManager)tsr.getResource(scopedPuName);
    }
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106	
        return delegate.getResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 116	
        TransactionImple transactionImple = getTransactionImple();
        return transactionImple.getTxLocalResource(key);
/s,
/ vraagt het aan de TM	, logisch,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getTransactionImple() line: 218	
            transactionImple = (TransactionImple)tm.getTransaction();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getTransaction() line: 109	
        return transactionManager.getTransaction() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.getTransaction() line: 52
		return TransactionImple.getTransaction();
/s,
/ static method,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1057	
		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:a8 status: ActionStatus.ABORT_ONLY
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
	return tx;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126	
        TransactionImple transactionImple = getTransactionImple();
/d,
        return transactionImple.getTxLocalResource(key);	/ key=test.war#arquillian-forge4-persistence-unit-1
/=
transactionImple._txLocalResources.get(key)
...
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 156	
        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
/d,
null
        if (entityManager == null) {
            entityManager = createEntityManager(emf, properties, synchronizationType);
...
/s,
org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 83	
...
		postInit();
/s,
		// NOTE : pulse() already handles auto-join-ability correctly
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse(); 	/ (*)
/ er is nog geen Session,
/s,
org.hibernate.jpa.internal.EntityManagerImpl.internalGetSession() line: 133	
		if ( session == null ) {
			SessionBuilderImplementor sessionBuilder = internalGetEntityManagerFactory().getSessionFactory().withOptions(); 
			sessionBuilder.owner( this );
			sessionBuilder.autoJoinTransactions( getSynchronizationType() == SynchronizationType.SYNCHRONIZED );

sessionBuilder	org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl  (id=21488)	
	autoJoinTransactions	true	
	sessionFactory	org.hibernate.internal.SessionFactoryImpl  (id=18571)	
	sessionOwner	org.hibernate.jpa.internal.EntityManagerImpl  (id=21459)
	
			session = sessionBuilder.openSession();
/s,
org.hibernate.internal.SessionFactoryImpl$SessionBuilderImpl.openSession() line: 1318	
			final SessionImpl session = new SessionImpl(
					connection,
					sessionFactory,
					sessionOwner,
					getTransactionCoordinator(),	/ null
					getJdbcCoordinator(),	/ null
					getTransaction(),	/ null
					getTransactionCompletionProcesses(),	/ null
					autoJoinTransactions,	/ true
					sessionFactory.settings.getRegionFactory().nextTimestamp(),
					interceptor,
					statementInspector,
					flushBeforeCompletion,
					autoClose,
					connectionReleaseMode,
					tenantIdentifier
			);
/s,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 246	

		this.actionQueue = new ActionQueue( this );
		this.persistenceContext = new StatefulPersistenceContext( this );
		
		this.autoCloseSessionEnabled = autoCloseSessionEnabled;	/ false
		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;	/ false
		
		initializeFromSessionOwner( sessionOwner );

		if ( statementInspector == null ) {
			this.statementInspector = new StatementInspector() {
				@Override
				@SuppressWarnings("deprecation")
				public String inspect(String sql) {
					return SessionImpl.this.interceptor.onPrepareStatement( sql );
				}
			};
		}

		this.jdbcSessionContext = new JdbcSessionContextImpl( factory, this.statementInspector );

		if ( transactionCoordinator == null ) {
			this.isTransactionCoordinatorShared = false;	/ TODO
			this.connectionReleaseMode = connectionReleaseMode;	/ AFTER_STATEMENT
			this.autoJoinTransactions = autoJoinTransactions;	/ true
	
			this.jdbcCoordinator = new JdbcCoordinatorImpl( connection, this );
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(
					this.jdbcCoordinator,
					this
			);
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 25	
		return new JtaTransactionCoordinatorImpl(
				this,
				owner,
				options.shouldAutoJoinTransaction()
		);
	}
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 87
		...
		this.jtaPlatform = jdbcSessionContext.getServiceRegistry().getService( JtaPlatform.class );
		...
		pulse();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 132	

/ we zijn onder (*)	,
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse(); 	/ (*)
/ en we zitten nog in internalGetSession()	, dus de pulse() bij (*) zal overbodig zijn, 
/ WH is die .pulse() bij (*) alleen overbodig als de session er nog niet is, TODO

		if ( !autoJoinTransactions ) {
			return;
		}

		if ( synchronizationRegistered ) {
			return;
		}

		// Can we resister a synchronization according to the JtaPlatform?
		if ( !jtaPlatform.canRegisterSynchronization() ) {
			log.trace( "JTA platform says we cannot currently resister synchronization; skipping" );
			return;
		}

		joinJtaTransaction();
/s,
	/**
	 * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the
	 * RegisteredSynchronization with the JTA system
	 */
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 154	
		if ( synchronizationRegistered ) {
			return;
		}
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.getSynchronizationCallbackCoordinator() line: 122	
		if ( callbackCoordinator == null ) {
			callbackCoordinator = performJtaThreadTracking
/j,
					? new SynchronizationCallbackCoordinatorTrackingImpl( this )
		return callbackCoordinator;
/t,
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.<init>(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator) line: 29	
/=
/**
 * The JTA {@link javax.transaction.Synchronization} Hibernate registers when needed for JTA callbacks.
 * <p/>
 * Note that we split the notion of the registered Synchronization and the processing of the Synchronization callbacks
 * mainly to account for "separation of concerns", but also so that the transaction engine does not have to hold
 * reference to the actual Synchronization that gets registered with the JTA system.
 *
 * @author Steve Ebersole
 */
public class RegisteredSynchronization implements Synchronization {
	private static final Logger log = logger( RegisteredSynchronization.class );

	private final SynchronizationCallbackCoordinator synchronizationCallbackCoordinator;

	public RegisteredSynchronization(SynchronizationCallbackCoordinator synchronizationCallbackCoordinator) {
		this.synchronizationCallbackCoordinator = synchronizationCallbackCoordinator;
	}

	@Override
	public void beforeCompletion() {
		log.trace( "Registered JTA Synchronization : beforeCompletion()" );

		synchronizationCallbackCoordinator.beforeCompletion();
	}

	@Override
	public void afterCompletion(int status) {
		log.tracef( "Registered JTA Synchronization : afterCompletion(%s)", status );

		synchronizationCallbackCoordinator.afterCompletion( status );
	}
}
/t,
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform(org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform).registerSynchronization(javax.transaction.Synchronization) line: 126	
		getSynchronizationStrategy().registerSynchronization( synchronization );
/s,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29	
/=
/**
 * Implementation of the {@link JtaSynchronizationStrategy} contract based on using a
 * {@link TransactionSynchronizationRegistry}
 *
 * @author Steve Ebersole
 */
public class SynchronizationRegistryBasedSynchronizationStrategy implements JtaSynchronizationStrategy {
	private final SynchronizationRegistryAccess synchronizationRegistryAccess;

	public SynchronizationRegistryBasedSynchronizationStrategy(SynchronizationRegistryAccess synchronizationRegistryAccess) {
		this.synchronizationRegistryAccess = synchronizationRegistryAccess;
	}

	@Override
	public void registerSynchronization(Synchronization synchronization) {
		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
				synchronization
		);
	}
/s,
org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform$1.getSynchronizationRegistry() line: 47	
/=
    public JBossAppServerJtaPlatform(final JtaManager jtaManager) {
        this.jtaManager = jtaManager;
        this.synchronizationStrategy = new SynchronizationRegistryBasedSynchronizationStrategy(new SynchronizationRegistryAccess() {
            @Override
            public TransactionSynchronizationRegistry getSynchronizationRegistry() {
                return jtaManager.getSynchronizationRegistry();
            }
        });
    }
/s,
org.jboss.as.jpa.transaction.JtaManagerImpl.getSynchronizationRegistry() line: 47	
/=
/**
 * passes the TM and TSR into the persistence provider integration classes
 *
 * @author Scott Marlow
 */
public class JtaManagerImpl implements JtaManager {

    private final TransactionManager transactionManager;
    private final TransactionSynchronizationRegistry transactionSynchronizationRegistry;

    public JtaManagerImpl(TransactionManager transactionManager, TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
        this.transactionManager = transactionManager;
        this.transactionSynchronizationRegistry = transactionSynchronizationRegistry;
    }

    @Override
    public TransactionSynchronizationRegistry getSynchronizationRegistry() {
        return transactionSynchronizationRegistry;
    }
/t,
org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy.registerSynchronization(javax.transaction.Synchronization) line: 29	
		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
				synchronization
		);
/pd,	
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 68	
            Transaction tx = transactionManager.getTransaction();
TransactionImple < ac, BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:de status: ActionStatus.RUNNING >

            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
			
this	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20541)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20652)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=21376)	
				key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19908)		 / de arjuna global tx,
				val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21370)
					jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=20652)	
						table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=21376)	
							[1]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=21369)	
								key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19908)	/ de arjuna global tx,
								val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21370)	/ pointer back
					jcaSyncs	java.util.ArrayList<E>  (id=21372)
[org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer@78df08e]					
					preJcaSyncs	java.util.ArrayList<E>  (id=21373)					
						elementData	java.lang.Object[10]  (id=21538)	
							[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21540)	
								synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=21544)	
							[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=21541)	
								manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19940)	
								scopedPuName	"test.war#arquillian-forge4-persistence-unit" (id=21546)	
					tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19908)	
TransactionImple < ac, BasicAction: 0:ffff0a26785d:22d14db8:5ae6b6ab:de status: ActionStatus.RUNNING >
			
            if (jcaOrderedLastSynchronization == null) {
/n,
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync);

this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=21370)	
	preJcaSyncs	java.util.ArrayList<E>  (id=21373)	
		elementData	java.lang.Object[10]  (id=21538)	
			[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=21540)	
				synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=21544)	
					target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=21674)	
						physicalTransactionDelegate	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=21688)	
							jtaTransactionAdapter	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl  (id=21700)	
								transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=19907)	
									transactionManager	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple  (id=19909)	
			[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=21541)	
				manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19940)	
				scopedPuName	"test.war#arquillian-forge4-persistence-unit" (id=21546)	
			[2]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=20692)	/ er bij,	
				synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=20679)	
					target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=20677)	
						physicalTransactionDelegate	null	
/ TODO
...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 159	
		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
/d,

/ WH,
this	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19916)	
	jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=18146)	
		jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=18143)	
			transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=19073)	
				interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19123)	
					table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=19954)	
							key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
							val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19933)	
								jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19123)	
								jcaSyncs	java.util.ArrayList<E>  (id=19956)	
								preJcaSyncs	java.util.ArrayList<E>  (id=19936)	
									elementData	java.lang.Object[10]  (id=20060)	
										[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=20074)	
												registrationThreadId	370	
												target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=20247)	
										[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=20075)	
										[2]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=19929)	
												registrationThreadId	370	
												target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19916)	
								tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
/ [2] hebben we zojuist toegevoegd	,


		getSynchronizationCallbackCoordinator().synchronizationRegistered();
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl.synchronizationRegistered() line: 77	
		registrationThreadId = Thread.currentThread().getId();

this	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=20677)	
	callbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=20679)	
		registrationThreadId	247	
	physicalTransactionDelegate	null	
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.joinJtaTransaction() line: 160	
		getSynchronizationCallbackCoordinator().synchronizationRegistered();
/d,
		synchronizationRegistered = true;
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 147	
		joinJtaTransaction();
/d,
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, boolean) line: 87
		...
		this.jtaPlatform = jdbcSessionContext.getServiceRegistry().getService( JtaPlatform.class );
		...
		pulse();
/d,
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl.buildTransactionCoordinator(org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner, org.hibernate.resource.transaction.TransactionCoordinatorBuilder$TransactionCoordinatorOptions) line: 25	
		return new JtaTransactionCoordinatorImpl(
				this,
				owner,
				options.shouldAutoJoinTransaction()
		);
	}
/d,
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 278	
			this.transactionCoordinator = getTransactionCoordinatorBuilder().buildTransactionCoordinator(
					this.jdbcCoordinator,
					this
			);
/d,
this	org.hibernate.internal.SessionImpl  (id=20669)	
	transactionCoordinator	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=20677)	
		callbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=20679)	
		physicalTransactionDelegate	null	

			this.currentHibernateTransaction = getTransaction();
/s,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 313	
		if ( this.currentHibernateTransaction == null 
/j,
			|| this.currentHibernateTransaction.getStatus() != TransactionStatus.ACTIVE ) {
			this.currentHibernateTransaction = new TransactionImpl( getTransactionCoordinator() );
/s,
org.hibernate.engine.transaction.internal.TransactionImpl.<init>(org.hibernate.resource.transaction.TransactionCoordinator) line: 36	
		this.transactionCoordinator = transactionCoordinator;
		this.transactionDriverControl = transactionCoordinator.getTransactionDriverControl();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.getTransactionDriverControl() line: 203	
		if ( physicalTransactionDelegate == null ) {
			physicalTransactionDelegate = makePhysicalTransactionDelegate();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.makePhysicalTransactionDelegate() line: 220	
		else {
			adapter = makeTransactionManagerAdapter();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.makeTransactionManagerAdapter() line: 261	
			else {
				return new JtaTransactionAdapterTransactionManagerImpl( transactionManager );
/s,
/**
 * JtaTransactionAdapter for coordinating with the JTA TransactionManager
 *
 * @author Steve Ebersole
 */
public class JtaTransactionAdapterTransactionManagerImpl implements JtaTransactionAdapter {
/ heeft begin, commit, rollback, setRollbackOnly, ...	 methods,
/=
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.<init>(javax.transaction.TransactionManager) line: 30	
		this.transactionManager = transactionManager;
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.makePhysicalTransactionDelegate() line: 234	
		else {
			adapter = makeTransactionManagerAdapter();
/d,
		return new TransactionDriverControlImpl( adapter );
/s,
	/**
	 * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the
	 * local transaction ({@link org.hibernate.Transaction} to callback into this
	 * TransactionCoordinator for the purpose of driving the underlying JTA transaction.
	 */
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl.<init>(org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl, org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapter) line: 378	
/ heeft begin, commit, rollback, getStatus, markRollbackOnly methods,
	this.jtaTransactionAdapter=...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.getTransactionDriverControl() line: 205	
			physicalTransactionDelegate = makePhysicalTransactionDelegate();
/d,
		}
		return physicalTransactionDelegate;
		
this	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19916)	
	physicalTransactionDelegate	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=20341)	
		jtaTransactionAdapter	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl  (id=20339)	
			transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18476)	
/t,
org.hibernate.internal.SessionImpl(org.hibernate.internal.AbstractSessionImpl).getTransaction() line: 315	
			this.currentHibernateTransaction = new TransactionImpl( getTransactionCoordinator() );
/d,
this	org.hibernate.internal.SessionImpl  (id=19833)	
	currentHibernateTransaction	org.hibernate.engine.transaction.internal.TransactionImpl  (id=20327)	
		transactionCoordinator	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19916)	
			physicalTransactionDelegate	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=20341)	
				jtaTransactionAdapter	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl  (id=20339)	
					transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18476)	
		transactionDriverControl	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=20341)	
			jtaTransactionAdapter	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl  (id=20339)	
/ we zien de transactionManager op 2 plaatsen	,

		}
		getTransactionCoordinator().pulse();
		return currentHibernateTransaction;
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.pulse() line: 137	
		if ( synchronizationRegistered ) {
			return;
		}
/t,
org.hibernate.internal.SessionImpl.<init>(java.sql.Connection, org.hibernate.internal.SessionFactoryImpl, org.hibernate.engine.spi.SessionOwner, org.hibernate.resource.transaction.TransactionCoordinator, org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl, org.hibernate.Transaction, org.hibernate.engine.spi.ActionQueue$TransactionCompletionProcesses, boolean, long, org.hibernate.Interceptor, org.hibernate.resource.jdbc.spi.StatementInspector, boolean, boolean, org.hibernate.ConnectionReleaseMode, java.lang.String) line: 278	
			this.currentHibernateTransaction = getTransaction();
/d,
...
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 174	
		// NOTE : pulse() already handles auto-join-ability correctly
		( (SessionImplementor) internalGetSession() ).getTransactionCoordinator().pulse();
/pd,
/d,
/ want de pulse() is al, 
		setDefaultProperties();
/s,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).setDefaultProperties() line: 285	
		if ( properties.get( AvailableSettings.FLUSH_MODE ) == null ) {
			properties.put( AvailableSettings.FLUSH_MODE, getSession().getFlushMode().toString() );
		}
		if ( properties.get( AvailableSettings.LOCK_SCOPE ) == null ) {
			this.properties.put( AvailableSettings.LOCK_SCOPE, PessimisticLockScope.EXTENDED.name() );
		}
		if ( properties.get( AvailableSettings.LOCK_TIMEOUT ) == null ) {
			properties.put( AvailableSettings.LOCK_TIMEOUT, LockOptions.WAIT_FOREVER );
		}
		if ( properties.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) == null ) {
			properties.put( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE, CacheModeHelper.DEFAULT_RETRIEVE_MODE );
		}
		if ( properties.get( AvailableSettings.SHARED_CACHE_STORE_MODE ) == null ) {
			properties.put( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheModeHelper.DEFAULT_STORE_MODE );
		}
	}
/t,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).postInit() line: 177	
		setDefaultProperties();
/d,
this	org.hibernate.jpa.internal.EntityManagerImpl  (id=19795)	
	properties	java.util.HashMap<K,V>  (id=19808)	

{javax.persistence.lock.timeout=-1, org.hibernate.flushMode=AUTO, javax.persistence.cache.retrieveMode=USE, javax.persistence.lock.scope=EXTENDED, javax.persistence.cache.storeMode=USE}

		applyProperties();
/s,
	private void applyProperties() {
		getSession().setFlushMode( ConfigurationHelper.getFlushMode( properties.get( AvailableSettings.FLUSH_MODE ) ) );
		setLockOptions( this.properties, this.lockOptions );
		getSession().setCacheMode(
				CacheModeHelper.interpretCacheMode(
						currentCacheStoreMode(),
						currentCacheRetrieveMode()
				)
		);
	}
this	org.hibernate.jpa.internal.EntityManagerImpl  (id=19795)	
	lockOptions	org.hibernate.LockOptions  (id=19807)	
		aliasSpecificLockModes	null	
		lockMode	org.hibernate.LockMode  (id=20453)	
		scope	true	
		timeout	-1	
	session	org.hibernate.internal.SessionImpl  (id=19833)	
		cacheMode	org.hibernate.CacheMode  (id=20357)	
			name	"NORMAL" (id=20448)	
		flushMode	org.hibernate.FlushMode  (id=20358)	
			name	"AUTO" (id=20422)	
/t,
org.hibernate.jpa.internal.EntityManagerImpl.<init>(org.hibernate.jpa.internal.EntityManagerFactoryImpl, javax.persistence.PersistenceContextType, javax.persistence.SynchronizationType, javax.persistence.spi.PersistenceUnitTransactionType, boolean, java.lang.Class, java.util.Map) line: 84	
		postInit();
/d,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 158	
            entityManager = createEntityManager(emf, properties, synchronizationType);
/d,
entityManager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19795)	
	session	org.hibernate.internal.SessionImpl  (id=19833)	
		currentHibernateTransaction	org.hibernate.engine.transaction.internal.TransactionImpl  (id=20327)	
			transactionCoordinator	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19916)	
			transactionDriverControl	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl  (id=20341)	
				jtaTransactionAdapter	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl  (id=20339)	
					transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18476)	
		persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=19837)	
			entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=19844)	
		transactionCoordinator	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=19916)	
			jtaPlatform	org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform  (id=18146)	
				jtaManager	org.jboss.as.jpa.transaction.JtaManagerImpl  (id=18143)	
					transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18476)	
					transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=19073)	
						delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=19103)	
						interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19123)	
						transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18476)	

            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 73

        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);
/s,
org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization.<init>(javax.persistence.EntityManager, java.lang.String) line: 152	
/=
    /**
     * Using the TransactionListener, we can detect Synchronization.afterCompletion() being called from a
     * background thread, while the application may still be actively using the EntityManager.
     * We need to ensure that the background thread does not close the EntityManager while the application thread
     * is actively using it.
     *
     * We know when the application thread is associated with the transaction and can defer closing the EntityManager
     * until both conditions are met:
     *
     *   1. application is disassociated from transaction
     *   2. Synchronization.afterCompletion has been called
     *
     * See discussions for more details about how we arrived at using the TransactionListener:
     *     https://developer.jboss.org/message/919807
     *     https://developer.jboss.org/thread/252572
     */
    private static class SessionSynchronization implements Synchronization, TransactionListener {
            this.manager = session;
            this.scopedPuName = scopedPuName;
        }
/t,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 74	
        SessionSynchronization sessionSynchronization = new SessionSynchronization(entityManager, puScopedName);
/d,
        tsr.registerInterposedSynchronization(sessionSynchronization);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.registerInterposedSynchronization(javax.transaction.Synchronization) line: 68	

/ er voor,
this	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=19073)	
	delegate	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple  (id=19103)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19123)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=19954)	
				key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
				val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19933)	
					jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19123)	
					jcaSyncs	java.util.ArrayList<E>  (id=19956)	
					preJcaSyncs	java.util.ArrayList<E>  (id=19936)	
[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@6bb9eec2, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@686445f2, org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@7af59ed3]
					tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=18476)

			Transaction tx = transactionManager.getTransaction();
            JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx);
            if (jcaOrderedLastSynchronization == null) {
/n,
            jcaOrderedLastSynchronization.registerInterposedSynchronization(sync);

/ er na,
this	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=19073)	
	interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=19123)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=19954)	
			[0]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=19932)	
				val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=19933)	
					preJcaSyncs	java.util.ArrayList<E>  (id=19936)	
[org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@6bb9eec2, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@686445f2, org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@7af59ed3, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@66526d56]									<- nieuw,

/t,
org.jboss.as.jpa.transaction.TransactionUtil.registerSynchronization(javax.persistence.EntityManager, java.lang.String, javax.transaction.TransactionSynchronizationRegistry, javax.transaction.TransactionManager) line: 76
	
        tsr.registerInterposedSynchronization(sessionSynchronization);
/d,
        try {
            getTransactionListenerRegistry(transactionManager).addListener(getTransaction(transactionManager), sessionSynchronization, eventTypes);
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).addListener(javax.transaction.Transaction, org.jboss.tm.listener.TransactionListener, java.util.EnumSet<org.jboss.tm.listener.EventType>) line: 172	
	
        Collection<TransactionListener> listeners = getListeners(transaction, true);
[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@686445f2]
        if (listeners != null) {
            listeners.add(listener);

            // if transaction is already associated with the current thread notify this listener
/ TODO getTransaction() is assoc. met current thread?
            try {
                if (transaction.equals(getTransaction()) && types.contains(EventType.ASSOCIATED))
/j,
                    listener.onEvent(new TransactionEvent(transaction, EnumSet.of(EventType.ASSOCIATED)));
/ NIETS,
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager.getOrCreateTransactionScopedEntityManager(javax.persistence.EntityManagerFactory, java.lang.String, java.util.Map, javax.persistence.SynchronizationType) line: 163	

            entityManager = createEntityManager(emf, properties, synchronizationType);
            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);
/d,
            TransactionUtil.putEntityManagerInTransactionRegistry(scopedPuName, entityManager, transactionSynchronizationRegistry);
/s,
org.jboss.as.jpa.transaction.TransactionUtil.putEntityManagerInTransactionRegistry(java.lang.String, javax.persistence.EntityManager, javax.transaction.TransactionSynchronizationRegistry) line: 127	
        tsr.putResource(scopedPuName, entityManager);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.putResource(java.lang.Object, java.lang.Object) line: 112	
        delegate.putResource(key, value);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 100	
        TransactionImple transactionImple = getTransactionImple();
        transactionImple.putTxLocalResource(key, value);
key	"test.war#arquillian-forge4-persistence-unit-1" (id=19068)	
value	org.hibernate.jpa.internal.EntityManagerImpl  (id=19795)

transactionImple	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=18479)		
_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=19126)	
	m	java.util.HashMap<K,V>  (id=19128)	
		table	java.util.HashMap$Node<K,V>[16]  (id=20948)	
			[10]	java.util.HashMap$Node<K,V>  (id=20952)	
				key	org.jboss.jca.core.connectionmanager.transaction.LockKey  (id=21024)	
				value	java.util.concurrent.locks.ReentrantLock  (id=21026)	
			[12]	java.util.HashMap$Node<K,V>  (id=20954)
				key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=20998)	
				value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20999)		
			[13]	java.util.HashMap$Node<K,V>  (id=20955)	
				key	"__TX_LISTENERS" (id=20329)	
				next	java.util.HashMap$Node<K,V>  (id=21028)	
					key	"test.war#arquillian-forge4-persistence-unit" (id=21030)	
					value	org.hibernate.jpa.internal.EntityManagerImpl  (id=18509)	
				value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=20916)	
			[14]	java.util.HashMap$Node<K,V>  (id=20956)	
				key	"test.war#arquillian-forge4-persistence-unit-1" (id=19068)	
/t,
org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580	
            getEntityManager().persist(entity);
/pd,
...	
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 98	
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntry(java.lang.Object) line: 433	
		return entityEntryContext.getEntityEntry( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		// locate a ManagedEntity for the entity, but only if it is associated with the same PersistenceContext.
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	

		else {
			return nonEnhancedEntityXref != null
/n,
					? nonEnhancedEntityXref.get( entity )
					: null;
		}
/t,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
null
		// and get/return the EntityEntry from the ManagedEntry
		return managedEntity == null
				? null
				: managedEntity.$$_hibernate_getEntityEntry();
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 99	
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
/d,
null
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).getEntityState(java.lang.Object, java.lang.String, org.hibernate.engine.spi.EntityEntry, org.hibernate.engine.spi.SessionImplementor) line: 510	

		// the entity is not associated with the session, so
		// try interceptor and unsaved-value

		if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source ) ) {
/s,
org.hibernate.engine.internal.ForeignKeys.isTransient(java.lang.String, java.lang.Object, java.lang.Boolean, org.hibernate.engine.spi.SessionImplementor) line: 225	

		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
SingleTableEntityPersister(domain.Language)
/ Deze was er al, 	en heeft dus niets te maken met pg of h2, of local tx ... TODO	,
		isUnsaved = persister.isTransient( entity, session );
/ true, want entity.id==null,
		if ( isUnsaved != null ) {
			return isUnsaved;
		}
			if ( traceEnabled ) {
				LOG.tracev( "Transient instance of: {0}", getLoggableName( entityName, entity ) );
			}
			return EntityState.TRANSIENT;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 100	
		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
null
		EntityState entityState = getEntityState( entity, entityName, entityEntry, source );
/d,
TRANSIENT
			case TRANSIENT: {
				entityIsTransient( event, createCache );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189	

			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 100	
		EntityPersister persister = source.getEntityPersister( entityName, entity );
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
			return performSave( entity, generatedId, persister, false, anything, source, true );
...
/s,
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/s,
/ CONSTRUCTION,
org.hibernate.id.enhanced.SequenceStructure.buildCallback(org.hibernate.engine.spi.SessionImplementor) line: 89	
	@Override
	public AccessCallback buildCallback(final SessionImplementor session) {
		if ( sql == null ) {
			throw new AssertionFailure( "SequenceStyleGenerator's SequenceStructure was not properly initialized" );
		}

		return new AccessCallback() {								<-
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
					...
/t,
/s,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
		// IMPL NOTE : this method is called concurrently and is
		// not synchronized. It is very important to work on the
		// local variable: the field lastSourceValue is not
		// reliable as it might be mutated by multipled threads.
		// The lastSourceValue field is only accessed by tests,
		// so this is not a concern.
		IntegralDataTypeHolder value = callback.getNextValue();
/s,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 92	
/=
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
sql=call next value for hibernate_sequence
/ dit is h2 dialect,
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.buildPreparedStatementPreparationTemplate(java.lang.String, boolean) line: 82	
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).<init>(org.hibernate.engine.jdbc.internal.StatementPreparerImpl, java.lang.String) line: 157	
/=
	private abstract class StatementPreparationTemplate {
		protected final String sql;

		protected StatementPreparationTemplate(String incomingSql) {			/ nu,
			final String inspectedSql = jdbcCoordinator.getJdbcSessionOwner()
					.getJdbcSessionContext()
					.getStatementInspector()
					.inspect( incomingSql );
			this.sql = inspectedSql == null ? incomingSql : inspectedSql;
		}
		public PreparedStatement prepareStatement() {		/ straks,	
			...
/s,
org.hibernate.internal.SessionImpl$1.inspect(java.lang.String) line: 259	
/=
		if ( statementInspector == null ) {
			this.statementInspector = new StatementInspector() {
				@Override
				@SuppressWarnings("deprecation")
				public String inspect(String sql) {
					return SessionImpl.this.interceptor.onPrepareStatement( sql );	/= return sql;
				}
			};
		}	
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
/pd,
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 167	
/=
	private abstract class StatementPreparationTemplate {
		protected final String sql;

		protected StatementPreparationTemplate(String incomingSql) {			/ zonet,
			final String inspectedSql = jdbcCoordinator.getJdbcSessionOwner()
					.getJdbcSessionContext()
					.getStatementInspector()
					.inspect( incomingSql );
			this.sql = inspectedSql == null ? incomingSql : inspectedSql;
		}
		public PreparedStatement prepareStatement() {				/ nu,
			try {
					preparedStatement = doPrepare();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 85	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );	<-
			}
		};
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
		return logicalConnection().getPhysicalConnection();
...
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 85	
		if ( physicalConnection == null ) {
			try {
				physicalConnection = jdbcConnectionAccess.obtainConnection();
/s,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
			try {
				return connectionProvider.getConnection();
/s,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/s,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
        return delegate.getConnection();
/s,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 739	

      //it is an explicit spec requirement that equals be used for matching rather than ==.
      if (!pool.getManagedConnectionFactory().equals(mcf))
	  
mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=21151)	
	jndiName	"java:jboss/datasources/RemoteExampleDS" (id=21158)	
	xaDataSourceClass	"org.h2.jdbcx.JdbcDataSource" (id=21256)
	password	"sa" (id=21248)	
	userName	"sa" (id=21253)
	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
null
      ConnectionListener cl = getManagedConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 401
         if (!interleaving)
/j,
         {
            trackByTransaction = tx;
      return super.getManagedConnection(trackByTransaction, subject, cri);
/s,
   /**
    * Get the managed connection from the pool.
    *
    * @param transaction the transaction for track by transaction
    * @param subject the subject
    * @param cri the ConnectionRequestInfo
    * @return a managed connection
	*
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 578	
      try
      {
         return pool.getConnection(transaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 566	
      // Get specific managed connection pool key
      Object key = getKey(subject, cri, separateNoTx);	/ Boolean.FALSE
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getManagedConnectionPool(java.lang.Object, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 295	
		ManagedConnectionPool mcp = mcpPools.get(key);
mcpPools={false=SemaphoreConcurrentLinkedQueueManagedConnectionPool@777095ee[pool=RemoteExampleDS]}  
         return mcp;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 584	
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
/d,
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/s,
   /**
    * Get any transaction synchronization registry associated with the pool.
    * @return The value
    */
      if (getTransactionIntegration() != null)
         return getTransactionIntegration().getTransactionSynchronizationRegistry();
/t,
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;			/=  return transactionImple.get_uid();
0:ffffbea85a97:-35437ec6:5af567cc:60
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 659	

      try
      {
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
...
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126	
        TransactionImple transactionImple = getTransactionImple();	/= (TransactionImple)tm.getTransaction(); TODO tsr.tm,
        return transactionImple.getTxLocalResource(key);
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 660	
      try
      {
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
null	
		return null;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 596	
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
null
      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);
      }
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 699	

      // Need a new one for this transaction
      // This must be done outside the tx local lock, otherwise
      // the tx timeout won't work and get connection can do a lot of other work
      // with many opportunities for deadlocks.
      // Instead we do a double check after we got the transaction to see
      // whether another thread beat us to the punch.
      ConnectionListener cl = mcp.getConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 350	

            // We have a permit to get a connection. Is there one in the pool already?
            ConnectionListenerWrapper clw = null;
            do 
            {
               if (!isRunning()) /= !!isShutdown()
/n,
               {
                  pool.getLock().release();

                  throw new ResourceException(
                     bundle.thePoolHasBeenShutdown(pool.getName(),
                                                   Integer.toHexString(System.identityHashCode(this))));
               }

               if (fifo)
/n,
               {
                  clw = clq.pollFirst();
               }
               else
/j,
               {
                  clw = clq.pollLast();
               }		 
null
            // OK, we couldnt find a working connection from the pool. Make
            // a new one.
            try 
            {
               // No, the pool was empty, so we have to make a new one.
               clw = new ConnectionListenerWrapper(createConnectionEventListener(subject, cri), true, true);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1320

      ManagedConnection mc = mcf.createManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).createManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 416	
         else
         {
            return getXAManagedConnection(subject, cri);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 484
	
      XAConnection xaConnection = null;
      Properties props = getConnectionProperties(null, subject, cri);
{user=sa, password=sa}
      try
      {
         final String user = props.getProperty("user");
         final String password = props.getProperty("password");

         xaConnection = (user != null)
            ? getXADataSource().getXAConnection(user, password)	<-
            : getXADataSource().getXAConnection();
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXADataSource() line: 612	
      return xads;
ds0: url=jdbc:h2:tcp://localhost/~/h2/test user=
/t,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 492	
         xaConnection = (user != null)
            ? getXADataSource().getXAConnection(user, password)
/pd,
            : getXADataSource().getXAConnection();
/s,
org.h2.jdbcx.JdbcDataSource.getXAConnection(java.lang.String, java.lang.String) line: 336	
        int id = getNextId(XA_DATA_SOURCE);
0
        return new JdbcXAConnection(factory, id, getJdbcConnection(user, convertToCharArray(password)));
/s,
org.h2.jdbcx.JdbcDataSource.getJdbcConnection(java.lang.String, char[]) line: 181	
        info.setProperty("user", user);
        info.put("password", password);
        Connection conn = Driver.load().connect(url, info);
/s,
    public static synchronized Driver load() {
        try {
            if (!registered) {
                registered = true;
                DriverManager.registerDriver(INSTANCE);
            }
        } catch (SQLException e) {
            TraceSystem.traceThrowable(e);
        }
        return INSTANCE;
    }
/t,
/s,
org.h2.Driver.connect(java.lang.String, java.util.Properties) line: 60	
/=
    public Connection connect(String url, Properties info) throws SQLException {
url	"jdbc:h2:tcp://localhost/~/h2/test" (id=21347)	
props java.util.Properties  (id=21342) {user=sa, password=[C@240f83db}

            return new JdbcConnection(url, info);
/s,
org.h2.jdbc.JdbcConnection.<init>(java.lang.String, java.util.Properties) line: 90	
        this(new ConnectionInfo(url, info), true);
/s,
org.h2.jdbc.JdbcConnection.<init>(org.h2.engine.ConnectionInfo, boolean) line: 96	
            // this will return an embedded or server connection
            session = new SessionRemote(ci).connectEmbeddedOrServer(false);
/s,
org.h2.engine.SessionRemote.connectEmbeddedOrServer(boolean) line: 295	

        ConnectionInfo ci = connectionInfo;
        if (ci.isRemote()) {
/j,
            connectServer(ci);
/s,
org.h2.engine.SessionRemote.connectServer(org.h2.engine.ConnectionInfo) line: 344	
        String name = ci.getName();
        if (name.startsWith("//")) {
/j,
            name = name.substring("//".length()); / localhost/~/h2/test
        }
        int idx = name.indexOf('/');
        if (idx < 0) {
            throw ci.getFormatException();
        }
        databaseName = name.substring(idx + 1); / ~/h2/test
        String server = name.substring(0, idx);	/ localhost

        String[] servers = StringUtils.arraySplit(server, ',', true);	/ [localhost]
        int len = servers.length;
        transferList.clear();
        sessionId = StringUtils.convertBytesToHex(MathUtils.secureRandomBytes(32)); 
/ ed9cad0bef3f035f9b729ff294d17a886a39b11fc143202519b1c2e87ca78d29
        try {
            for (int i = 0; i < len; i++) {
                String s = servers[i];
                try {
                    Transfer trans = initTransfer(ci, databaseName, s);
/s,
org.h2.engine.SessionRemote.initTransfer(org.h2.engine.ConnectionInfo, java.lang.String, java.lang.String) line: 95	
        Socket socket = NetUtils.createSocket(server, Constants.DEFAULT_TCP_PORT, ci.isSSL());
/s,
org.h2.util.NetUtils.createSocket(java.lang.String, int, boolean) line: 88	
        int port = defaultPort;								/ 9092
        // IPv6: RFC 2732 format is '[a:b:c:d:e:f:g:h]' or
        // '[a:b:c:d:e:f:g:h]:port'
        // RFC 2396 format is 'a.b.c.d' or 'a.b.c.d:port' or 'hostname' or
        // 'hostname:port'
        int startIndex = server.startsWith("[") ? server.indexOf(']') : 0;	/ server=localhost
        int idx = server.indexOf(':', startIndex);
        if (idx >= 0) {
/n,
            port = Integer.decode(server.substring(idx + 1));
            server = server.substring(0, idx);
        }
        InetAddress address = InetAddress.getByName(server);
/ getByName() returned	java.net.Inet4Address  (id=21400)	localhost/127.0.0.1
        return createSocket(address, port, ssl);
/s,
org.h2.util.NetUtils.createSocket(java.net.InetAddress, int, boolean) line: 112	
        for (int i = 0;; i++) {
            try {
                if (ssl) {
/n,
                    return CipherFactory.createSocket(address, port);
                }
                Socket socket = new Socket();
                socket.connect(new InetSocketAddress(address, port), / address=java.net.InetAddress localhost/127.0.0.1	, port=9092
                        SysProperties.SOCKET_CONNECT_TIMEOUT);
                return socket;
/t,
org.h2.engine.SessionRemote.initTransfer(org.h2.engine.ConnectionInfo, java.lang.String, java.lang.String) line: 96	
        Socket socket = NetUtils.createSocket(server, Constants.DEFAULT_TCP_PORT, ci.isSSL());
        Transfer trans = new Transfer(this);
/s,
/**
 * The transfer class is used to send and receive Value objects.
 * It is used on both the client side, and on the server side.
 */
public class Transfer {
    private Socket socket;
    private DataInputStream in;
    private DataOutputStream out;
    private SessionInterface session;

        trans.setSocket(socket);	/ Socket[addr=localhost/127.0.0.1,port=9092,localport=51083]
        trans.setSSL(ci.isSSL());	/ false
        trans.init();
/s,
org.h2.value.Transfer.init() line: 82 [local variables unavailable]	
        if (socket != null) {
            in = new DataInputStream(new BufferedInputStream(socket.getInputStream(), Transfer.BUFFER_SIZE));
            out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), Transfer.BUFFER_SIZE));
/t,
        trans.writeInt(Constants.TCP_PROTOCOL_VERSION_6);	/=         out.writeInt(x);	, x==6
        trans.writeInt(Constants.TCP_PROTOCOL_VERSION_12);	/=         out.writeInt(x);	, x==12
        trans.writeString(db);
/s,
org.h2.value.Transfer.writeString(java.lang.String) line: 227	
        } else {					/ s=~/h2/test
            int len = s.length();
            out.writeInt(len);
            for (int i = 0; i < len; i++) {
                out.writeChar(s.charAt(i));
            }
        }
        return this;
/t,
        trans.writeString(ci.getOriginalURL()); / jdbc:h2:tcp://localhost/~/h2/test
        trans.writeString(ci.getUserName());	/ SA
        trans.writeBytes(ci.getUserPasswordHash());	/ 'n byte[]
        trans.writeBytes(ci.getFilePasswordHash());
        String[] keys = ci.getKeys();
        trans.writeInt(keys.length);	/ []
        for (String key : keys) {
            trans.writeString(key).writeString(ci.getProperty(key));
        }
        try {
            done(trans);
/s,
org.h2.engine.SessionRemote.done(org.h2.value.Transfer) line: 571	
        transfer.flush();	/= out.flush()
        int status = transfer.readInt();
        } else if (status == STATUS_OK) {
            // ok
/t,
            clientVersion = trans.readInt();	/= in.readInt()
            trans.setVersion(clientVersion);	/ this.version=version
            trans.writeInt(SessionRemote.SESSION_SET_ID);	/     public static final int SESSION_SET_ID = 12;
            trans.writeString(sessionId);	/ ed9cad0bef3f035f9b729ff294d17a886a39b11fc143202519b1c2e87ca78d29
            done(trans);	/=         transfer.flush(); int status = transfer.readInt();
        } catch (DbException e) {
            trans.close();
            throw e;
        }
        autoCommit = true;
        return trans;
/t,
org.h2.engine.SessionRemote.connectServer(org.h2.engine.ConnectionInfo) line: 404	
        try {
            for (int i = 0; i < len; i++) {
                String s = servers[i];
                try {
                    Transfer trans = initTransfer(ci, databaseName, s);
/d,
                    transferList.add(trans);				/ als transferList.size()>1	, dan cluster,
            checkClusterDisableAutoCommit(serverList);
/s,
org.h2.engine.SessionRemote.checkClusterDisableAutoCommit(java.lang.String) line: 187	
        if (autoCommit && transferList.size() > 1) {
/n,
            setAutoCommitSend(false);
            CommandInterface c = prepareCommand("SET CLUSTER " + serverList, Integer.MAX_VALUE);
            // this will set autoCommit to false
            c.executeUpdate();
            // so we need to switch it on
            autoCommit = true;
            cluster = true;
        }
    }		
/t,
org.h2.engine.SessionRemote.connectEmbeddedOrServer(boolean) line: 296	
        ConnectionInfo ci = connectionInfo;
        if (ci.isRemote()) {
            connectServer(ci);
/d,
            return this;
        }
/t,
org.h2.jdbc.JdbcConnection.<init>(org.h2.engine.ConnectionInfo, boolean) line: 106	
            // this will return an embedded or server connection
            session = new SessionRemote(ci).connectEmbeddedOrServer(false);
/d,
            this.user = ci.getUserName();	/ SA
            this.url = ci.getURL();	/ jdbc:h2:tcp://localhost/~/h2/test
...
/t,
org.h2.jdbcx.JdbcDataSource.getJdbcConnection(java.lang.String, char[]) line: 188	
        Connection conn = Driver.load().connect(url, info);
/d,
        return (JdbcConnection) conn;
/t,
org.h2.jdbcx.JdbcDataSource.getXAConnection(java.lang.String, java.lang.String) line: 340	
        return new JdbcXAConnection(factory, id, getJdbcConnection(user, convertToCharArray(password)));
/pd,
/s,
org.h2.jdbcx.JdbcXAConnection.<init>(org.h2.jdbcx.JdbcDataSourceFactory, int, org.h2.jdbc.JdbcConnection) line: 52	
/**
 * This class provides support for distributed transactions.
 * An application developer usually does not use this interface.
 * It is used by the transaction manager internally.
 */
public class JdbcXAConnection extends TraceObject implements XAConnection, XAResource {

    JdbcXAConnection(JdbcDataSourceFactory factory, int id, JdbcConnection physicalConn) {
        this.factory = factory;
        setTrace(factory.getTrace(), TraceObject.XA_DATA_SOURCE, id);
        this.physicalConn = physicalConn;
    }
this	org.h2.jdbcx.JdbcXAConnection  (id=21446)	
	factory	org.h2.jdbcx.JdbcDataSourceFactory  (id=21448)	
	physicalConn	org.h2.jdbc.JdbcConnection  (id=21367)	/ conn8: url=jdbc:h2:tcp://localhost/~/h2/test user=SA
/t,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).getXAManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
         xaConnection = (user != null)
            ? getXADataSource().getXAConnection(user, password)	/ <-
            : getXADataSource().getXAConnection();
/d,
         return newXAManagedConnection(props, xaConnection);
/s,
org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory).newXAManagedConnection(java.util.Properties, javax.sql.XAConnection) line: 523

      return new XAManagedConnection(this, xaConnection, props, transactionIsolation, preparedStatementCacheSize);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.<init>(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory, javax.sql.XAConnection, java.util.Properties, int, int) line: 68	
      super(mcf, xaConnection.getConnection(), props, transactionIsolation, psCacheSize);
/s,
org.h2.jdbcx.JdbcXAConnection.getConnection() line: 107 [local variables unavailable]	
        Connection lastHandle = handleConn;
null
        if (lastHandle != null) {
/n,
            lastHandle.close();
        }
        // this will ensure the rollback command is cached
        physicalConn.rollback();
/s,
org.h2.jdbc.JdbcConnection.rollback() line: 468 [local variables unavailable]	
/=
    /**
     * Rolls back the current transaction. This call has only an effect if auto
     * commit is switched off.
     *
     * @throws SQLException if the connection is closed
     */
    @Override
    public synchronized void rollback() throws SQLException {
        try {
            debugCodeCall("rollback");
            checkClosedForWrite();
            try {
                rollbackInternal();
            } finally {
                afterWriting();
            }
/s,
org.h2.jdbc.JdbcConnection.rollbackInternal() line: 1444 [local variables unavailable]	
        rollback = prepareCommand("ROLLBACK", rollback);
/s,
org.h2.jdbc.JdbcConnection.prepareCommand(java.lang.String, org.h2.command.CommandInterface) line: 1142	
        return old == null ? session.prepareCommand(sql, Integer.MAX_VALUE) : old;
/s,
org.h2.engine.SessionRemote.prepareCommand(java.lang.String, int) line: 448	
        return new CommandRemote(this, transferList, sql, fetchSize);
/s,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 40	
/=
/**
 * Represents the client-side part of a SQL statement.
 * This class is not used in embedded mode.
 */
public class CommandRemote implements CommandInterface {
    public CommandRemote(SessionRemote session, ArrayList<Transfer> transferList, String sql, int fetchSize) {
        this.transferList = transferList;
this	org.h2.command.CommandRemote  (id=21474)	
	transferList	java.util.ArrayList<E>  (id=21382)	
		elementData	java.lang.Object[4]  (id=21478)	
			[0]	org.h2.value.Transfer  (id=21417)	
				in	java.io.DataInputStream  (id=21428)	
				out	java.io.DataOutputStream  (id=21431)	
				session	org.h2.engine.SessionRemote  (id=21381)	
					sessionId	"ed9cad0bef3f035f9b729ff294d17a886a39b11fc143202519b1c2e87ca78d29" (id=21395)	
				socket	java.net.Socket  (id=21415)	/ Socket[addr=localhost/127.0.0.1,port=9092,localport=51083]
				ssl	false	
				version	12	
		size	1	

        trace = session.getTrace();
        this.sql = sql;	/ ROLLBACK
        parameters = New.arrayList();
        prepare(session, true);
/s,
org.h2.command.CommandRemote.prepare(org.h2.engine.SessionRemote, boolean) line: 54
        id = s.getNextId();
0
        for (int i = 0, count = 0; i < transferList.size(); i++) {
            try {
                Transfer transfer = transferList.get(i);
                if (createParams) {
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql); / id=0, sql=ROLLBACK
                s.done(transfer);	/= transfer.flush() /= transfer.out.flush()
/t,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 48	
        prepare(session, true);
/d,

        // set session late because prepare might fail - in this case we don't
        // need to close the object
        this.session = session;
        this.fetchSize = fetchSize; / 2147483647
        created = session.getLastReconnect(); / 0	, heeft te maken met of je opnieuw moet prepare,
    }
/t,
org.h2.jdbc.JdbcConnection.rollbackInternal() line: 1445 [local variables unavailable]	
        rollback = prepareCommand("ROLLBACK", rollback);
/d,
        rollback.executeUpdate();
/s,
org.h2.command.CommandRemote.executeUpdate() line: 180	
        synchronized (session) {
            int updateCount = 0;
            boolean autoCommit = false;
            for (int i = 0, count = 0; i < transferList.size(); i++) {
                prepareIfRequired();
/s,
org.h2.command.CommandRemote.prepareIfRequired() line: 99 [local variables unavailable]	
        if (session.getLastReconnect() != created) {
/n,
            // in this case we need to prepare again in every case
            id = Integer.MIN_VALUE;
        }
        session.checkClosed();
        if (id <= session.getCurrentId() - SysProperties.SERVER_CACHED_OBJECTS) { / id==0, session.getCurrentId()=session.nextId==1 TODO
/n,
            // object is too old - we need to prepare again
            prepare(session, false);
        }
/t,
org.h2.command.CommandRemote.executeUpdate() line: 181 [local variables unavailable]	
            for (int i = 0, count = 0; i < transferList.size(); i++) {
                prepareIfRequired();
/d,
                Transfer transfer = transferList.get(i);
                try {
                    transfer.writeInt(SessionRemote.COMMAND_EXECUTE_UPDATE).writeInt(id);
                    sendParameters(transfer);
/s,
org.h2.command.CommandRemote.sendParameters(org.h2.value.Transfer) line: 212	
        int len = parameters.size();/ 0
        transfer.writeInt(len);	/ dat stuur je wel op,
        for (ParameterInterface p : parameters) {
/n,
            transfer.writeValue(p.getParamValue());
        }
/t,
                    session.done(transfer);	/= transfer.flush()
                    updateCount = transfer.readInt();	/ 0
                    autoCommit = transfer.readBoolean();	/ true	, TODO autocommit==true na rollback?
            session.setAutoCommitFromServer(autoCommit);	/= this.autoCommit = autoCommit;
            session.autoCommitIfCluster();	/n,
            session.readSessionState();	/ NIETS
            return updateCount;	  
/t,
org.h2.jdbc.JdbcConnection.rollback() line: 472 [local variables unavailable]	
            try {
                rollbackInternal();
/d,
            } finally {
                afterWriting(); / NIETS,
            }
/t,
org.h2.jdbcx.JdbcXAConnection.getConnection() line: 108 [local variables unavailable]	
        // this will ensure the rollback command is cached
        physicalConn.rollback();
/d,
        handleConn = new PooledJdbcConnection(physicalConn);
physicalConn	org.h2.jdbc.JdbcConnection  (id=21367)	
	session	org.h2.engine.SessionRemote  (id=21381)	
		transferList	java.util.ArrayList<E>  (id=21382)	
			elementData	java.lang.Object[4]  (id=21478)	
				[0]	org.h2.value.Transfer  (id=21417)
					in	java.io.DataInputStream  (id=21428)	
					out	java.io.DataOutputStream  (id=21431)	
					socket	java.net.Socket  (id=21415)	
					ssl	false
handleConn	org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection  (id=21588)	
	session	org.h2.engine.SessionRemote  (id=21381)	
		transferList	java.util.ArrayList<E>  (id=21382)	
			elementData	java.lang.Object[4]  (id=21478)	
				[0]	org.h2.value.Transfer  (id=21417)	
					in	java.io.DataInputStream  (id=21428)	
					out	java.io.DataOutputStream  (id=21431)	
					socket	java.net.Socket  (id=21415)	
					ssl	false				
/ TODO pooled	,
        return handleConn;
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.<init>(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory, javax.sql.XAConnection, java.util.Properties, int, int) line: 68	
      super(mcf, xaConnection.getConnection(), props, transactionIsolation, psCacheSize);
/pd,
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).<init>(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnectionFactory, java.sql.Connection, java.util.Properties, int, int) line: 184	
      this.mcf = mcf;	/ heeft xads	org.h2.jdbcx.JdbcDataSource  (id=21257)	
      this.con = con; / conn9: url=jdbc:h2:tcp://localhost/~/h2/test user=SA
      this.props = props;
      this.tryLock = mcf.getUseTryLock().intValue();

      if (psCacheSize > 0)
/n,
      {
         psCache = new PreparedStatementCache(psCacheSize, mcf.getStatistics());
         mcf.getStatistics().registerPreparedStatementCache(psCache);
      }

      if (transactionIsolation == -1)
         this.transactionIsolation = con.getTransactionIsolation();
/s,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).getTransactionIsolation() line: 756 [local variables unavailable]	
            getLockMode = prepareCommand("CALL LOCK_MODE()", getLockMode); 
this.getLockMode=org.h2.command.CommandRemote  (id=21734) CALL LOCK_MODE	/ dus hij is er al,
            ResultInterface result = getLockMode.executeQuery(0, false);
            result.next();
            int lockMode = result.currentRow()[0].getInt();
/s,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).prepareCommand(java.lang.String, org.h2.command.CommandInterface) line: 1142
/=
    private CommandInterface prepareCommand(String sql, CommandInterface old) {	
        return old == null ? session.prepareCommand(sql, Integer.MAX_VALUE) : old;
/t,
/s,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 138	
                    transfer.writeInt(SessionRemote.COMMAND_EXECUTE_QUERY).writeInt(id).writeInt(objectId).writeInt( / id==3
                            maxRows);
/ Intermezzo

/ eerder is al,
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql); / id=3, sql=CALL LOCK_MODE()

/ WH is id de id van de ...	, de sql is met die id al eerder naar de server gestuurd	,
/ Dus nu hoeven we alleen te zeggen: execute id, en geef hierbij een arg objectId mee, dat zal de lock mode zijn,

/ Einde Intermezzo
                    } else {
                        fetch = fetchSize;	/ 2147483647
                    }
                    transfer.writeInt(fetch);
                    sendParameters(transfer);
                    session.done(transfer);
                    int columnCount = transfer.readInt(); / 1
                    if (result != null) {
/n,
                        result.close();
                        result = null;
                    }
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch);
/s,
org.h2.result.ResultRemote.<init>(org.h2.engine.SessionRemote, org.h2.value.Transfer, int, int, int) line: 38	
        for (int i = 0; i < columnCount; i++) {
            columns[i] = new ResultColumn(transfer);
        }
        result = New.arrayList();
        this.fetchSize = fetchSize;
        fetchRows(false);
/s,
org.h2.result.ResultRemote.fetchRows(boolean) line: 204	
        synchronized (session) {
            session.checkClosed();
            try {
                rowOffset += result.size(); / 0
                result.clear();
                int fetch = Math.min(fetchSize, rowCount - rowOffset); / 1	
/ TODO
                if (sendFetch) {
/n,
/ TODO
                    session.traceOperation("RESULT_FETCH_ROWS", id);
                    transfer.writeInt(SessionRemote.RESULT_FETCH_ROWS).writeInt(id).writeInt(fetch);
                    session.done(transfer);
                }
                for (int r = 0; r < fetch; r++) {
                    boolean row = transfer.readBoolean();
                    if (!row) {
                        break;
                    }
                    int len = columns.length;
                    Value[] values = new Value[len];
                    for (int i = 0; i < len; i++) {
                        Value v = transfer.readValue();	/ 3
                        values[i] = v;
					}
this	org.h2.result.ResultRemote  (id=21752)	
	columns	org.h2.result.ResultColumn[1]  (id=21755)	
		[0]	org.h2.result.ResultColumn  (id=21753)	
			alias	"LOCK_MODE()" (id=21757)	
			autoIncrement	false	
			columnName	"LOCK_MODE()" (id=21757)	
			columnType	4	
			displaySize	11	
			nullable	2	
			precision	10	
			scale	0	
			schemaName	null	
			tableName	null	
	fetchSize	2147483647	
	id	3	
	result	java.util.ArrayList<E>  (id=21754)	
		elementData	java.lang.Object[4]  (id=21756)	
			[0]	org.h2.value.Value[1]  (id=21766)	
				[0]	org.h2.value.ValueInt  (id=21737)	
					value	3	
		size	1	

                if (rowOffset + result.size() >= rowCount) {
/j,
                    sendClose();
/s,
org.h2.result.ResultRemote.sendClose() line: 167 [local variables unavailable]

this	org.h2.result.ResultRemote  (id=21752)	
	columns	org.h2.result.ResultColumn[1]  (id=21755)	
	id	3	
	result	java.util.ArrayList<E>  (id=21754)	
	session	org.h2.engine.SessionRemote  (id=21381)	
	transfer	org.h2.value.Transfer  (id=21417)	

/ dus de ResultRemote heeft ook session, transfer!
/ TODO
	
        try {
            synchronized (session) {
                session.traceOperation("RESULT_CLOSE", id);
                transfer.writeInt(SessionRemote.RESULT_CLOSE).writeInt(id);
/ TODO id
            }
        } catch (IOException e) {
            trace.error(e, "close");
        } finally {
            transfer = null;
            session = null;
        }
/t,
org.h2.result.ResultRemote.<init>(org.h2.engine.SessionRemote, org.h2.value.Transfer, int, int, int) line: 52	
        fetchRows(false);
/d,
/t,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 160	
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch);
/d,
            session.autoCommitIfCluster();
            session.readSessionState();
            return result;
/t,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).getTransactionIsolation() line: 758 [local variables unavailable]	
            getLockMode = prepareCommand("CALL LOCK_MODE()", getLockMode);
            ResultInterface result = getLockMode.executeQuery(0, false);
/d,
            result.next();
/s,
org.h2.result.ResultRemote.next() line: 129 [local variables unavailable]	
        if (rowId < rowCount) {
/j,
            rowId++;
            remapIfOld();	/ NIETS, want session==null in deze ResultRemote, in de SessionRemote NIET	,
            if (rowId < rowCount) {
/j,
                if (rowId - rowOffset >= result.size()) {
/n,
                    fetchRows(true);
                }
                currentRow = result.get(rowId - rowOffset);
                return true;
/t,
            int lockMode = result.currentRow()[0].getInt();
3
            result.close(); / WH result.result=null
            switch(lockMode) {
            case Constants.LOCK_MODE_READ_COMMITTED:
                transactionIsolationLevel = Connection.TRANSACTION_READ_COMMITTED;
                break;
            return transactionIsolationLevel;
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).<init>(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnectionFactory, java.sql.Connection, java.util.Properties, int, int) line: 205	
      if (transactionIsolation == -1)
         this.transactionIsolation = con.getTransactionIsolation();
/d,
      readOnly = con.isReadOnly();
/s,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).isReadOnly() line: 540	
        try {
            debugCodeCall("isReadOnly");
            checkClosed();
            getReadOnly = prepareCommand("CALL READONLY()", getReadOnly); / getReadOnly==null, dus is er nog niet,
/s,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).prepareCommand(java.lang.String, org.h2.command.CommandInterface) line: 1142	
        return old == null ? session.prepareCommand(sql, Integer.MAX_VALUE) : old;	/ sql=CALL READONLY()
/s,
org.h2.engine.SessionRemote.prepareCommand(java.lang.String, int) line: 448	
        return new CommandRemote(this, transferList, sql, fetchSize);
/s,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 41	
        this.transferList = transferList;
        trace = session.getTrace();
        this.sql = sql;
        parameters = New.arrayList();
        prepare(session, true); / this.sql kent hij,
/s,
org.h2.command.CommandRemote.prepare(org.h2.engine.SessionRemote, boolean) line: 55	
        id = s.getNextId();
4
        for (int i = 0, count = 0; i < transferList.size(); i++) {
            try {
                Transfer transfer = transferList.get(i);
                if (createParams) {
                    s.traceOperation("SESSION_PREPARE_READ_PARAMS", id);
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql); / sql=CALL READONLY()
                s.done(transfer);	/ transfer.flush()
                isQuery = transfer.readBoolean();	/ true
                readonly = transfer.readBoolean();	/ false
                int paramCount = transfer.readInt();/ 0
/t,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 48	
        prepare(session, true);
/d,			
        // set session late because prepare might fail - in this case we don't
        // need to close the object
        this.session = session;
        this.fetchSize = fetchSize;	/ 2147483647
        created = session.getLastReconnect(); / 0
/t,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).isReadOnly() line: 543 [local variables unavailable]	
            getReadOnly = prepareCommand("CALL READONLY()", getReadOnly);
/d,
this	org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection  (id=21588)	
	getReadOnly	org.h2.command.CommandRemote  (id=21930) CALL READONLY()
			
            ResultInterface result = getReadOnly.executeQuery(0, false);
/s,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 134	
this	org.h2.command.CommandRemote  (id=21930)	
	id	4												/ dit is de id van de cmd	, CALL_READONLY()
	session	org.h2.engine.SessionRemote  (id=21381)	
		nextId	6										/ TODO

                    
                    transfer.writeInt(SessionRemote.COMMAND_EXECUTE_QUERY).writeInt(id).writeInt(objectId).writeInt(
                            maxRows);

                    } else {
                        fetch = fetchSize;	/ 2147483647
                    }
                    transfer.writeInt(fetch);
                    sendParameters(transfer);
                    session.done(transfer);
                    int columnCount = transfer.readInt();
                    if (result != null) {
                        result.close();
                        result = null;
                    }
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch); / objectId=5, columnCount=1
/s,
org.h2.result.ResultRemote.<init>(org.h2.engine.SessionRemote, org.h2.value.Transfer, int, int, int) line: 43	

        this.id = id;
        this.columns = new ResultColumn[columnCount];
        rowCount = transfer.readInt();
        for (int i = 0; i < columnCount; i++) {
            columns[i] = new ResultColumn(transfer);
        }					
        rowId = -1;
        result = New.arrayList();
        this.fetchSize = fetchSize;
        fetchRows(false);
/s,
org.h2.result.ResultRemote.fetchRows(boolean) line: 204	
       synchronized (session) {
            session.checkClosed();
            try {
                rowOffset += result.size();	/ WH 0
                result.clear();
                int fetch = Math.min(fetchSize, rowCount - rowOffset);	/ WH 1
                if (sendFetch) {
/n,
                    session.traceOperation("RESULT_FETCH_ROWS", id);
                    transfer.writeInt(SessionRemote.RESULT_FETCH_ROWS).writeInt(id).writeInt(fetch);
                    session.done(transfer);
                }
                for (int r = 0; r < fetch; r++) {
                    boolean row = transfer.readBoolean();	/ TODO
                    if (!row) {
/n,
                        break;
                    }
                    int len = columns.length;
                    Value[] values = new Value[len];
                    for (int i = 0; i < len; i++) {
                        Value v = transfer.readValue();
/s,
org.h2.value.Transfer.readValue() line: 535 [local variables unavailable]	
        int type = readInt();
        switch(type) {
        case Value.BOOLEAN:
            return ValueBoolean.get(readBoolean());	
/s,
				return in.readByte() == 1;
/t,
/s,
				return (ValueBoolean) (b ? TRUE : FALSE);
/t,
org.h2.result.ResultRemote.fetchRows(boolean) line: 229	
                    for (int i = 0; i < len; i++) {
                        Value v = transfer.readValue();
/d,
                        values[i] = v;
                    }
                    result.add(values);
                }
                if (rowOffset + result.size() >= rowCount) {
/j,
                    sendClose();
/s,
org.h2.result.ResultRemote.sendClose() line: 167 [local variables unavailable]	
                transfer.writeInt(SessionRemote.RESULT_CLOSE).writeInt(id);		/ id=5
        } finally {
            transfer = null;
            session = null;
/t,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 160	
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch);
/d,
            return result;
/t,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).isReadOnly() line: 544 [local variables unavailable]	
            getReadOnly = prepareCommand("CALL READONLY()", getReadOnly);
            ResultInterface result = getReadOnly.executeQuery(0, false);
/d,
            result.next();
            boolean readOnly = result.currentRow()[0].getBoolean().booleanValue();
            return readOnly;
/s,
org.h2.result.ResultRemote.next() line: 129 [local variables unavailable]	
        if (rowId < rowCount) {	/ -1<1
            rowId++;
            remapIfOld();
            if (rowId < rowCount) { / 0<1
                if (rowId - rowOffset >= result.size()) {
/n,
                    fetchRows(true);
                }
                currentRow = result.get(rowId - rowOffset);
                return true;

this	org.h2.result.ResultRemote  (id=21948)	
	currentRow	org.h2.value.Value[1]  (id=21966)	
		[0]	org.h2.value.ValueBoolean  (id=21961)	
			value	java.lang.Boolean  (id=21017)	
				value	false	
/t,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).isReadOnly() line: 545 [local variables unavailable]	
            getReadOnly = prepareCommand("CALL READONLY()", getReadOnly);
            ResultInterface result = getReadOnly.executeQuery(0, false);
            result.next();
/d,
            boolean readOnly = result.currentRow()[0].getBoolean().booleanValue();
			return readOnly;
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).<init>(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnectionFactory, java.sql.Connection, java.util.Properties, int, int) line: 207	
      readOnly = con.isReadOnly();
false
      if (mcf.getNewConnectionSQL() != null)	/ mcf.newConnectionSQL==null
/n,
      underlyingReadOnly = readOnly; / false
      jdbcReadOnly = readOnly;
      jdbcTransactionIsolation = this.transactionIsolation;	/ 2

      metadata = new ManagedConnectionMetaDataImpl(con, props.getProperty("user"));
/s,
org.jboss.jca.adapters.jdbc.ManagedConnectionMetaDataImpl.<init>(java.sql.Connection, java.lang.String) line: 70	
         if (connection != null && connection.getMetaData() != null)
         {
            productName = connection.getMetaData().getDatabaseProductName();		/ H2
            productVersion = connection.getMetaData().getDatabaseProductVersion();	/ 1.3.173 (2013-07-28)
      this.maxConnections = 1;
      this.user = user; / sa
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.<init>(org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory, javax.sql.XAConnection, java.util.Properties, int, int) line: 70	
      super(mcf, xaConnection.getConnection(), props, transactionIsolation, psCacheSize);
/d,
      this.xaConnection = xaConnection;
	  
this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	
	transactionIsolation	2	
	xaConnection	org.h2.jdbcx.JdbcXAConnection  (id=21446)
	
      this.xaResource = xaConnection.getXAResource(); /= return this
...
/t,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1322	
      ManagedConnection mc = mcf.createManagedConnection(subject, cri);
/d,
mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	
	transactionIsolation	2	
	xaConnection	org.h2.jdbcx.JdbcXAConnection  (id=21446)	
	xaResource	org.h2.jdbcx.JdbcXAConnection  (id=21446)		/ de xaConnection heeft zelf de XAResource fcts	,

      try 
      {
         ConnectionListener cl = cm.createConnectionListener(mc, this);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.createConnectionListener(javax.resource.spi.ManagedConnection, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 604	
      else
      {         
         if (wrapXAResource)
         {
            String eisProductName = null;
            String eisProductVersion = null;

            try
            {
               if (mc.getMetaData() != null)
               {
                  eisProductName = mc.getMetaData().getEISProductName();	/ H2
                  eisProductVersion = mc.getMetaData().getEISProductVersion(); / 1.3.173 (2013-07-28)
               }
            }
            if (xaResource == null)
/j,
            {
               XAResource xar = mc.getXAResource();
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5

              if (!(xar instanceof org.jboss.jca.core.spi.transaction.xa.XAResourceWrapper))
               {
                  xaResource = txIntegration.createXAResourceWrapper(xar, padXid,
                                                                     isSameRMOverride,
                                                                     eisProductName, eisProductVersion,
                                                                     getJndiName(), txIntegration.isFirstResource(mc),  
                                                                     getXAResourceStatistics());
jndiName()==java:jboss/datasources/RemoteExampleDS
txIntegration.isFirstResource(mc)==false																	 
               }
	
/s,
org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl.createXAResourceWrapper(javax.transaction.xa.XAResource, boolean, java.lang.Boolean, java.lang.String, java.lang.String, java.lang.String, boolean, org.jboss.jca.core.spi.transaction.XAResourceStatistics) line: 357	

         else
         {
            return new XAResourceWrapperImpl(xares, pad, override, productName, productVersion, jndiName);
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.createConnectionListener(javax.resource.spi.ManagedConnection, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 757	
                  xaResource = txIntegration.createXAResourceWrapper(xar, padXid,
                                                                     isSameRMOverride,
                                                                     eisProductName, eisProductVersion,
                                                                     getJndiName(), txIntegration.isFirstResource(mc),
                                                                     getXAResourceStatistics());
/d,
      ConnectionListener cli = new TxConnectionListener(this, mc, getPool(), mcp,
                                                        getFlushStrategy(), getTracking(), getEnlistmentTrace(),
                                                        xaResource, explicitXAResourceTimeout);
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.<init>(org.jboss.jca.core.connectionmanager.ConnectionManager, javax.resource.spi.ManagedConnection, org.jboss.jca.core.connectionmanager.pool.api.Pool, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, org.jboss.jca.common.api.metadata.common.FlushStrategy, java.lang.Boolean, java.lang.Boolean, javax.transaction.xa.XAResource, int) line: 137	

      super(cm, mc, pool, mcp, flushStrategy, tracking);

this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=18205)				/ 'n mgr	,	
mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)					/ 'n conn
pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=18220)	
mcp	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=21283)	
flushStrategy	org.jboss.jca.common.api.metadata.common.FlushStrategy  (id=21008)	
tracking	java.lang.Boolean  (id=21017)												/ false
enlistmentTrace	java.lang.Boolean  (id=21006)											/ true
xaResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22007)	
xaResourceTimeout	0	

	...
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.createConnectionListener(javax.resource.spi.ManagedConnection, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 760	
      ConnectionListener cli = new TxConnectionListener(this, mc, getPool(), mcp,
                                                        getFlushStrategy(), getTracking(), getEnlistmentTrace(),
                                                        xaResource, explicitXAResourceTimeout);
/d,
      mc.addConnectionEventListener(cli);	/ cels.add(cel);
/t,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.createConnectionEventListener(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 1330	

         ConnectionListener cl = cm.createConnectionListener(mc, this);
/d,
         poolSize.incrementAndGet(); 	/ is nu 1	, TODO hoe conn in pool	?
         return cl;
/t,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 496	
            try 
            {
               // No, the pool was empty, so we have to make a new one.
               clw = new ConnectionListenerWrapper(createConnectionEventListener(subject, cri), true, true);
/pd,
/d,
               clw.setCheckedOut(true);
               checkedOutSize.incrementAndGet();

               cls.put(clw.getConnectionListener(), clw);
{org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@29043380[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 connection handles=0 lastReturned=1526498637637 lastValidated=1526498637637 lastCheckedOut=1526498637637 trackByTx=false pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@12a3b7d5 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@777095ee[pool=RemoteExampleDS] xaResource=XAResourceWrapperImpl@5bcc6a79[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS] txSync=null]=org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool$ConnectionListenerWrapper@1b0cd260}
/=
this	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=21283)	
	cls	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22069)	
		table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=22082)	
			[4]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=22085)	
				key	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
				val	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool$ConnectionListenerWrapper  (id=22067)	
					checkedOut	true	
					cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
					hasPermit	true
/ in de value zit de key zelf, de cl,					

               return clw.getConnectionListener();
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 709	
      // Need a new one for this transaction
      // This must be done outside the tx local lock, otherwise
      // the tx timeout won't work and get connection can do a lot of other work
      // with many opportunities for deadlocks.
      // Instead we do a double check after we got the transaction to see
      // whether another thread beat us to the punch.
      ConnectionListener cl = mcp.getConnection(subject, cri);
/d,
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/s,
         return getTransactionIntegration().getTransactionSynchronizationRegistry();
/t,
      try
      {
         // Check we weren't racing with another transaction
         ConnectionListener other =
            (ConnectionListener)tsr.getResource(mcp);
         if (other != null)
/n,
         {
            returnConnection(cl, false);

            log.tracef("Another thread already got a connection tracked by transaction=%s tx=%s",
                       other, trackByTransaction);

            cl = other;
         }
/ TODO TX
         // This is the connection for this transaction
         cl.setTrackByTx(true);
		 

         tsr.putResource(mcp, cl);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.putResource(java.lang.Object, java.lang.Object) line: 110	
        TransactionImple transactionImple = getTransactionImple();
        transactionImple.putTxLocalResource(key, value);
/s,
		_txLocalResources.put(key, value);
		
this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=19126)	
		m	java.util.HashMap<K,V>  (id=19128)	
			table	java.util.HashMap$Node<K,V>[16]  (id=20948)	
				[10]	java.util.HashMap$Node<K,V>  (id=20952)	
					key	org.jboss.jca.core.connectionmanager.transaction.LockKey  (id=21024)	
					value	java.util.concurrent.locks.ReentrantLock  (id=21026)	
				[12]	java.util.HashMap$Node<K,V>  (id=20954)	
					key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=20998)
SemaphoreConcurrentLinkedQueueManagedConnectionPool@3ba1a91d[pool=PostgreSQLDS]					
					value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20999)
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@2694a63f[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 connection handles=0 lastReturned=1526050567923 lastValidated=1526050366421 lastCheckedOut=1526050760686 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@2e8d2faf mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@3ba1a91d[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@2bc0537d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=TransactionSynchronization@674601548{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:60 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]					
				[13]	java.util.HashMap$Node<K,V>  (id=20955)	
					key	"__TX_LISTENERS" (id=20329)	
					value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=20916)	
						head	java.util.concurrent.ConcurrentLinkedQueue$Node<E>  (id=22173)	
							item	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=20075)	
							next	java.util.concurrent.ConcurrentLinkedQueue$Node<E>  (id=22174)	
								item	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=20776)	
								next	null	
					next	java.util.HashMap$Node<K,V>  (id=21028)	
						key	"test.war#arquillian-forge4-persistence-unit" (id=21030)	
						value	org.hibernate.jpa.internal.EntityManagerImpl  (id=18509)	
				[14]	java.util.HashMap$Node<K,V>  (id=20956)	
					key	"test.war#arquillian-forge4-persistence-unit-1" (id=19068)	
					value	org.hibernate.jpa.internal.EntityManagerImpl  (id=19795)
					next	java.util.HashMap$Node<K,V>  (id=22188)	
						key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=21283)
SemaphoreConcurrentLinkedQueueManagedConnectionPool@777095ee[pool=RemoteExampleDS]						
						next	null	
						value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@29043380[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 connection handles=0 lastReturned=1526498637637 lastValidated=1526498637637 lastCheckedOut=1526498637637 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@12a3b7d5 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@777095ee[pool=RemoteExampleDS] xaResource=XAResourceWrapperImpl@5bcc6a79[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS] txSync=null]

/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionNewConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 761
	
         // This is the connection for this transaction
         cl.setTrackByTx(true);
         tsr.putResource(mcp, cl);
/d,
         log.tracef("Using connection from pool tracked by transaction=%s tx=%s", cl, trackByTransaction);
trackByTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	

         return cl;
      }
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 598
	
      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);
      }
/d,
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	

      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/d,
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).reconnectManagedConnection(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 928	
/=
  /**
    * Invoked to reassociate a managed connection.
    *
    * @param cl the managed connection
    * @throws ResourceException for exception
    */
   protected void reconnectManagedConnection(ConnectionListener cl) throws ResourceException
   {
      try
      {
         managedConnectionReconnected(cl);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 553	
         if (shouldEnlist(cl.getManagedConnection()))
            cl.enlist();
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 263	

      // This method is a bit convulted, but it has to be such because
      // there is a race condition in the transaction manager where it
      // unlocks during the enlist of the XAResource. It does this
      // to avoid distributed deadlocks and to ensure the transaction
      // timeout can fail a badly behaving resource during the enlist.
      //
      // When two threads in the same transaction are trying to enlist
      // connections they could be from the same resource manager
      // or even the same connection when tracking the connection by transaction.
      //
      // For the same connection, we only want to do the real enlist once.
      // For two connections from the same resource manager we don't
      // want the join before the initial start request.
      //
      // The solution is to build up a list of unenlisted resources
      // in the TransactionSynchronizer and then choose one of the
      // threads that is contending in the transaction to enlist them
      // in order. The actual order doesn't really matter as it is the
      // transaction manager that calculates the enlist flags and determines
      // whether the XAResource was already enlisted.
      //
      // Once there are no unenlisted resources the threads are released
      // to return the result of the enlistments.
      //
      // In practice, a thread just takes a snapshot to try to avoid one
      // thread having to do all the work. If it did not do them all
      // the next waiting thread will do the next snapshot until there
      // there is either no snapshot or no waiting threads.
      //
      // A downside to this design is a thread could have its resource enlisted by
      // an earlier thread while it enlists some later thread's resource.
      // Since they are all a part of the same transaction, this is probably
      // not a real issue.

      // If we are already enlisted there is no reason to check again, as this method
      // could be called multiple times during a transaction lifecycle.
      // We know that we can only be inside this method if we are allowed to

      // No transaction associated with the thread
      TransactionManager tm = getConnectionManager().getTransactionIntegration().getTransactionManager();
      int status = tm.getStatus();

      if (status == Status.STATUS_NO_TRANSACTION)
/n,
      {
         if (transactionSynchronization != null && transactionSynchronization.currentTx != null)
         {
            String error = "Attempt to use connection outside a transaction when already a tx!";
            log.tracef("%s %s", error, this);
            

            throw new IllegalStateException(error);
         }
         log.tracef("No transaction, no need to enlist: %s", this);

         return;
      }
	  
      // Inactive transaction
      Transaction threadTx = tm.getTransaction();
      if (threadTx == null || status != Status.STATUS_ACTIVE)
/n,
      {
         TxConnectionManager txConnectionManager = (TxConnectionManager)getConnectionManager();

         if (!txConnectionManager.isAllowMarkedForRollback())
         {
            String error = "Transaction " + threadTx + " is not active " + TxUtils.getStatusAsString(status);
            log.tracef("%s cl=%s",error, this);

            throw new IllegalStateException(error);
         }
      }

      log.tracef("Pre-enlist: %s threadTx=%s", this, threadTx);
this=cl

      // Our synchronization
      TransactionSynchronization ourSynchronization = null;

      // Serializes enlistment when two different threads are enlisting
      // different connections in the same transaction concurrently
      TransactionSynchronizer synchronizer = null;

         // Interleaving should have an unenlisted transaction
         if (!isTrackByTx() && transactionSynchronization != null)		/ transactionSynchronization == null
/n,
         {
            String error = "Can't enlist - already a tx!";
            log.tracef("%s %s", error, this);
            throw new IllegalStateException(error);
         }

         // Check for different transaction
         if (transactionSynchronization != null && !transactionSynchronization.currentTx.equals(threadTx))
/n,
         {
            String error = "Trying to change transaction " + threadTx + " in enlist!";
            log.tracef("%s %s", error, this);
            throw new IllegalStateException(error);
         }

         // Get the synchronizer
         try
         {
            log.tracef("Get synchronizer %s threadTx=%s",this, threadTx);

            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());
/s,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.getRegisteredSynchronizer(javax.transaction.Transaction, org.jboss.jca.core.spi.transaction.TransactionIntegration) line: 200	

      Object id = ti.getIdentifier(tx);
      Record record = records.get(id);
tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
ti	org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl  (id=21166)	
id	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
record	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer$Record  (id=22626)	

      return record.getTransactionSynchronizer();	/=          return txSync;
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 352	
            synchronizer =
               TransactionSynchronizer.getRegisteredSynchronizer(threadTx,
                  getConnectionManager().getTransactionIntegration());
/d,
synchronizer	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=22629)	
	records	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22623)	
	enlisted	java.util.ArrayList<E>  (id=22653)
[TransactionSynchronization@674601548{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:60 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]	
	enlistingThread	null	
	identifier	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	

	  
         }
         catch (Throwable t)
         {
            setTrackByTx(false);
            TxConnectionManagerImpl.rethrowAsSystemException("Cannot register synchronization", threadTx, t);
         }

         // First time through, create a transaction synchronization
         if (transactionSynchronization == null)
/j,
         {
            TransactionSynchronization synchronization = new TransactionSynchronization(threadTx, isTrackByTx());
            synchronizer.addUnenlisted(synchronization);
            transactionSynchronization = synchronization;
         }
synchronizer	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=22629)	
	enlisted	java.util.ArrayList<E>  (id=22653)	
		elementData	java.lang.Object[1]  (id=22693)	
			[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=21018)	
				this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20999)
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@2694a63f[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 connection handles=0 lastReturned=1526050567923 lastValidated=1526050366421 lastCheckedOut=1526050760686 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@2e8d2faf mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@3ba1a91d[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@2bc0537d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=TransactionSynchronization@674601548{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:60 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]				
	unenlisted	java.util.ArrayList<E>  (id=22681)	
		elementData	java.lang.Object[1]  (id=22705)	
			[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22677)	
				this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@29043380[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 connection handles=0 lastReturned=1526498637637 lastValidated=1526498637637 lastCheckedOut=1526498637637 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@12a3b7d5 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@777095ee[pool=RemoteExampleDS] xaResource=XAResourceWrapperImpl@5bcc6a79[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS] txSync=TransactionSynchronization@586576442{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:60 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=false cancel=false}]
		 
         ourSynchronization = transactionSynchronization;
      }	  
	  
      // Perform the enlistment(s)
      List<Synchronization> unenlisted = synchronizer.getUnenlisted();
      if (unenlisted != null)
      {
         try
         {
            int size = unenlisted.size();
            for (int i = 0; i < size; ++i)
            {
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 985	
            XAResource resource = getXAResource();
XAResourceWrapperImpl@5bcc6a79[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS]

            if (!currentTx.enlistResource(resource))
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
	/**
	 * This is the JTA compliant version of the method. However, you had better
	 * know that your XAResource and family are truly compliant implementations.
	 * If they aren't then we may fail gracefully (e.g., some versions of Oracle
	 * don't work with arbitrary Xid implementations!)
	 *
	 * If the family isn't compliant, then you should use the other method and
	 * pass through a relevant XAModifier, which should address the issues we
	 * have already come across.
	 */

	public boolean enlistResource(XAResource xaRes) throws RollbackException,
			IllegalStateException, javax.transaction.SystemException
	{
		return enlistResource(xaRes, null);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 430	
			try
			{
				synchronized (this)
				{
					info = (TxInfo) _resources.get(xaRes);
					
this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	_resources	java.util.Hashtable<K,V>  (id=20930)	
		table	java.util.Hashtable$Entry<K,V>[11]  (id=22789)	
			[7]	java.util.Hashtable$Entry<K,V>  (id=22794)	
				key	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=21019)	
XAResourceWrapperImpl@2bc0537d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]
				value	com.arjuna.ats.internal.jta.xa.TxInfo  (id=22799)	
					_state	0	
					_thread	java.lang.Thread  (id=18310)	
					_xid	com.arjuna.ats.jta.xa.XidImple  (id=22804)
xaRes=
XAResourceWrapperImpl@5bcc6a79[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS]					

					if (info == null)
					{
						/*
						 * Null info means it's not in the main resources list,
						 * but may be in the duplicates.
						 */

						info = (TxInfo) _duplicateResources.get(xaRes);
null
			/*
			 * We definitely haven't seen this specific resource instance
			 * before, but that doesn't mean that we haven't seen the RM it is
			 * connected to.
			 */

			Xid xid = null;
			TxInfo existingRM = isNewRM(xaRes);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.isNewRM(javax.transaction.xa.XAResource) line: 1478	
		try
		{
			synchronized (this)
			{
				Enumeration el = _resources.keys();
_resources={XAResourceWrapperImpl@2bc0537d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS]=com.arjuna.ats.internal.jta.xa.TxInfo@3ec6108f}
				if (el != null)
				{
					while (el.hasMoreElements())
					{
						XAResource x = (XAResource) el.nextElement();

						if (x.isSameRM(xaRes))
/s,
org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.isSameRM(javax.transaction.xa.XAResource) line: 159	
      else
      {
         if (resource instanceof org.jboss.jca.core.spi.transaction.xa.XAResourceWrapper)
         {
            org.jboss.jca.core.spi.transaction.xa.XAResourceWrapper other =
               (org.jboss.jca.core.spi.transaction.xa.XAResourceWrapper)resource;
            return xaResource.isSameRM(other.getResource());
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.isSameRM(javax.transaction.xa.XAResource) line: 377	

      // compare apples to apples
      return (other instanceof XAManagedConnection)
            ? xaResource.isSameRM(((XAManagedConnection) other).xaResource)
            : xaResource.isSameRM(other);
/s,
org.postgresql.xa.PGXAConnection.isSameRM(javax.transaction.xa.XAResource) line: 544	
        // This trivial implementation makes sure that the
        // application server doesn't try to use another connection
        // for prepare, commit and rollback commands.
        return xares == this;
/ false
xares	org.h2.jdbcx.JdbcXAConnection  (id=21446)	
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.isNewRM(javax.transaction.xa.XAResource) line: 1493	
				Enumeration el = _resources.keys();

				if (el != null)
				{
					while (el.hasMoreElements())
					{
						XAResource x = (XAResource) el.nextElement();

						if (x.isSameRM(xaRes))
/d,
/n,
						{
							return (TxInfo) _resources.get(x);
						}
					}
				}

				el = _duplicateResources.keys();
java.util.Collections$EmptyEnumeration@51e88e83
				if (el != null)
				{
					while (el.hasMoreElements())
/n,
		return null;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 607	
			Xid xid = null;
			TxInfo existingRM = isNewRM(xaRes);

			if (existingRM == null)
			{
				/*
				 * New RM, so create xid with new branch.
				 */

				boolean branchRequired = true;

				synchronized (this)
				{
					if (_resources.size() == 0)// first ever, so no need for
					// branch
/n,
					{
						// branchRequired = false;
						branchRequired = true;
					}
				}

				xid = createXid(branchRequired, theModifier, xaRes);
branchRequired==true
xaRes=XAResourceWrapperImpl@5bcc6a79[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@2f994bb5 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS]
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1529

                eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);	
/s,
com.arjuna.ats.internal.jbossatx.jta.XAResourceRecordWrappingPluginImpl.getEISName(javax.transaction.xa.XAResource) line: 72	
			String jndiName = ((XAResourceWrapper) xaResource).getJndiName();
			Integer key = nameToKey.get(jndiName);
3

this	com.arjuna.ats.internal.jbossatx.jta.XAResourceRecordWrappingPluginImpl  (id=20879)	
	eisNameStore	com.arjuna.ats.internal.arjuna.objectstore.ShadowNoFileLockStore  (id=22907)	
	keyToName	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22908)
{1=java:jboss/datasources/ExampleDS, 2=java:jboss/datasources/PostgreSQLDS, 3=java:jboss/datasources/RemoteExampleDS}	
	nameToKey	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22909)	
{java:jboss/datasources/RemoteExampleDS=3, java:jboss/datasources/ExampleDS=1, java:jboss/datasources/PostgreSQLDS=2}
	nextKey	java.util.concurrent.atomic.AtomicInteger  (id=22910)	
4
	nodeIdentifier	"1" (id=22911)	

/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.createXid(boolean, com.arjuna.ats.jta.xa.XAModifier, javax.transaction.xa.XAResource) line: 1535	
                eisName = _xaResourceRecordWrappingPlugin.getEISName(xaResource);
/d,
3
            }
        }
		Xid xid = new XidImple(_theTransaction.get_uid(), branch, eisName);
/s,
com.arjuna.ats.jta.xa.XidImple.<init>(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 90	
id	com.arjuna.ats.arjuna.common.Uid  (id=19065)	
branch	true	
eisName	java.lang.Integer  (id=22914)	
/=
0:ffffbea85a97:-35437ec6:5af567cc:60
true
3
			_theXid = XATxConverter.getXid(id, branch, eisName);
/s,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 60	
/=
    static XID getXid (Uid uid, boolean branch, Integer eisName) throws IllegalStateException
    {
        if (branch)
            return getXid(uid, new Uid(), FORMAT_ID, eisName);	/ new Uid() is de branch,
/s,
com.arjuna.ats.arjuna.utils.Utility.hostInetAddr() line: 173	
    /**
     * @return Long(s) representing the ip v6 address of the local machine.
     *         Essentially the bytes of the InetAddress are shuffled into the
     *         long(s). This was once part of the Uid class but has been
     *         separated for general availability.
     * @since JTS 2.1.
     */
    public static long[] hostInetAddr() throws UnknownHostException {
        if(myAddr == null) {
            calculateHostInetAddr();
        }

        return myAddr;
[0, 281473880447639]
    }
/t,
com.arjuna.ats.arjuna.common.Uid.<init>() line: 80	
            hostAddr = Utility.hostInetAddr(); /* calculated only once */
/d,
            process = Utility.getpid();
-893615814
            if (Uid.initTime == 0)
/n,
                Uid.initTime = (int) (System.currentTimeMillis() / 1000);

            sec = Uid.initTime;
1526032332
            other = Uid.getValue();
122
/ TODO
            _valid = true;

            generateHash();
/s,
                _hashValue = (int) hostAddr[0] ^ (int) hostAddr[1] ^ process
                        ^ sec ^ other;
				if (_hashValue < 0)
					_hashValue = -_hashValue;				
/t,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, boolean, java.lang.Integer) line: 60	
        if (branch)
            return getXid(uid, new Uid(), FORMAT_ID, eisName);
/pd,
/s,
com.arjuna.ats.jta.xa.XATxConverter.getXid(com.arjuna.ats.arjuna.common.Uid, com.arjuna.ats.arjuna.common.Uid, int, java.lang.Integer) line: 82	
/=
    private static XID getXid(Uid uid, Uid branch, int formatId, Integer eisName) throws IllegalStateException
uid=0:ffffbea85a97:-35437ec6:5af567cc:60
branch=0:ffffbea85a97:-35437ec6:5af567cc:7a
formatId=131077
eisName=3
       XID xid = new XID();
        xid.formatID = formatId;

        // gtrid is uid byte form followed by as many chars of the node name as will fit.
/ gtrid is WH global transaction id,
        byte[] gtridUid = uid.getBytes();
		
        String nodeName = TxControl.getXANodeName();
1
        int nodeNameLengthToUse =  nodeName.getBytes().length;
1
        xid.gtrid_length = gtridUid.length+nodeNameLengthToUse;

        // src, srcPos, dest, destPos, length
        System.arraycopy(gtridUid, 0, xid.data, 0, gtridUid.length);
        System.arraycopy(nodeName.getBytes(), 0, xid.data, gtridUid.length, nodeNameLengthToUse);

        if (branch.notEquals(Uid.nullUid()))
		{
            // bqual is uid byte form plus EIS name.
            byte[] bqualUid = branch.getBytes();

            if (bqualUid.length > XID.MAXBQUALSIZE) {
                throw new IllegalStateException(); // Uid is too long!!!!
            }

            int spareBqualBytes = XID.MAXBQUALSIZE - (bqualUid.length + 4);
           
            xid.bqual_length = bqualUid.length+4+4;

            // src, srcPos, dest, destPos, length
            int offset = xid.gtrid_length;
            System.arraycopy (bqualUid, 0, xid.data, offset, bqualUid.length);
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 609	
				xid = createXid(branchRequired, theModifier, xaRes);
/d,
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffbea85a97:-35437ec6:5af567cc:60, node_name=1, branch_uid=0:ffffbea85a97:-35437ec6:5af567cc:7a, subordinatenodename=null, eis_name=java:jboss/datasources/RemoteExampleDS >

				/*
				 * If another process has (or is about to) create the same
				 * transaction association then we will probably get a failure
				 * during start with XAER_DUPID. We know this must be due to
				 * another server, since we keep track of our own registrations.
				 * So, if this happens we create a new transaction branch and
				 * try again.
				 *
				 * To save time we could always just create branches by default.
				 *
				 * Is there a benefit to a zero branch?
				 */

				while (!associatedWork)
				{
					try
					{
						if (_xaTransactionTimeoutEnabled)
						{
							int timeout = _theTransaction.getTimeout();

							if (timeout > 0)
							{
								try
								{
									xaRes.setTransactionTimeout(timeout);

								int xaStartNormal = ((theModifier == null) ? XAResource.TMNOFLAGS
/j,
									: theModifier
											.xaStartParameters(XAResource.TMNOFLAGS));
											
                        // Pay attention now, this bit is hairy. We need to add a new AbstractRecord (XAResourceRecord)
                        // to the BasicAction, which will thereafter drive its completion. However, the transaction
                        // core is not directly XA aware, so it's our job to start the XAResource. Problem is, if
                        // adding the record fails, BasicAction will never end the resource via the XAResourceRecord,
                        // so we must do so directly.  start may fail due to dupl xid or other reason, and transactions
                        // may rollback async, for which reasons we can't call add before start.
                        // The xid will change on each pass of the loop, so we need to create a new record on each pass.
                        // The add will fail in the case of multiple last resources being disallowed
                        // see JBTM-362 and JBTM-363
                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);	/ params==null
/s,
							return new XAResourceRecord(this, xaRes, xid, params);
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.<init>(com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple, javax.transaction.xa.XAResource, javax.transaction.xa.Xid, java.lang.Object[]) line: 111	

		super(new Uid(), null, ObjectType.ANDPERSISTENT);
/ new Uid()=	 * @param storeUid the unique id for this instance.

		_theXAResource = res;
		...
		_tranID = xid;
		_heuristic = TwoPhaseOutcome.FINISH_OK;
		...
		_theTransaction = tx;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 661	
                        AbstractRecord abstractRecord = createRecord(xaRes, params, xid);
/d,
                        if(abstractRecord != null) {
                            xaRes.start(xid, xaStartNormal);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 259	
            xaResource.start(xid, flags);

this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	
	xaResource	org.h2.jdbcx.JdbcXAConnection  (id=21446)	

/ Intermezzo

Thread [default task-67] (Suspended (breakpoint at line 328 in org.h2.jdbcx.JdbcXAConnection))	
	org.h2.jdbcx.JdbcXAConnection.start(javax.transaction.xa.Xid, int) line: 328	
	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 259	
	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.start(javax.transaction.xa.Xid, int) line: 215	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 662	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986	
	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 379	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 553	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).reconnectManagedConnection(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 928	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
	org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
	org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87
/=
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
/cb,	
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	

					preparedStatement = doPrepare();
/cb,
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String) line: 72	
	org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 94
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
/cb,	
	org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 40	
	org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 101	
	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );		 / <-

			return performSave( entity, generatedId, persister, false, anything, source, true );
/cb,
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener.saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 67	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 189
	
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/cb,	
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 132
			case TRANSIENT: {
				entityIsTransient( event, createCache );
				break;
			}
/cb,			
	org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent) line: 58	
	org.hibernate.internal.SessionImpl.firePersist(org.hibernate.event.spi.PersistEvent) line: 775	
	org.hibernate.internal.SessionImpl.persist(java.lang.String, java.lang.Object) line: 748	
	org.hibernate.internal.SessionImpl.persist(java.lang.Object) line: 753	
	org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1146	
	org.jboss.as.jpa.container.TransactionScopedEntityManager(org.jboss.as.jpa.container.AbstractEntityManager).persist(java.lang.Object) line: 580
            transactionIsRequired();
            getEntityManager().persist(entity);
/cb,			
	repository.LanguageDao.insertInTx() line: 86
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
		l=new Language();
		l.setName("Java");
		em1.persist(l);

/ Einde Intermezzo
	
/s,
    /**
     * Start or continue to work on a transaction.
     *
org.h2.jdbcx.JdbcXAConnection.start(javax.transaction.xa.Xid, int) line: 342	
/=
    public void start(Xid xid, int flags) throws XAException {
flags=TMNOFLAGS
        try {
            physicalConn.setAutoCommit(false);
        } catch (SQLException e) {
            throw convertException(e);
        }
        currentTransaction = xid;
        prepared = false;	
/t,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection.start(javax.transaction.xa.Xid, int) line: 275	
            xaResource.start(xid, flags);
/d,
            currentXid = xid;
            inManagedTransaction = true;
/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 663	
                            xaRes.start(xid, xaStartNormal);
/d,
                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.BasicAction).add(com.arjuna.ats.arjuna.coordinator.AbstractRecord) line: 315	
            result = (pendingList.insert(A) ? AddOutcome.AR_ADDED
                    : AddOutcome.AR_DUPLICATE);

this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=18479)	
	objectUid	com.arjuna.ats.arjuna.common.Uid  (id=19065)
0:ffffbea85a97:-35437ec6:5af567cc:60	
	pendingList	com.arjuna.ats.arjuna.coordinator.RecordList  (id=20938)	
		listHead	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=23046)	
			_jndiName	"java:jboss/datasources/PostgreSQLDS" (id=22855)	
			_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
			_theXAResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=21019)	
				jndiName	"java:jboss/datasources/PostgreSQLDS" (id=22855)	
				xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21012)	
					currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22804)	
						_theXid	com.arjuna.ats.internal.jta.xa.XID  (id=23209)
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffbea85a97:-35437ec6:5af567cc:60, node_name=1, branch_uid=0:ffffbea85a97:-35437ec6:5af567cc:63, subordinatenodename=null, eis_name=java:jboss/datasources/PostgreSQLDS >						
					xaConnection	org.postgresql.xa.PGXAConnection  (id=22893)	
					xaResource	org.postgresql.xa.PGXAConnection  (id=22893)	
			_tranID	com.arjuna.ats.jta.xa.XidImple  (id=22804)	
				_theXid	com.arjuna.ats.internal.jta.xa.XID  (id=23209)	
			objectUid	com.arjuna.ats.arjuna.common.Uid  (id=23096)
0:ffffbea85a97:-35437ec6:5af567cc:65
		listTail	com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord  (id=22969)	
			_jndiName	"java:jboss/datasources/RemoteExampleDS" (id=21158)	
			_theXAResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22007)	
				xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	
					con	org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection  (id=21588)	
					currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22947)	
						_theXid	com.arjuna.ats.internal.jta.xa.XID  (id=22959)
< formatId=131077, gtrid_length=29, bqual_length=36, tx_uid=0:ffffbea85a97:-35437ec6:5af567cc:60, node_name=1, branch_uid=0:ffffbea85a97:-35437ec6:5af567cc:7a, subordinatenodename=null, eis_name=java:jboss/datasources/RemoteExampleDS >						
					xaConnection	org.h2.jdbcx.JdbcXAConnection  (id=21446)	
					xaResource	org.h2.jdbcx.JdbcXAConnection  (id=21446)	
			objectUid	com.arjuna.ats.arjuna.common.Uid  (id=23449)
0:ffffbea85a97:-35437ec6:5af567cc:7c

/ we zien dat de XAREsourceRecords ook zelf een uid hebben 	, 
/ we zien in beide XAResources de XIDs	, elk met de global tx uid ... 60 , en een eigen branch uid, ... 63 en ... 7a			

/t,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource, java.lang.Object[]) line: 664

this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	_theTransaction	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=18479)	
	
                            if(_theTransaction.add(abstractRecord) == AddOutcome.AR_ADDED) {
/d,
                                _resources.put(xaRes, new TxInfo(xid));

this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
	_resources	java.util.Hashtable<K,V>  (id=20930)	
		table	java.util.Hashtable$Entry<K,V>[11]  (id=22789)	
			[7]	java.util.Hashtable$Entry<K,V>  (id=22794)	
				key	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=21019)
					jndiName	"java:jboss/datasources/PostgreSQLDS" (id=22855)	
					xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21012)	
						currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22804)	
						xaResource	org.postgresql.xa.PGXAConnection  (id=22893)	
				value	com.arjuna.ats.internal.jta.xa.TxInfo  (id=22799)	
					_thread	java.lang.Thread  (id=18310)				Thread[default task-67,5,main]
					_xid	com.arjuna.ats.jta.xa.XidImple  (id=22804)	
			[9]	java.util.Hashtable$Entry<K,V>  (id=23467)	
				key	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22007)
					jndiName	"java:jboss/datasources/RemoteExampleDS" (id=21158)	
					xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	
						currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22947)	
						xaResource	org.h2.jdbcx.JdbcXAConnection  (id=21446)	
				value	com.arjuna.ats.internal.jta.xa.TxInfo  (id=23457)	
					_state	0	
					_thread	java.lang.Thread  (id=18310)				Thread[default task-67,5,main]
					_xid	com.arjuna.ats.jta.xa.XidImple  (id=22947)	

                                return true; // dive out, no need to set associatedWork = true;
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986	

            XAResource resource = getXAResource();
            if (!currentTx.enlistResource(resource))
/d,
/n,
             enlisted = true;
            return true;
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 381	
               if (sync.enlist())
/d,
               {
                  synchronizer.addEnlisted(sync);
/s,
org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer.addEnlisted(javax.transaction.Synchronization) line: 153	
      enlisted.add(synch);

this	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=22629)	
	enlisted	java.util.ArrayList<E>  (id=22653)	
		elementData	java.lang.Object[2]  (id=23665)	
			[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=21018)
				currentTx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
				enlisted	true	
				this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=20999)	
				wasTrackByTx	true				
			[1]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22677)
				currentTx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=18477)	
				enlisted	true	
				recordEnlist	true	
				this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
				wasTrackByTx	true	
/t,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 387	
               if (sync.enlist())
               {
                  synchronizer.addEnlisted(sync);
/d,
               }
            }
         }
         finally
         {
            synchronizer.enlisted();
/s,
   /**
    * This thread has finished enlisting.
    */
   public synchronized void enlisted()
	...
      enlistingThread = null;
/t,
      setEnlisted(true);
...
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 753	
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/d,
      // Ask the managed connection for a connection
      Object connection = null;
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getWrappedConnection() line: 1193	
      WrappedConnection lc = WRAPPED_CONNECTION_FACTORY.createWrappedConnection(this,
                                                                                mcf.getSpy().booleanValue(),
                                                                                mcf.getJndiName(),
                                                                                mcf.isDoLocking());
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionFactoryJDK7.createWrappedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection, boolean, java.lang.String, boolean) line: 60	
      return new WrappedConnectionJDK7(mc, spy, jndiName, doLocking);
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 773
	
         connection = cl.getManagedConnection().getConnection(subject, cri);
/d,
      // Associate managed connection with the connection
      registerAssociation(cl, connection);
/ TODO
/ Beide hebben
mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener(org.jboss.jca.core.connectionmanager.listener.AbstractConnectionListener).registerConnection(java.lang.Object) line: 303	
/=
   public void registerConnection(Object handle)
   {
      if (handle != null)
      {
         connectionHandles.add(handle);
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 775	

      // Associate managed connection with the connection
      registerAssociation(cl, connection);
/d,
cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22016)	
	connectionHandles	java.util.concurrent.CopyOnWriteArraySet<E>  (id=22595)
[org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7@5e303b80]	
	managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=21471)	

      if (cachedConnectionManager != null)
      {
         cachedConnectionManager.registerConnection(this, cl, connection);
/ TODO
      }

      return connection;
/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 139	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/d,
         wc.setDataSource(this);
         wc.setSpy(mcf.getSpy().booleanValue());
         wc.setJndiName(mcf.getJndiName());
         return wc;
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
/n,
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 443	
      try
      {
         checkTransaction();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).checkTransaction() line: 1918	
      checkStatus();
      mc.checkTransaction();
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).checkTransaction() line: 900	
/=
   /**
    * The <code>checkTransaction</code> method makes sure the adapter follows the JCA
    * autocommit contract, namely all statements executed outside a container managed transaction
    * or a component managed transaction should be autocommitted. To avoid continually calling
    * setAutocommit(enable) before and after container managed transactions, we keep track of the state
    * and check it before each transactional method call.
    * @exception SQLException Thrown if an error occurs
    */
   void checkTransaction() throws SQLException
   {
      synchronized (stateLock)
      {
         if (inManagedTransaction)
            return;
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
         checkTransaction();
         try
         {
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 704	
      else
      {
         return doPrepareStatement(sql, resultSetType, resultSetConcurrency);	/ sql=call next value for hibernate_sequence
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);
/s,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).prepareStatement(java.lang.String, int, int) line: 636	
            return new JdbcPreparedStatement(this, sql, id, resultSetType, resultSetConcurrency, false);
/s,
org.h2.jdbc.JdbcPreparedStatement.<init>(org.h2.jdbc.JdbcConnection, java.lang.String, int, int, int, boolean) line: 70	
        command = conn.prepareCommand(sql, fetchSize);
/s,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).prepareCommand(java.lang.String, int) line: 1138	
/=
    /**
     * Prepare an command. This will parse the SQL statement.
     *
     * @param sql the SQL statement
     * @param fetchSize the fetch size (used in remote connections)
     * @return the command
     */
    CommandInterface prepareCommand(String sql, int fetchSize) {
        return session.prepareCommand(sql, fetchSize);
/s,
org.h2.engine.SessionRemote.prepareCommand(java.lang.String, int) line: 449	
        checkClosed();
        return new CommandRemote(this, transferList, sql, fetchSize);
/s,
org.h2.command.CommandRemote.<init>(org.h2.engine.SessionRemote, java.util.ArrayList<org.h2.value.Transfer>, java.lang.String, int) line: 40	
        prepare(session, true);
/s,
org.h2.command.CommandRemote.prepare(org.h2.engine.SessionRemote, boolean) line: 54	
        id = s.getNextId();
5
        for (int i = 0, count = 0; i < transferList.size(); i++) {
            try {
                Transfer transfer = transferList.get(i);
                if (createParams) {
                    s.traceOperation("SESSION_PREPARE_READ_PARAMS", id);
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql); 
/ sql = call next val-ue for hibernate_sequence
                s.done(transfer);
                isQuery = transfer.readBoolean(); / true
                readonly = transfer.readBoolean();	/ false
                int paramCount = transfer.readInt(); / 0
                if (createParams) {
/j,
                    parameters.clear();
                    for (int j = 0; j < paramCount; j++) {
/n,
/t,
org.h2.jdbc.JdbcPreparedStatement.<init>(org.h2.jdbc.JdbcConnection, java.lang.String, int, int, int, boolean) line: 70	
        command = conn.prepareCommand(sql, fetchSize);
/d,
/t,
org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection(org.h2.jdbc.JdbcConnection).prepareStatement(java.lang.String, int, int) line: 644	
            return new JdbcPreparedStatement(this, sql, id, resultSetType, resultSetConcurrency, false);
/d,
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/pd,
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).<init>(org.jboss.jca.adapters.jdbc.WrappedConnection, java.sql.Statement, boolean, java.lang.String, boolean, java.lang.String) line: 129
	
      lc.registerStatement(this);
	  
this	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=20437)	
	lc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=20412)	
		statements	java.util.HashMap<K,V>  (id=20443)	
{org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@2cda72f8=null}
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 466	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/d,
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/d,
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
					preparedStatement = doPrepare();
/d,
				postProcess( preparedStatement );
/s,
		public void postProcess(PreparedStatement preparedStatement) throws SQLException {
			jdbcCoordinator.getResourceRegistry().register( preparedStatement, true );
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.register(java.sql.Statement, boolean) line: 61	
		xref.put( statement, null );
		if ( cancelable ) {
			lastQuery = statement;

this	org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl  (id=20488)	
	xref	java.util.HashMap<K,V>  (id=20491)	
{org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@2cda72f8=null}
...
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96	
/=
		return new AccessCallback() {
			@Override
			public IntegralDataTypeHolder getNextValue() {
				accessCounter++;
				try {
					final PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
/d,
					try {
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.<init>(org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 44	
		this.jdbcCoordinator = jdbcCoordinator;

		final JdbcServices jdbcServices = jdbcCoordinator.getJdbcSessionOwner()
				.getJdbcSessionContext()
				.getServiceRegistry()
				.getService( JdbcServices.class );
/s,
org.hibernate.service.internal.SessionFactoryServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 189	
		R service = serviceRole.cast( initializedServiceByRole.get( serviceRole ) ); 
serviceRole=interface org.hibernate.engine.jdbc.spi.JdbcServices
		if ( service != null ) {
/j,
			return service;
		}				
				
this	org.hibernate.service.internal.SessionFactoryServiceRegistryImpl  (id=20507)	
	initializedServiceByRole	org.hibernate.service.internal.ConcurrentServiceBinding<K,V>  (id=20511)	
		treeRoot	org.hibernate.service.internal.ConcurrentServiceBinding$Node<K,V>  (id=20514)
/=		
<interface org.hibernate.engine.jdbc.spi.JdbcServices, org.hibernate.engine.jdbc.internal.JdbcServicesImpl@32241431>
L-> <interface org.hibernate.engine.jdbc.connections.spi.ConnectionProvider, org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl@4d96fd3f>
	L-> <interface org.hibernate.engine.spi.CacheImplementor, org.hibernate.internal.CacheImpl@9a3227c>
		L-> <interface org.hibernate.engine.config.spi.ConfigurationService, org.hibernate.engine.config.internal.ConfigurationServiceImpl@67da8fb9>
			L-> <interface org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform, org.jboss.as.jpa.hibernate5.JBossAppServerJtaPlatform@75cd8aef>
		R-> <interface org.hibernate.integrator.spi.IntegratorService, org.hibernate.integrator.internal.IntegratorServiceImpl@f48fe6c>
	R-> <interface org.hibernate.boot.registry.classloading.spi.ClassLoaderService, org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl@1f689d3b>
		L-> <interface org.hibernate.engine.jndi.spi.JndiService, org.hibernate.engine.jndi.internal.JndiServiceImpl@2cfc7e28>
		R-> <interface org.hibernate.stat.spi.StatisticsImplementor, Statistics[start time=1526661402389,sessions opened=0,sessions closed=0,transactions=0,successful transactions=0,optimistic lock failures=0,flushes=0,connections obtained=0,statements prepared=0,statements closed=0,second level cache puts=0,second level cache hits=0,second level cache misses=0,entities loaded=0,entities updated=0,entities inserted=0,entities deleted=0,entities fetched=0,collections loaded=0,collections updated=0,collections removed=0,collections recreated=0,collections fetched=0,naturalId queries executed to database=0,naturalId cache puts=0,naturalId cache hits=0,naturalId cache misses=0,naturalId max query time=0,queries executed to database=0,query cache puts=0,query cache hits=0,query cache misses=0,update timestamps cache puts=0,update timestamps cache hits=0,update timestamps cache misses=0,max query time=0]>
R-> <interface org.hibernate.envers.boot.internal.EnversService, org.hibernate.envers.boot.internal.EnversServiceImpl@357f13aa>
	L-> <interface org.hibernate.engine.query.spi.NativeQueryInterpreter, org.hibernate.engine.query.internal.NativeQueryInterpreterStandardImpl@7d0c30f7>
		L-> <interface org.hibernate.secure.spi.JaccService, org.hibernate.secure.internal.DisabledJaccServiceImpl@26d6eb28>
		R-> <interface org.hibernate.boot.cfgxml.spi.CfgXmlAccessService, org.hibernate.boot.cfgxml.internal.CfgXmlAccessServiceImpl@6914cce4>
	R-> <interface org.hibernate.persister.spi.PersisterFactory, org.hibernate.persister.internal.PersisterFactoryImpl@243b602f>
		L-> <interface org.hibernate.event.service.spi.EventListenerRegistry, org.hibernate.event.service.internal.EventListenerRegistryImpl@382c77d7>
		R-> <interface org.hibernate.resource.transaction.TransactionCoordinatorBuilder, org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl@29b25451>
/t,
		this.dialect = jdbcServices.getDialect();
/s,
org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getDialect() line: 77	
		if ( jdbcEnvironment != null ) {
			return jdbcEnvironment.getDialect();	/ org.hibernate.dialect.H2Dialect
/t,
		this.sqlStatementLogger = jdbcServices.getSqlStatementLogger();
		this.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 96	
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/pd,
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 70	
		try {
			final ResultSet rs;
			try {
				rs = statement.executeQuery();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 495	
      if (doLocking)
         lock();
      try
      {
         checkTransaction();
         try 
         {
            checkConfiguredQueryTimeout();

            ResultSet resultSet = ps.executeQuery();
/s,
org.h2.jdbc.JdbcPreparedStatement.executeQuery() line: 94	
            int id = getNextId(TraceObject.RESULT_SET);	/ 58 TODO
           
            synchronized (session) {
				...
                ResultInterface result;
                boolean scrollable = resultSetType != ResultSet.TYPE_FORWARD_ONLY;
                boolean updatable = resultSetConcurrency == ResultSet.CONCUR_UPDATABLE;
                try {
                    setExecutingStatement(command);	/  command=CommandRemote call next value for hibernate_sequence
/s,
org.h2.jdbc.JdbcPreparedStatement(org.h2.jdbc.JdbcStatement).setExecutingStatement(org.h2.command.CommandInterface) line: 1025	
        } else {
            conn.setExecutingStatement(this);
conn	org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection  (id=20427)	conn11: url=jdbc:h2:tcp://localhost/~/h2/test user=SA
/ sets conn.statement,
            lastExecutedCommandType = c.getCommandType(); / UNKNOWN
        }
        executingCommand = c;
/t,
                    result = command.executeQuery(maxRows, scrollable);
/s,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 137	
        synchronized (session) {
            int objectId = session.getNextId();
6
            ResultRemote result = null;
            for (int i = 0, count = 0; i < transferList.size(); i++) {
                prepareIfRequired();
                Transfer transfer = transferList.get(i);
                try {
                    session.traceOperation("COMMAND_EXECUTE_QUERY", id);
                    transfer.writeInt(SessionRemote.COMMAND_EXECUTE_QUERY).writeInt(id).writeInt(objectId).writeInt(
                            maxRows);
/ id=5 klopt, net als bij prepare, objectId=6 TODO
                    int fetch;
                    
                    } else {
                        fetch = fetchSize;
                    }
                    transfer.writeInt(fetch);
                    sendParameters(transfer);
                    session.done(transfer);
                    int columnCount = transfer.readInt();
                    if (result != null) {
/n,
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch);
/s,
org.h2.result.ResultRemote.<init>(org.h2.engine.SessionRemote, org.h2.value.Transfer, int, int, int) line: 46	
	...
        this.id = id;
        this.columns = new ResultColumn[columnCount];
        rowCount = transfer.readInt();
        for (int i = 0; i < columnCount; i++) {	/ columnCount==1
            columns[i] = new ResultColumn(transfer);
        }
        rowId = -1;
        result = New.arrayList();
        this.fetchSize = fetchSize;
        fetchRows(false);
/s,
org.h2.result.ResultRemote.fetchRows(boolean) line: 221	

                for (int r = 0; r < fetch; r++) {
                    boolean row = transfer.readBoolean();
                    if (!row) {
                        break;
                    }
                    int len = columns.length;
                    Value[] values = new Value[len];
                    for (int i = 0; i < len; i++) {
                        Value v = transfer.readValue();
                        values[i] = v;
                    }
                    result.add(values);
                if (rowOffset + result.size() >= rowCount) {
                    sendClose();
/ TODO
                }			
/s,
org.h2.value.Transfer.readValue() line: 573 [local variables unavailable]	
        int type = readInt();
        switch(type) {
        case Value.LONG:
            return ValueLong.get(readLong());
/s,
    public long readLong() throws IOException {
        return in.readLong();
/t,
/t,
org.h2.command.CommandRemote.executeQuery(int, boolean) line: 167	
                    result = new ResultRemote(session, transfer, objectId, columnCount, fetch);
/d,
            session.autoCommitIfCluster();
            session.readSessionState();
            return result;
/t,
org.h2.jdbc.JdbcPreparedStatement.executeQuery() line: 108 [local variables unavailable]	

                    result = command.executeQuery(maxRows, scrollable);
/d,
                resultSet = new JdbcResultSet(conn, this, result, id, closedByResultSet, scrollable, updatable, cachedColumnLabelMap);
            return resultSet;
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeQuery() line: 505	
            ResultSet resultSet = ps.executeQuery();
/d,
resultSet	org.h2.jdbc.JdbcResultSet  (id=20578)	
	result	org.h2.result.ResultRemote  (id=20571)	
		columns	org.h2.result.ResultColumn[1]  (id=20574)	
			[0]	org.h2.result.ResultColumn  (id=20572)	
				columnName	"NEXT VALUE FOR PUBLIC.HIBERNATE_SEQUENCE" (id=20617)	
				columnType	5	
		result	java.util.ArrayList<E>  (id=20573)	
			elementData	java.lang.Object[4]  (id=20620)	
				[0]	org.h2.value.Value[1]  (id=20622)	
					[0]	org.h2.value.ValueLong  (id=20577)	
						value	160
						
            return registerResultSet(resultSet);
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedStatement).registerResultSet(java.sql.ResultSet) line: 1525	
      if (resultSet != null)
         resultSet = wrapResultSet(resultSet, spy, jndiName, doLocking);
/s,
      return new WrappedResultSetJDK7(this, resultSet, spy, jndiName, doLocking);
/t,
      WrappedResultSet wrapped = (WrappedResultSet) resultSet;
      
      synchronized (this)
      {
         if (resultSets == null)
            resultSets = new HashMap<WrappedResultSet, Throwable>(1);
         
         if (lc.getTrackStatements() == BaseWrapperManagedConnectionFactory.TRACK_STATEMENTS_TRUE_INT)
/n,
            resultSets.put(wrapped, new Throwable("STACKTRACE"));
         else
            resultSets.put(wrapped, null);

this	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=20437)	
	resultSets	java.util.HashMap<K,V>  (id=20716)	
		table	java.util.HashMap$Node<K,V>[2]  (id=20719)	
			[0]	java.util.HashMap$Node<K,V>  (id=20718)	
				key	org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7  (id=20715)	
					jndiName	"java:jboss/datasources/RemoteExampleDS" (id=20439)	
					resultSet	org.h2.jdbc.JdbcResultSet  (id=20578)	
						result	org.h2.result.ResultRemote  (id=20571)	
							result	java.util.ArrayList<E>  (id=20573)	
								elementData	java.lang.Object[4]  (id=20620)	
									[0]	org.h2.value.Value[1]  (id=20622)	
										[0]	org.h2.value.ValueLong  (id=20577)	
      return resultSet;
/t,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(java.sql.PreparedStatement) line: 75	
				rs = statement.executeQuery();
/d,
			postExtract( rs, statement );
			return rs;
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.postExtract(java.sql.ResultSet, java.sql.Statement) line: 231	
			jdbcCoordinator.getResourceRegistry().register( rs, st );
/ TODO jdbcCoordinator.getResourceRegistry()
...
/s,
org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl.register(java.sql.ResultSet, java.sql.Statement) line: 200	
			Set<ResultSet> resultSets = xref.get( statement );
this	org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl  (id=20488)	
	xref	java.util.HashMap<K,V>  (id=20491)	
		table	java.util.HashMap$Node<K,V>[16]  (id=20493)	
			[2]	java.util.HashMap$Node<K,V>  (id=20494)	
				key	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=20437)	
				value	null
/ de pstmt zit er wel in, maar met value null,

			if ( resultSets == null ) {
/j,
				resultSets = new HashSet<ResultSet>();
				xref.put( statement, resultSets );
			}
			resultSets.add( resultSet );
...
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 98	
						final ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
/d,
						try {
							rs.next();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7(org.jboss.jca.adapters.jdbc.WrappedResultSet).next() line: 2689	
            return resultSet.next();
/s,
org.h2.jdbc.JdbcResultSet.next() line: 120	
            return nextRow();
/s,
org.h2.jdbc.JdbcResultSet.nextRow() line: 3156	
        boolean next = result.next();
/s,
org.h2.result.ResultRemote.next() line: 129 [local variables unavailable]	

this	org.h2.result.ResultRemote  (id=20571)	
	columns	org.h2.result.ResultColumn[1]  (id=20574)	
			columnName	"NEXT VALUE FOR PUBLIC.HIBERNATE_SEQUENCE" (id=20617)	
			columnType	5	
	result	java.util.ArrayList<E>  (id=20573)	
		elementData	java.lang.Object[4]  (id=20620)	
			[0]	org.h2.value.Value[1]  (id=20622)	
	rowCount	1	
	rowId	-1	
	rowOffset	0	

        if (rowId < rowCount) {
            rowId++;
            if (rowId < rowCount) {
                if (rowId - rowOffset >= result.size()) 
/n,
                    fetchRows(true);
                }
                currentRow = result.get(rowId - rowOffset);	/ get from ArrayList,
                return true;
				
currentRow	org.h2.value.Value[1]  (id=20622)	
	[0]	org.h2.value.ValueLong  (id=20577)	
		value	160	
/t,
org.hibernate.id.enhanced.SequenceStructure$1.getNextValue() line: 99	
							rs.next();
/d,
							final IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
/s,
			return new BasicHolder( integralType );	/ integralType=Long.class
/t,
							value.initialize( rs, 1 );

rs	org.jboss.jca.adapters.jdbc.jdk7.WrappedResultSetJDK7  (id=20715)	
	resultSet	org.h2.jdbc.JdbcResultSet  (id=20578)	
		result	org.h2.result.ResultRemote  (id=20571)	
			currentRow	org.h2.value.Value[1]  (id=20622)	
				[0]	org.h2.value.ValueLong  (id=20577)	
					value	160	
value	org.hibernate.id.IdentifierGeneratorHelper$BasicHolder  (id=21278)	
	exactType	java.lang.Class<T> (java.lang.Long) (id=19152)	
	value	160	
							return value;
						finally {
								try {
									session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
					finally {
						session.getJdbcCoordinator().getResourceRegistry().release( st );
/t,
org.hibernate.id.enhanced.NoopOptimizer.generate(org.hibernate.id.enhanced.AccessCallback) line: 41	
		// IMPL NOTE : this method is called concurrently and is
		// not synchronized. It is very important to work on the
		// local variable: the field lastSourceValue is not
		// reliable as it might be mutated by multipled threads.
		// The lastSourceValue field is only accessed by tests,
		// so this is not a concern.
		IntegralDataTypeHolder value = callback.getNextValue();
/d,
		lastSourceValue = value;
		return value.makeValue();	/= return value
/t,
/ CONSTRUCTION
org.hibernate.id.enhanced.SequenceStyleGenerator.generate(org.hibernate.engine.spi.SessionImplementor, java.lang.Object) line: 412	
		return optimizer.generate( databaseStructure.buildCallback( session ) );
/d,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).saveWithGeneratedId(java.lang.Object, java.lang.String, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 102	

		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/d,
160
			return performSave( entity, generatedId, persister, false, anything, source, true );
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSave(java.lang.Object, java.io.Serializable, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 152	
/=
	protected Serializable performSave(
			Object entity,					/ Language Java
			Serializable id,				/ 160
			EntityPersister persister,
			...
		if ( !useIdentityColumn ) {
			key = source.generateEntityKey( id, persister );

key	org.hibernate.engine.spi.EntityKey  (id=21342)	
	hashCode	789	
	identifier	java.lang.Long  (id=21324)	
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=19827)	

			Object old = source.getPersistenceContext().getEntity( key ); /= return entitiesByKey.get( key );
null
			persister.setIdentifier( entity, id, source ); /= idSetter.set( entity, id, getFactory() ); / sets id in entity,

		return performSaveOrReplicate(
				entity,
				key,
				persister,
				useIdentityColumn,
				anything,
				source,
				requiresImmediateIdAccess
		);
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 227	

		Serializable id = key == null ? null : key.getIdentifier();
160
		boolean inTxn = source.isTransactionInProgress();
		boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;

		// Put a placeholder in entries, so we don't recurse back and try to save() the
		// same object again. QUESTION: should this be done before onSave() is called?
		// likewise, should it be done before onUpdate()?
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 509	
		/*
			IMPORTANT!!!

			The following instanceof checks and castings are intentional.

			DO NOT REFACTOR to make calls through the EntityEntryFactory interface, which would result
			in polymorphic call sites which will severely impact performance.

			When a virtual method is called via an interface the JVM needs to resolve which concrete
			implementation to call.  This takes CPU cycles and is a performance penalty.  It also prevents method
			in-ling which further degrades performance.  Casting to an implementation and making a direct method call
			removes the virtual call, and allows the methods to be in-lined.  In this critical code path, it has a very
			large impact on performance to make virtual method calls.
		*/
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/s,
org.hibernate.engine.internal.MutableEntityEntryFactory.createEntityEntry(org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean, org.hibernate.engine.spi.PersistenceContext) line: 48	

		return new MutableEntityEntry(
				status,
				loadedState,
				rowId,
				id,
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched,
				persistenceContext
		);
/s,
org.hibernate.engine.internal.MutableEntityEntry(org.hibernate.engine.internal.AbstractEntityEntry).<init>(org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean, org.hibernate.engine.spi.PersistenceContext) line: 128	

		setCompressedValue( EnumState.STATUS, status ); / sets bits in compressedState
		// not useful strictly speaking but more explicit
		setCompressedValue( EnumState.PREVIOUS_STATUS, null );
		// only retain loaded state if the status is not Status.READ_ONLY
		if ( status != Status.READ_ONLY ) {
			this.loadedState = loadedState;
		}
		this.id=id;
		this.rowId=rowId;
		setCompressedValue( BooleanState.EXISTS_IN_DATABASE, existsInDatabase ); / sets bits in compressedState
		this.version=version;
		setCompressedValue( EnumState.LOCK_MODE, lockMode );
		setCompressedValue( BooleanState.IS_BEING_REPLICATED, disableVersionIncrement );
		setCompressedValue( BooleanState.LOADED_WITH_LAZY_PROPERTIES_UNFETCHED, lazyPropertiesAreUnfetched );
		this.persister=persister;
		this.persistenceContext = persistenceContext;
/t,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 542	
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/d,
e	org.hibernate.engine.internal.MutableEntityEntry  (id=21365)	
	compressedState	102	
	id	java.lang.Long  (id=21324)	
	loadedState	null	

		entityEntryContext.addEntityEntry( entity, e );
/s,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 77	
/=
	/**
	 * Adds the entity and entry to this context, associating them together
	 *
	 * @param entity The entity
	 * @param entityEntry The entry
	 */
	public void addEntityEntry(Object entity, EntityEntry entityEntry) {
		// IMPORTANT!!!!!
		//		add is called more than once of some entities.  In such cases the first
		//		call is simply setting up a "marker" to avoid infinite looping from reentrancy

		// any addition (even the double one described above) should invalidate the cross-ref array
		dirty = true;

		// Determine the appropriate ManagedEntity instance to use based on whether the entity is enhanced or not.
		// Throw an exception if entity is a mutable ManagedEntity that is associated with a different
		// PersistenceContext.
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 176	
		else {
			return nonEnhancedEntityXref != null		/ nonEnhancedEntityXref==null,
					? nonEnhancedEntityXref.get( entity )
					: null;
		}
/t,
org.hibernate.engine.internal.EntityEntryContext.addEntityEntry(java.lang.Object, org.hibernate.engine.spi.EntityEntry) line: 77	
		ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
null
			else {
				if ( nonEnhancedEntityXref == null ) {
					nonEnhancedEntityXref = new IdentityHashMap<Object, ManagedEntity>();
				}
				managedEntity = new ManagedEntityImpl( entity );
				nonEnhancedEntityXref.put( entity, managedEntity );
				
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
	entityEntry	null	
	entityInstance	domain.Language  (id=19770)	
	next	null	
	previous	null	


		// associate the EntityEntry with the entity
		managedEntity.$$_hibernate_setEntityEntry( entityEntry );
		
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=21365) 	/ entityEntry is WH wat de db ingaat,	
		id	java.lang.Long  (id=21324)	160			
		loadedState	null	
	entityInstance	domain.Language  (id=19770)	
	next	null	
	previous	null	

this	org.hibernate.engine.internal.EntityEntryContext  (id=21400)	
	count	1	
	dirty	true	
	head	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
	nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=21417)
{Language name: Java=org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl@34f3192b}
/=
		table
			[56]	domain.Language  (id=19770)	
			[57]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
	tail	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)
/t,
		// Put a placeholder in entries, so we don't recurse back and try to save() the
		// same object again. QUESTION: should this be done before onSave() is called?
		// likewise, should it be done before onUpdate()?
		EntityEntry original = source.getPersistenceContext().addEntry(
				entity,
				Status.SAVING,
				null,
				null,
				id,
				null,
				LockMode.WRITE,
				useIdentityColumn,
				persister,
				false,
				false
		);
/d,
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer.getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 237	
		else {
			return super.getPropertyValuesToInsert( entity, mergeMap, session );
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).getPropertyValuesToInsert(java.lang.Object, java.util.Map, org.hibernate.engine.spi.SessionImplementor) line: 522	

		final int span = entityMetamodel.getPropertySpan();
2
		final Object[] result = new Object[span];

		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
		}
		return result;
[Java, 0]
/////////////////////////
/ H. heeft dus met getters de data opgehaald uit entity die de db ingaan	,
/ Later worden deze WH set in entityEntry TODO	,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 252	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/d,
[Java,0]		
		Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@4707878c, org.hibernate.type.IntegerType@75e42953]
/=
persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=19827)	
	entityMetamodel	org.hibernate.tuple.entity.EntityMetamodel  (id=19828)	
		propertyNames	java.lang.String[2]  (id=21850)	
			[0]	"name" (id=22020)	
			[1]	"version" (id=22021)	
		propertyTypes	org.hibernate.type.Type[2]  (id=21843)	
			[0]	org.hibernate.type.StringType  (id=21844)	
				javaTypeDescriptor	org.hibernate.type.descriptor.java.StringTypeDescriptor  (id=21895)	
				sqlTypeDescriptor	org.hibernate.type.descriptor.sql.VarcharTypeDescriptor  (id=21896)	
				sqlTypes	(id=21897)	[12]
			[1]	org.hibernate.type.IntegerType  (id=21845)	
				javaTypeDescriptor	org.hibernate.type.descriptor.java.IntegerTypeDescriptor  (id=21945)	
				sqlTypeDescriptor	org.hibernate.type.descriptor.sql.IntegerTypeDescriptor  (id=21949)	
				sqlTypes	(id=21954)	[4]
/ via entityMetamodel=EntityMetamodel(domain.Language:[Attribute(name=name, type=string [non-identifier]),Attribute(name=version, type=integer [non-identifier])])

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/s,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).addInsertAction(java.lang.Object[], java.io.Serializable, java.lang.Object, org.hibernate.persister.entity.EntityPersister, boolean, org.hibernate.event.spi.EventSource, boolean) line: 321	
		else {
			Object version = Versioning.getVersion( values, persister );
Integer 0
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
insert	org.hibernate.action.internal.EntityInsertAction  (id=22051)	
	entityName	"domain.Language" (id=19821)	
	id	java.lang.Long  (id=21324)	
	instance	domain.Language  (id=19770)	
	state	java.lang.Object[2]  (id=21837)		/ was met getters opgehaald uit entity,
		[0]	"Java" (id=19819)	
		[1]	java.lang.Integer  (id=21836)	
	version	java.lang.Integer  (id=21836)	

			source.getActionQueue().addAction( insert );
/s,
org.hibernate.engine.spi.ActionQueue.addInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 245	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
		if ( nonNullableTransientDependencies == null ) {
			LOG.tracev( "Adding insert with no non-nullable, transient entities: [{0}]", insert );
			addResolvedEntityInsertAction( insert );
/s,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 269	
		else {
			LOG.trace( "Adding resolved non-early insert action." );
			addAction( AbstractEntityInsertAction.class, insert );
/s,
org.hibernate.engine.spi.ActionQueue.addAction(java.lang.Class<T>, T) line: 289	
/=
	@SuppressWarnings("unchecked")
	private <T extends Executable & Comparable & Serializable> void addAction(Class<T> executableClass, T action) {
		EXECUTABLE_LISTS_MAP.get( executableClass ).getOrInit( this ).add( action );
		
instance	org.hibernate.engine.spi.ActionQueue  (id=22090)	
	EXECUTABLE_LISTS_MAP	java.util.LinkedHashMap<K,V>  (id=22092)
		{class org.hibernate.action.internal.OrphanRemovalAction=org.hibernate.engine.spi.ActionQueue$1@23bfd90f, class org.hibernate.action.internal.AbstractEntityInsertAction=org.hibernate.engine.spi.ActionQueue$2@7c7587b6, class org.hibernate.action.internal.EntityUpdateAction=org.hibernate.engine.spi.ActionQueue$3@74f4555c, class org.hibernate.action.internal.QueuedOperationCollectionAction=org.hibernate.engine.spi.ActionQueue$4@45048d3e, class org.hibernate.action.internal.CollectionRemoveAction=org.hibernate.engine.spi.ActionQueue$5@18ae5330, class org.hibernate.action.internal.CollectionUpdateAction=org.hibernate.engine.spi.ActionQueue$6@48363fa4, class org.hibernate.action.internal.CollectionRecreateAction=org.hibernate.engine.spi.ActionQueue$7@1e3edd4b, class org.hibernate.action.internal.EntityDeleteAction=org.hibernate.engine.spi.ActionQueue$8@7f32cecf}	
	afterTransactionProcesses	null	
	beforeTransactionProcesses	null	
	collectionCreations	null	
	collectionQueuedOps	null	
	collectionRemovals	null	
	collectionUpdates	null	
	deletions	null	
	insertions	null	
	orphanRemovals	null	
	updates	null	
/s,
org.hibernate.engine.spi.ActionQueue$2(org.hibernate.engine.spi.ActionQueue$ListProvider<T>).getOrInit(org.hibernate.engine.spi.ActionQueue) line: 1124	
/=
	private static abstract class ListProvider<T extends Executable & Comparable & Serializable> {
		abstract ExecutableList<T> get(ActionQueue instance);
		abstract ExecutableList<T> init(ActionQueue instance);
		ExecutableList<T> getOrInit( ActionQueue instance ) {
			ExecutableList<T> list = get( instance );
			if ( list == null ) {
/j,
				list = init( instance );
			}
			return list;
		}
/s,
org.hibernate.engine.spi.ActionQueue$2.get(org.hibernate.engine.spi.ActionQueue) line: 117	
/=
		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;
					}
					ExecutableList<AbstractEntityInsertAction> init(ActionQueue instance) {
						if ( instance.isOrderInsertsEnabled() ) {
/n,
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									new InsertActionSorter()
							);
						}
						else {
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									false
							);
						}
					}
				}
		);
/s,
org.hibernate.engine.spi.ExecutableList<E>.<init>(boolean) line: 86	
		this( INIT_QUEUE_LIST_SIZE, requiresSorting );
/t,
/s,
org.hibernate.engine.spi.ExecutableList<E>.add(E) line: 211	
		boolean added = executables.add( executable );
executable=EntityInsertAction[domain.Language#160]
/t,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 279	
		else {
			LOG.trace( "Adding resolved non-early insert action." );
			addAction( AbstractEntityInsertAction.class, insert );
/d,
this	org.hibernate.engine.spi.ActionQueue  (id=22090)	
	insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=22165)	
		executables	java.util.ArrayList<E>  (id=22166)	[EntityInsertAction[domain.Language#160]]

		}
		insert.makeEntityManaged();

/ Intermezzo

/ per conn is er een persistenceContext,

/s,
repository.LanguageDao.insertInTx() line: 86	
		Language l=new Language();
		l.setName("Java");
		em.persist(l); 
		l=new Language();
		l.setName("Java");
		em1.persist(l);
		...

this	repository.LanguageDao  (id=19752)	
	em	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=19768)	
		emf	org.hibernate.jpa.internal.EntityManagerFactoryImpl  (id=22269)	
		puScopedName	"test.war#arquillian-forge4-persistence-unit" (id=22270)	
		transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=19736)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20414)	
	em1	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=19771)	
		emf	org.hibernate.jpa.internal.EntityManagerFactoryImpl  (id=19777)	
		puScopedName	"test.war#arquillian-forge4-persistence-unit-1" (id=19772)	
		transactionManager	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate  (id=19736)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20414)	
			interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22272)	
				[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=22276)	
					key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19737)	
					value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
						preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
							[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22359)	
								manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19769)	
									session	org.hibernate.internal.SessionImpl  (id=22407)	
								scopedPuName	"test.war#arquillian-forge4-persistence-unit" (id=22270)	
							[3]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22361)	
								manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19807)	
									session	org.hibernate.internal.SessionImpl  (id=19808)	
								scopedPuName	"test.war#arquillian-forge4-persistence-unit-1" (id=19772)	
						jcaSyncs	java.util.ArrayList<E>  (id=22354)	
							[0]	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=22401)	
								enlisted	java.util.ArrayList<E>  (id=22485)	
									[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22488)	
										this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22492)	
											managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
												currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	
												xaConnection	org.postgresql.xa.PGXAConnection  (id=22575)	
													con	org.postgresql.jdbc42.Jdbc42Connection  (id=22585)	
														protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	
															pgStream	org.postgresql.core.PGStream  (id=22623)
																connection	java.net.Socket  (id=24944)	
																pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=24949)	
																pg_output	java.io.BufferedOutputStream  (id=24950)			
									[1]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22489)	
										this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22635)	
											managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20421)	
												currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22642)	
												xaConnection	org.h2.jdbcx.JdbcXAConnection  (id=22651)	
													currentTransaction	com.arjuna.ats.jta.xa.XidImple  (id=22642)	
													physicalConn	org.h2.jdbc.JdbcConnection  (id=22658)
														transferList	java.util.ArrayList<E>  (id=20435)	
															[0]	org.h2.value.Transfer  (id=20436)	
																in	java.io.DataInputStream  (id=20567)	
																out	java.io.DataOutputStream  (id=20568)	
																session	org.h2.engine.SessionRemote  (id=20430)	
																socket	java.net.Socket  (id=20569)	



/ Einde Intermezzo
	
/s,
org.hibernate.action.internal.EntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction).makeEntityManaged() line: 124	
		nullifyTransientReferencesIfNotAlready();
		final Object version = Versioning.getVersion( getState(), getPersister() );
		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),	/j,
				getState(), 	[Java,0]
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);

this	org.hibernate.action.internal.EntityInsertAction  (id=22051)	
	id	java.lang.Long  (id=21324)	
	instance	domain.Language  (id=19770)	
	state	java.lang.Object[2]  (id=21837)	/ met getters uit instance gehaald	,
/s,
org.hibernate.action.internal.EntityInsertAction.getEntityKey() line: 70	
		return getSession().generateEntityKey( getId(), getPersister() );
/s,
			return new EntityKey( id, persister );
/t,
/t,
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntity(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], org.hibernate.engine.spi.EntityKey, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 463	
		addEntity( entityKey, entity );
/s,
			entitiesByKey.put( key, entity );
/t,
		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(),
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.addEntry(java.lang.Object, org.hibernate.engine.spi.Status, java.lang.Object[], java.lang.Object, java.io.Serializable, java.lang.Object, org.hibernate.LockMode, boolean, org.hibernate.persister.entity.EntityPersister, boolean, boolean) line: 509	
		if (persister.getEntityEntryFactory() instanceof MutableEntityEntryFactory) {
			//noinspection RedundantCast
			e = ( (MutableEntityEntryFactory) persister.getEntityEntryFactory() ).createEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					this
			);
		}
/s,
			return new MutableEntityEntry(
					status,
					loadedState,
					rowId,
					id,
					version,
					lockMode,
					existsInDatabase,
					persister,
					disableVersionIncrement,
					lazyPropertiesAreUnfetched,
					persistenceContext
			);
/t,
		entityEntryContext.addEntityEntry( entity, e );

this	org.hibernate.engine.internal.StatefulPersistenceContext  (id=19822)	
	entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=21400)	
		head	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
		nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=21417)	
			table	java.lang.Object[64]  (id=21537)	
				[56]	domain.Language  (id=19770)	
				[57]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=24984)	
					entityInstance	domain.Language  (id=19770)	
					next	null	
					previous	null	
		tail	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
/t,
org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(org.hibernate.action.internal.AbstractEntityInsertAction) line: 285	
			addAction( AbstractEntityInsertAction.class, insert );
		}
		insert.makeEntityManaged();
/d,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).addInsertAction(java.lang.Object[], java.io.Serializable, java.lang.Object, org.hibernate.persister.entity.EntityPersister, boolean, org.hibernate.event.spi.EventSource, boolean) line: 326	
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
			source.getActionQueue().addAction( insert );
/d,
			return insert;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 278	

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/d,
		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getEntry(java.lang.Object) line: 433	
		return entityEntryContext.getEntityEntry( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 224	
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/s,
org.hibernate.engine.internal.EntityEntryContext.getAssociatedManagedEntity(java.lang.Object) line: 177	
		else {
			return nonEnhancedEntityXref != null
					? nonEnhancedEntityXref.get( entity )
					: null;
		}
/t,
org.hibernate.engine.internal.EntityEntryContext.getEntityEntry(java.lang.Object) line: 227	
		final ManagedEntity managedEntity = getAssociatedManagedEntity( entity );
/d,
managedEntity	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=21418)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=24984)	
	entityInstance	domain.Language  (id=19770)	
	next	null	
	previous	null	

		// and get/return the EntityEntry from the ManagedEntry
		return managedEntity == null
				? null
				: managedEntity.$$_hibernate_getEntityEntry();
/s,
					return entityEntry;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.AbstractSaveEventListener).performSaveOrReplicate(java.lang.Object, org.hibernate.engine.spi.EntityKey, org.hibernate.persister.entity.EntityPersister, boolean, java.lang.Object, org.hibernate.event.spi.EventSource, boolean) line: 296	

		EntityEntry newEntry = source.getPersistenceContext().getEntry( entity );
/d,
		if ( newEntry != original ) {
			EntityEntryExtraState extraState = newEntry.getExtraState( EntityEntryExtraState.class );
			if ( extraState == null ) {
/j,
				newEntry.addExtraState( original.getExtraState( EntityEntryExtraState.class ) );
/ TODO
			}
		}
original	org.hibernate.engine.internal.MutableEntityEntry  (id=21365)	
	compressedState	102	
	id	java.lang.Long  (id=21324)	
	loadedState	null	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=19822)	
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=19827)	
newEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=24984)	
	compressedState	22	
	id	java.lang.Long  (id=21324)	
	loadedState	java.lang.Object[2]  (id=21837)	
	persistenceContext	org.hibernate.engine.internal.StatefulPersistenceContext  (id=19822)	
	persister	org.hibernate.persister.entity.SingleTableEntityPersister  (id=19827)	

		return id;
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).entityIsTransient(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 191	
			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
/d,
/t,
org.hibernate.jpa.event.internal.core.JpaPersistEventListener(org.hibernate.event.internal.DefaultPersistEventListener).onPersist(org.hibernate.event.spi.PersistEvent, java.util.Map) line: 133	
			case TRANSIENT: {
				entityIsTransient( event, createCache );
				break;
			}
/d,
org.hibernate.jpa.internal.EntityManagerImpl(org.hibernate.jpa.spi.AbstractEntityManagerImpl).persist(java.lang.Object) line: 1153	
		try {
			internalGetSession().persist( entity );
		}
/d,
repository.LanguageDao.insertInTx() line: 87	
		l=new Language();
		l.setName("Java");
		em1.persist(l);
/d,
		l=new Language();
		l.setName("Go");
		em.persist(l);
		l=new Language();
		l.setName("Go");
		em1.persist(l);
		l=new Language();
		l.setName("C++");
		em.persist(l);
		l=new Language();
		l.setName("C++");
		em1.persist(l);
		
/ Intermezzo


this	repository.LanguageDao  (id=19752)	
	em	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=19768)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20414)	
			interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22272)	
				[0]	java.util.concurrent.ConcurrentHashMap$MapEntry<K,V>  (id=25265)	
					key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19737)	
					value	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
						preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
							[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22359)	
								manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19769)	
									session	org.hibernate.internal.SessionImpl  (id=22407)	
										actionQueue	org.hibernate.engine.spi.ActionQueue  (id=22412)	
											insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=25291)	
													[0]	org.hibernate.action.internal.EntityInsertAction  (id=25294)	
													[1]	org.hibernate.action.internal.EntityInsertAction  (id=25295)	
													[2]	org.hibernate.action.internal.EntityInsertAction  (id=25296)	
							[3]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22361)	
								manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19807)	
									session	org.hibernate.internal.SessionImpl  (id=19808)	
										actionQueue	org.hibernate.engine.spi.ActionQueue  (id=22090)	
											insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=22165)	
												executables	java.util.ArrayList<E>  (id=22166)	
													[0]	org.hibernate.action.internal.EntityInsertAction  (id=22051)	
													[1]	org.hibernate.action.internal.EntityInsertAction  (id=25280)	
													[2]	org.hibernate.action.internal.EntityInsertAction  (id=25281)	
	em1	org.jboss.as.jpa.container.TransactionScopedEntityManager  (id=19771)	
		transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20414)	
		
/ Einde Intermezzo

/ Intermezzo

/ WH moeten we naar (*) terug,
/ we set debug line op (*) en geven Enter met breakpoints aan,

Thread [default task-100] (Suspended)	
	repository.LanguageDao.insertInTx() line: 99	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.as.ee.component.ManagedReferenceMethodInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.doMethodInterception(javax.interceptor.InvocationContext, javax.enterprise.inject.spi.InterceptionType, org.jboss.as.weld.ejb.WeldInterceptorInstances, org.jboss.weld.ejb.spi.InterceptorBindings) line: 82	
	org.jboss.as.weld.ejb.Jsr299BindingsInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 93	
	org.jboss.as.ee.component.interceptors.UserInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 63	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.ExecutionTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 43	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.jpa.interceptor.SBInvocationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext$Invocation.proceed() line: 437	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor(org.jboss.weld.ejb.AbstractEJBRequestScopeActivationInterceptor).aroundInvoke(javax.interceptor.InvocationContext) line: 64	
	org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 83	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.concurrent.ConcurrentContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 45	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InitialInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 21	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 52	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.pool.PooledInstanceInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 51	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 275
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();		<- (*)
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
            }
        }
        throw new RuntimeException("UNREACHABLE");
/cb,		
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view9.insertInTx() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	


/ Einde Intermezzo
	
/t,
    /**
     * The <code>endTransaction</code> method ends a transaction and
     * translates any exceptions into
     * TransactionRolledBack[Local]Exception or SystemException.
     *
org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	
        for (int i = 0; i < MAX_RETRIES; i++) {
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();	/ (*)
/d,
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
/s,
/ TODO INTERESSANT al de exceptions,
org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 82	
            final int txStatus = tx.getStatus();
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 88	
/=
    /**
     * Commit the current transaction and disassociate from the thread.
/ TODO thread
     */
    public void commit()
        throws RollbackException, HeuristicMixedException, HeuristicRollbackException,
        SecurityException, IllegalStateException, SystemException
    {
        notifyAssociationListeners(getTransaction(), EnumSet.of(EventType.DISASSOCIATING));
/ NIETS nu,
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).notifyAssociationListeners(javax.transaction.Transaction, java.util.EnumSet<org.jboss.tm.listener.EventType>) line: 234	
/=
    // notify any listeners for this transaction that there has been an event
    private void notifyAssociationListeners(Transaction transaction, EnumSet<EventType> reasons)
    {
        if (transaction != null) {
            Collection<TransactionListener> listeners = getListeners(transaction, false);
[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@4e1bf99, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@2b6c899]
            TransactionEvent event = new TransactionEvent(transaction, reasons); / reasons=[DISASSOCIATING]

            if (listeners != null) {
                for (TransactionListener s : listeners)
                    s.onEvent(event);
            }
/s,
org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization.onEvent(org.jboss.tm.listener.TransactionEvent) line: 198	
            // set to true if application thread is no longer associated with JTA transaction
            // (EventType.DISASSOCIATING in progress).  We are tracking when the application thread
            // is no longer associated with the transaction, as that indicates that it is safe to
            // close the entity manager (since the application is no longer using the entity manager).
            transactionDisassociatedFromApplication = transactionEvent.getTypes().contains(EventType.DISASSOCIATING);
true
            safeCloseEntityManager();
/s,
org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization.safeCloseEntityManager() line: 176	
/=
        /**
         * After the JTA transaction is ended (Synchronization.afterCompletion has been called) and
         * the JTA transaction is no longer associated with application thread (application thread called
         * transaction.rollback/commit/suspend), the entity manager can safely be closed.
         */
        private void safeCloseEntityManager() {
            if ( afterCompletionCalled == true && transactionDisassociatedFromApplication == true) {
/n,
afterCompletionCalled==false
                if (manager != null) {
                    try {
						...
                        manager.close();
                    ...
                    manager = null;
                }
            }
        }
/t,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
        notifyAssociationListeners(getTransaction(), EnumSet.of(EventType.DISASSOCIATING));
/d,
        transactionManager.commit() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 115	
	/**
	 * We will never throw a HeuristicRollbackException because if we get a
	 * HeuristicRollback from a resource, and can successfully rollback the
	 * other resources, this is then the same as having simply been forced to
	 * rollback the transaction during phase 1. The OTS interfaces do not allow
	 * a differentiation.
	 */

	public void commit() throws javax.transaction.RollbackException,
			javax.transaction.HeuristicMixedException,
			javax.transaction.HeuristicRollbackException,
			java.lang.SecurityException, java.lang.IllegalStateException,
			javax.transaction.SystemException
	{
		...

		TransactionImple theTransaction = TransactionImple.getTransaction();

		...

		theTransaction.commitAndDisassociate();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1177	
/=
	protected void commitAndDisassociate()
			throws javax.transaction.RollbackException,
			javax.transaction.HeuristicMixedException,
			javax.transaction.HeuristicRollbackException,
			java.lang.SecurityException, javax.transaction.SystemException,
			java.lang.IllegalStateException
	{
				switch (_theTransaction.commit(true))
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
/=
	/**
	 * Commit the transaction. The report_heuristics parameter can be used to
	 * determine whether or not heuristic outcomes are reported.
	 *
	 * If the transaction has already terminated, or has not begun, then an
	 * appropriate error code will be returned.
	 *
	 * @return <code>ActionStatus</code> indicating outcome.
	 */

	public int commit (boolean report_heuristics)	/ true
	{
		int status = super.end(report_heuristics);
/s,
/ TODO INTERESSANT central method,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 83	
        if(status() != ActionStatus.ABORT_ONLY || TxControl.isBeforeCompletionWhenRollbackOnly())
        {
            canEnd = beforeCompletion();
        }
		if (canEnd)
		{
			outcome = super.End(report_heuristics);
		}
		else
			outcome = super.Abort();

		afterCompletion(outcome, report_heuristics);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 310	
/=
	/**
	 * Drive beforeCompletion participants.
	 * 
	 * @return true if successful, false otherwise.
	 */
	
	protected boolean beforeCompletion ()
	{
                } else {
	                /*
	                 * We must always call afterCompletion() methods, so just catch (and
	                 * log) any exceptions/errors from beforeCompletion() methods.
	                 *
	                 * If one of the Syncs throws an error the Record wrapper returns false
	                 * and we will rollback. Hence we don't then bother to call beforeCompletion
	                 * on the remaining records (it's not done for rollabcks anyhow).
	                 *
	                 * Since Synchronizations may register other Synchronizations, we can't simply
	                 * iterate the collection. Instead we work from an ordered copy, which we periodically
	                 * check for freshness. The addSynchronization method uses _currentRecord to disallow
	                 * adding records in the part of the array we have already traversed, thus all
	                 * Synchronization will be called and the (jta only) rules on ordering of interposed
	                 * Synchronization will be respected.
	                 */
					 
this	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction  (id=19739)	
	_synchs	java.util.TreeSet<E>  (id=25974)	
		m	java.util.TreeMap<K,V>  (id=25977)	
			root	java.util.TreeMap$Entry<K,V>  (id=25986)	
				key	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=25987)	
					_isInterposed	true	
					_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
						jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22272)	
						jcaSyncs	java.util.ArrayList<E>  (id=22354)	
						preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
						tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19737)
					_theUid	com.arjuna.ats.arjuna.common.Uid  (id=25991)							
				value	java.lang.Object  (id=25976)	
			size	1	
			
	                int lastIndexProcessed = -1;
	                SynchronizationRecord[] copiedSynchs;
	                // need to guard against synchs being added while we are performing beforeCompletion processing
	                synchronized (_synchs) {
	                    copiedSynchs = (SynchronizationRecord[])_synchs.toArray(new SynchronizationRecord[] {});
	                }

copiedSynchs	com.arjuna.ats.arjuna.coordinator.SynchronizationRecord[1]  (id=26191)	
	[0]	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple  (id=25987)	
		_isInterposed	true	
		_theSynch	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
			jcaOrderedLastSynchronizations	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22272)	
			jcaSyncs	java.util.ArrayList<E>  (id=22354)	
			preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
			tx	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19737)	
		_theUid	com.arjuna.ats.arjuna.common.Uid  (id=25991)	

	                while( (lastIndexProcessed < _synchs.size()-1) && !problem) {
/j, -1<0
	                    synchronized (_synchs) {
	                        // if new Synchronization have been registered, refresh our copy of the collection:
	                        if(copiedSynchs.length != _synchs.size()) {
/n,
	                            copiedSynchs = (SynchronizationRecord[])_synchs.toArray(new SynchronizationRecord[] {});
	                        }
	                    }
	                    lastIndexProcessed = lastIndexProcessed+1;
0
	                    _currentRecord = copiedSynchs[lastIndexProcessed];

	                    try
	                    {
	                        problem = !_currentRecord.beforeCompletion();
/s,
com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 70	
	if (_theSynch != null)
	{
		_theSynch.beforeCompletion();
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 107	
/=
    /**
     * Exceptions from Synchronizations that are registered with this TSR are not trapped for before completion. This is because
     * an error in a Sync here should result in the transaction rolling back.
     *
     * You can see that in effect in these classes:
     * https://github.com/jbosstm/narayana/blob/5.0.4.Final/ArjunaCore/arjuna/classes
     * /com/arjuna/ats/arjuna/coordinator/TwoPhaseCoordinator.java#L91
     * https://github.com/jbosstm/narayana/blob/5.0.4.Final/ArjunaJTA
     * /jta/classes/com/arjuna/ats/internal/jta/resources/arjunacore/SynchronizationImple.java#L76
     */
    @Override
    public void beforeCompletion() {			
        // This is needed to guard against syncs being registered during the run, otherwise we could have used an iterator
        int lastIndexProcessed = 0;
		
this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
	preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
		elementData	java.lang.Object[10]  (id=26046)	
			[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=22358)	
			[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22359)	
			[2]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=22360)	
			[3]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22361)	

        while ((lastIndexProcessed < preJcaSyncs.size())) {	/ <4
/j,
            Synchronization preJcaSync = preJcaSyncs.get(lastIndexProcessed);
            ...
            preJcaSync.beforeCompletion();
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 35	
/=
/**
 * The JTA {@link javax.transaction.Synchronization} Hibernate registers when needed for JTA callbacks.
 * <p/>
 * Note that we split the notion of the registered Synchronization and the processing of the Synchronization callbacks
 * mainly to account for "separation of concerns", but also so that the transaction engine does not have to hold
 * reference to the actual Synchronization that gets registered with the JTA system.
 *
 * @author Steve Ebersole
 */
public class RegisteredSynchronization implements Synchronization {
	@Override
	public void beforeCompletion() {

		synchronizationCallbackCoordinator.beforeCompletion();
	}
/s,
org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 42	
		if ( !target.isActive() ) {
			return;
		}
		target.beforeCompletion();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
		try {
			transactionCoordinatorOwner.beforeTransactionCompletion();
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
		owner.beforeTransactionCompletion();
/s,
org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2338	
		flushBeforeTransactionCompletion();
		actionQueue.beforeTransactionCompletion();
		try {
			interceptor.beforeTransactionCompletion( currentHibernateTransaction );
		}
/s,
org.hibernate.internal.SessionImpl.isTransactionFlushable() line: 2975	

		boolean flush = isTransactionFlushable() && managedFlushChecker.shouldDoManagedFlush( this );
		try {
			if ( flush ) {
				managedFlush();
			}
		}
/s,
org.hibernate.internal.SessionImpl.isTransactionFlushable() line: 2975	
		if ( currentHibernateTransaction == null ) {
/n,
			// assume it is flushable - CMT, auto-commit, etc
			return true;
		}
		final TransactionStatus status = currentHibernateTransaction.getStatus();
		return status == TransactionStatus.ACTIVE || status == TransactionStatus.COMMITTING;
/s,
org.hibernate.engine.transaction.internal.TransactionImpl.getStatus() line: 99	
		return transactionDriverControl.getStatus();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl$TransactionDriverControlImpl.getStatus() line: 421	
			return jtaTransactionAdapter.getStatus();
/s,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.getStatus() line: 90	
			return StatusTranslator.translate( transactionManager.getStatus() );
/s,
com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).getStatus() line: 99	
        return transactionManager.getStatus() ;
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).getStatus() line: 164	
		TransactionImple theTransaction = TransactionImple.getTransaction();
		...
		else
			return theTransaction.getStatus();
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTransaction() line: 1057	
		TransactionImple tx = null;

		final BasicAction current = BasicAction.Current();
BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:a3 status: ActionStatus.RUNNING
		if (current != null)
		{
			final Uid txid = current.get_uid();

			tx = (TransactionImple) _transactions.get(txid);
			...

		return tx;
...
/t,
org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionAdapterTransactionManagerImpl.getStatus() line: 90	
		try {
			return StatusTranslator.translate( transactionManager.getStatus() );
/pd,
/s,
org.hibernate.resource.transaction.backend.jta.internal.StatusTranslator.translate(int) line: 23	
		TransactionStatus transactionStatus = null;
		switch ( status ) {
			case Status.STATUS_ACTIVE:
				transactionStatus = TransactionStatus.ACTIVE;
				break;
/t,
org.hibernate.internal.SessionImpl.isTransactionFlushable() line: 2980	
		if ( currentHibernateTransaction == null ) {
			// assume it is flushable - CMT, auto-commit, etc
			return true;
		}
		final TransactionStatus status = currentHibernateTransaction.getStatus();
/d,
		return status == TransactionStatus.ACTIVE || status == TransactionStatus.COMMITTING;
/j,
/t,
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2960	
		boolean flush = isTransactionFlushable() && managedFlushChecker.shouldDoManagedFlush( this );
/pd,
		try {
			if ( flush ) {
				managedFlush();
			}
		}
/s,
org.hibernate.jpa.internal.EntityManagerImpl$ManagedFlushCheckerImpl.shouldDoManagedFlush(org.hibernate.internal.SessionImpl) line: 262	
/=
	private class ManagedFlushCheckerImpl implements ManagedFlushChecker {
		@Override
		public boolean shouldDoManagedFlush(SessionImpl session) {
			return !session.isClosed()
					&& !isManualFlushMode( session.getFlushMode() );	/ AUTO
/t,
org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2960	
		boolean flush = isTransactionFlushable() && managedFlushChecker.shouldDoManagedFlush( this );
/d,
true
		try {
			if ( flush ) {
				managedFlush();
			}
		}
/s,
org.hibernate.internal.SessionImpl.managedFlush() line: 460	
		flush();
/s,
org.hibernate.internal.SessionImpl.flush() line: 1282	
		FlushEvent flushEvent = new FlushEvent( this );
		for ( FlushEventListener listener : listeners( EventType.FLUSH ) ) {
org.hibernate.jpa.event.internal.core.JpaFlushEventListener@52dba76d
			listener.onFlush( flushEvent );
		}			
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 29	
/=
/**
 * Defines the default flush event listeners used by hibernate for 
 * flushing session state in response to generated flush events.
 *
 * @author Steve Ebersole
 */
public class DefaultFlushEventListener extends AbstractFlushingEventListener implements FlushEventListener {

	/** Handle the given flush event.
	 *
	 * @param event The flush event to be handled.
	 * @throws HibernateException
	 */
	public void onFlush(FlushEvent event) throws HibernateException {
		final EventSource source = event.getSession();
		final PersistenceContext persistenceContext = source.getPersistenceContext();

		if ( persistenceContext.getNumberOfManagedEntities() > 0 ||
				persistenceContext.getCollectionEntries().size() > 0 ) {

			try {
				source.getEventListenerManager().flushStart();

				flushEverythingToExecutions( event );
				performExecutions( source );
				postFlush( source );
			}
			finally {
				source.getEventListenerManager().flushEnd(
						event.getNumberOfEntitiesProcessed(),
						event.getNumberOfCollectionsProcessed()
				);
			}

			postPostFlush( source );
                          
/ Intermezzo

/ we zijn in,
/s,
org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
        while ((lastIndexProcessed < preJcaSyncs.size())) {
            Synchronization preJcaSync = preJcaSyncs.get(lastIndexProcessed);
            preJcaSync.beforeCompletion();
/ er zijn er 4	,
this	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
	preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
		elementData	java.lang.Object[10]  (id=26046)	
			[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=22358)	
				synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=22364)	
					target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=22445)	
						transactionCoordinatorOwner	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=22428)	
							owner	org.hibernate.internal.SessionImpl  (id=22407)	
			[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22359)	
				manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19769)	
					session	org.hibernate.internal.SessionImpl  (id=22407)	
				scopedPuName	"test.war#arquillian-forge4-persistence-unit" (id=22270)	
			[2]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=22360)	
			[3]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22361)	

/ bij [0] zie je het pad dat we gelopen hebben nu, bij [1] zie je dat het om de session met pg gaat, 
/ maar kunnen we aan de session zelf niet zien dat het om pg gaat?
/ TODO

/ Einde Intermezzo											
											
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.getNumberOfManagedEntities() line: 1016	
		return entityEntryContext.getNumberOfManagedEntities();
/s,
			return count
3

this	org.hibernate.engine.internal.StatefulPersistenceContext  (id=22435)	
	entityEntryContext	org.hibernate.engine.internal.EntityEntryContext  (id=22754)	
		count	3	
		nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=27068)	
			size	3	
				[16]	domain.Language  (id=25249)	
				[17]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27327)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27361)	
						id	java.lang.Long  (id=27352)	
						loadedState	java.lang.Object[2]  (id=27377)	
				[20]	domain.Language  (id=25255)	
				[21]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27070)	
				[46]	domain.Language  (id=19767)	
				[47]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27067)	
	
/t,
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 67	
/=
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Pre-flushing section
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	/**
	 * Coordinates the processing necessary to get things ready for executions
	 * as db calls by preping the session caches and moving the appropriate
	 * entities and collections to their respective execution queues.
	 *
	 * @param event The flush event.
	 * @throws HibernateException Error flushing caches to execution queues.
	 */
	protected void flushEverythingToExecutions(FlushEvent event) throws HibernateException {
		prepareEntityFlushes( session, persistenceContext );
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).prepareEntityFlushes(org.hibernate.event.spi.EventSource, org.hibernate.engine.spi.PersistenceContext) line: 136	
		final Object anything = getAnything();
anything	java.util.IdentityHashMap<K,V>  (id=27628)	{}
		//safe from concurrent modification because of how concurrentEntries() is implemented on IdentityMap
		for ( Map.Entry<Object,EntityEntry> me : persistenceContext.reentrantSafeEntityEntries() ) {
			EntityEntry entry = (EntityEntry) me.getValue();
			Status status = entry.getStatus();
			if ( status == Status.MANAGED || status == Status.SAVING || status == Status.READ_ONLY ) {
				cascadeOnFlush( session, entry.getPersister(), me.getKey(), anything );
			}
		}						
/s,
org.hibernate.engine.internal.StatefulPersistenceContext.reentrantSafeEntityEntries() line: 1128	
		return entityEntryContext.reentrantSafeEntityEntries();
/s,
org.hibernate.engine.internal.EntityEntryContext.reentrantSafeEntityEntries() line: 325	
		if ( dirty ) {
			reentrantSafeEntries = new EntityEntryCrossRefImpl[count];
			int i = 0;
			ManagedEntity managedEntity = head;
			while ( managedEntity != null ) {
				reentrantSafeEntries[i++] = new EntityEntryCrossRefImpl(
						managedEntity.$$_hibernate_getEntityInstance(),
						managedEntity.$$_hibernate_getEntityEntry()
				);
				managedEntity = managedEntity.$$_hibernate_getNextManagedEntity();
			}
			dirty = false;
		}
		return reentrantSafeEntries;
	}
/ copies nonEnhancedEntityXref naar reentrantSafeEntries
this	org.hibernate.engine.internal.EntityEntryContext  (id=22754)	
	nonEnhancedEntityXref	java.util.IdentityHashMap<K,V>  (id=27068)	
		size	3	
		table	java.lang.Object[64]  (id=27259)	
			[16]	domain.Language  (id=25249)	
				entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27361)	
				entityInstance	domain.Language  (id=25249)	
				next	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27070)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27637)	
					entityInstance	domain.Language  (id=25255)	
					next	null	
					previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27327)	
				previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27067)	
			[20]	domain.Language  (id=25255)	
			[21]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27070)	
				entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27637)	
				entityInstance	domain.Language  (id=25255)	
				next	null	
				previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27327)	
			[46]	domain.Language  (id=19767)	
			[47]	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27067)	
				entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27636)	
				entityInstance	domain.Language  (id=19767)	
				next	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27327)	
					entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27361)	
					entityInstance	domain.Language  (id=25249)	
					next	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27070)	
					previous	org.hibernate.engine.internal.EntityEntryContext$ManagedEntityImpl  (id=27067)	
				previous	null	
	reentrantSafeEntries	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl[3]  (id=27621)	
		[0]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27622)	
			entity	domain.Language  (id=19767)	
			entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27636)	
		[1]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27623)	
			entity	domain.Language  (id=25249)	
			entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27361)	
		[2]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27624)	
			entity	domain.Language  (id=25255)	
			entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27637)	

	return reentrantSafeEntries;
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).prepareEntityFlushes(org.hibernate.event.spi.EventSource, org.hibernate.engine.spi.PersistenceContext) line: 138	
		for ( Map.Entry<Object,EntityEntry> me : persistenceContext.reentrantSafeEntityEntries() ) {
/d,
me	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27622)	
	entity	domain.Language  (id=19767)	
	entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27636)	

			EntityEntry entry = (EntityEntry) me.getValue();
/= me.entityEntry
			Status status = entry.getStatus();	/= 		return getCompressedValue( EnumState.STATUS );	/ MANAGED
			if ( status == Status.MANAGED || status == Status.SAVING || status == Status.READ_ONLY ) {
				cascadeOnFlush( session, entry.getPersister(), me.getKey(), anything );	/ me.getKey()==entity,
			}
		}
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).cascadeOnFlush(org.hibernate.event.spi.EventSource, org.hibernate.persister.entity.EntityPersister, java.lang.Object, java.lang.Object) line: 150	
		try {
			Cascade.cascade( getCascadingAction(), CascadePoint.BEFORE_FLUSH, session, persister, object, anything );
/ getCascadingAction()==return CascadingActions.PERSIST_ON_FLUSH;
...
/ TODO afmaken	,
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 83	
		prepareEntityFlushes( session, persistenceContext );
/d,
		// we could move this inside if we wanted to
		// tolerate collection initializations during
		// collection dirty checking:
		prepareCollectionFlushes( persistenceContext );
		// now, any collections that are initialized
		// inside this block do not get updated - they
		// are ignored until the next flush

		persistenceContext.setFlushing( true );
		try {
			int entityCount = flushEntities( event, persistenceContext );	
			int collectionCount = flushCollections( session, persistenceContext );

			event.setNumberOfEntitiesProcessed( entityCount );
			event.setNumberOfCollectionsProcessed( collectionCount );
		}
		finally {
			persistenceContext.setFlushing(false);
		}
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEntities(org.hibernate.event.spi.FlushEvent, org.hibernate.engine.spi.PersistenceContext) line: 189	
/=
	/**
	 * 1. detect any dirty entities
	 * 2. schedule any entity updates
	 * 3. search out any reachable collections
	 */
	private int flushEntities(final FlushEvent event, final PersistenceContext persistenceContext) throws HibernateException {

		LOG.trace( "Flushing entities and processing referenced collections" );

		final EventSource source = event.getSession();
		final Iterable<FlushEntityEventListener> flushListeners = source.getFactory().getServiceRegistry()
				.getService( EventListenerRegistry.class )
				.getEventListenerGroup( EventType.FLUSH_ENTITY )
				.listeners();
[org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener@6bcc10dc]

		// Among other things, updateReachables() will recursively load all
		// collections that are moving roles. This might cause entities to
		// be loaded.

		// So this needs to be safe from concurrent modification problems.

		final Map.Entry<Object,EntityEntry>[] entityEntries = persistenceContext.reentrantSafeEntityEntries();
entityEntries	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl[3]  (id=27621)	
	[0]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27622)	
		entity	domain.Language  (id=19767)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27636)	
			id	java.lang.Long  (id=27638)	
			loadedState	java.lang.Object[2]  (id=27639)	
	[1]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27623)	
	[2]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27624)	

		final int count = entityEntries.length;
3
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {

			// Update the status of the object and if necessary, schedule an update

			EntityEntry entry = me.getValue();
entry	org.hibernate.engine.internal.MutableEntityEntry  (id=27636)	
	id	java.lang.Long  (id=27638)	
	loadedState	java.lang.Object[2]  (id=27639)	

			Status status = entry.getStatus();
MANAGED
			if ( status != Status.LOADING && status != Status.GONE ) {
				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );	/ doet WH NIETS, want de entityEntries of de entities zijn niet dirty,
				}
			}
		}

		source.getActionQueue().sortActions();

		return count;
	}
/s,
	/**
	 * Flushes a single entity's state to the database, by scheduling
	 * an update action, if necessary
	 */
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).onFlushEntity(org.hibernate.event.spi.FlushEntityEvent) line: 126	
		final Object entity = event.getEntity();
		final EntityEntry entry = event.getEntityEntry();
		final EventSource session = event.getSession();
		final EntityPersister persister = entry.getPersister();
		final Status status = entry.getStatus();
		final Type[] types = persister.getPropertyTypes();

		final boolean mightBeDirty = entry.requiresDirtyCheck( entity );

		final Object[] values = getValues( entity, entry, mightBeDirty, session );

		event.setPropertyValues( values );

		//TODO: avoid this for non-new instances where mightBeDirty==false
		boolean substitute = wrapCollections( session, persister, types, values );

		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/n,																					/ dit zulllen we hieronder zien,
																				/ dus deze method doet WH niets,	
			substitute = scheduleUpdate( event ) || substitute;
		}

		if ( status != Status.DELETED ) {
			// now update the object .. has to be outside the main if block above (because of collections)
			if ( substitute ) {
				persister.setPropertyValues( entity, values );
			}

			// Search for collections by reachability, updating their role.
			// We don't want to touch collections reachable from a deleted object
			if ( persister.hasCollections() ) {
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
			}
		}		

		
/ Intermezzo

/ wat is het verschil tussen session.persistenceContext.entityEntryContext.reentrantSafeEntries en session.actionQueue.insertions	?
/ TODO
		
session	org.hibernate.internal.SessionImpl  (id=22407)	
	actionQueue	org.hibernate.engine.spi.ActionQueue  (id=22412)	
		insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=25291)	
			executables	java.util.ArrayList<E>  (id=25292)	
				elementData	java.lang.Object[5]  (id=28914)	
					[0]	org.hibernate.action.internal.EntityInsertAction  (id=25294)	
					[1]	org.hibernate.action.internal.EntityInsertAction  (id=25295)	
					[2]	org.hibernate.action.internal.EntityInsertAction  (id=25296)	
				size	3	
		updates	null

/ op dit moment kijken we naar 	session.persistenceContext.entityEntryContext.reentrantSafeEntries	, 	
/ see ook Intermezzo (**)
		
		
/ Einde Intermezzo


		final boolean mightBeDirty = entry.requiresDirtyCheck( entity );
true
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).getValues(java.lang.Object, org.hibernate.engine.spi.EntityEntry, boolean, org.hibernate.engine.spi.SessionImplementor) line: 175
{	
		final Object[] loadedState = entry.getLoadedState(); [Java,0]
		final Status status = entry.getStatus();	 / MANAGED
		final EntityPersister persister = entry.getPersister();

		final Object[] values;
		if ( status == Status.DELETED ) {
/n,
			//grab its state saved at deletion
			values = entry.getDeletedState();
		}
		else if ( !mightBeDirty && loadedState != null ) {
/n,
			values = loadedState;
		}
		else {
			checkId( entity, persister, entry.getId(), session );

			// grab its current state
			values = persister.getPropertyValues( entity );

			checkNaturalId( persister, entry, values, loadedState, session );
		}
		return values;
	}
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).checkId(java.lang.Object, org.hibernate.persister.entity.EntityPersister, java.io.Serializable, org.hibernate.engine.spi.SessionImplementor) line: 56

		if ( persister.canExtractIdOutOfEntity() ) {

			Serializable oid = persister.getIdentifier( object, session );
			if ( id == null ) {
				throw new AssertionFailure( "null id in " + persister.getEntityName() + " entry (don't flush the Session after an exception occurs)" );
			}
			if ( !persister.getIdentifierType().isEqual( id, oid, session.getFactory() ) ) { / org.hibernate.type.LongType@2ed4fed3	, 
/ checks if id==oid, of daarna id.equals(oid)
				throw new HibernateException(
						"identifier of an instance of " + persister.getEntityName() + " was altered from "
								+ id + " to " + oid
				);
			}
		}

	}
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).canExtractIdOutOfEntity() line: 4429	
		return hasIdentifierProperty() || hasEmbeddedCompositeIdentifier() || hasIdentifierMapper();
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).hasIdentifierProperty() line: 4219	
		return !entityMetamodel.getIdentifierProperty().isVirtual(); / in entityMetamodel heet identifierAttribute	,
true
/t,
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getIdentifier(java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 4612	
		return getEntityTuplizer().getIdentifier( entity, session );
/s,
			else {
				id = idGetter.get( entity );	
		try {
			return (Serializable) id;
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).getValues(java.lang.Object, org.hibernate.engine.spi.EntityEntry, boolean, org.hibernate.engine.spi.SessionImplementor) line: 178	
		else {
			checkId( entity, persister, entry.getId(), session );
/d,
			// grab its current state
			values = persister.getPropertyValues( entity );
...
/s,
org.hibernate.tuple.entity.PojoEntityTuplizer(org.hibernate.tuple.entity.AbstractEntityTuplizer).getPropertyValues(java.lang.Object) line: 496	
		final int span = entityMetamodel.getPropertySpan();
		final Object[] result = new Object[span];
		final EntityInstrumentationMetadata enhancementMetadata = entityMetamodel.getInstrumentationMetadata();
org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl$EntityInstrumentationMetadataImpl@5cc51bb7
		final FieldInterceptor interceptor = enhancementMetadata.isInstrumented()
/n,
				? enhancementMetadata.extractInterceptor( entity )
				: null;

		for ( int j = 0; j < span; j++ ) {
			NonIdentifierAttribute property = entityMetamodel.getProperties()[j];
			if ( !property.isLazy() || interceptor == null || interceptor.isInitialized( property.getName() ) ) {
				result[j] = getters[j].get( entity );
			}
			else {
				result[j] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
			}
		}
		return result;
[Java, 0]
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).getValues(java.lang.Object, org.hibernate.engine.spi.EntityEntry, boolean, org.hibernate.engine.spi.SessionImplementor) line: 180	
		else {
			checkId( entity, persister, entry.getId(), session );

			// grab its current state
			values = persister.getPropertyValues( entity );

			checkNaturalId( persister, entry, values, loadedState, session );
/ NIETS
/ TODO
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).onFlushEntity(org.hibernate.event.spi.FlushEntityEvent) line: 137	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/d,
[Java,0]
		event.setPropertyValues( values );

		//TODO: avoid this for non-new instances where mightBeDirty==false
		boolean substitute = wrapCollections( session, persister, types, values );
false
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
			substitute = scheduleUpdate( event ) || substitute;
		}
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).isUpdateNecessary(org.hibernate.event.spi.FlushEntityEvent, boolean) line: 216	
		final Status status = event.getEntityEntry().getStatus();
		if ( mightBeDirty || status == Status.DELETED ) {
			// compare to cached state (ignoring collections unless versioned)
			dirtyCheck( event );
			if ( isUpdateNecessary( event ) ) {
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).isUpdateNecessary(org.hibernate.event.spi.FlushEntityEvent) line: 424	
/=
	/**
	 * Performs all necessary checking to determine if an entity needs an SQL update
	 * to synchronize its state to the database. Modifies the event by side-effect!
	 * Note: this method is quite slow, avoid calling if possible!
	 */
	protected final boolean isUpdateNecessary(FlushEntityEvent event) throws HibernateException {
...
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).isUpdateNecessary(org.hibernate.event.spi.FlushEntityEvent, boolean) line: 220	
		final Status status = event.getEntityEntry().getStatus();
		if ( mightBeDirty || status == Status.DELETED ) {
			// compare to cached state (ignoring collections unless versioned)
			dirtyCheck( event );
			if ( isUpdateNecessary( event ) ) {
/n,
				return true;
			}
			else {
				if ( event.getEntityEntry().getPersister().getInstrumentationMetadata().isInstrumented() ) {
/n,
					event.getEntityEntry()
							.getPersister()
							.getInstrumentationMetadata()
							.extractInterceptor( event.getEntity() )
							.clearDirty();
				}
				event.getSession()
						.getFactory()
						.getCustomEntityDirtinessStrategy()
						.resetDirty( event.getEntity(), event.getEntityEntry().getPersister(), event.getSession() );
/ TODO
				return false;
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener(org.hibernate.event.internal.DefaultFlushEntityEventListener).onFlushEntity(org.hibernate.event.spi.FlushEntityEvent) line: 146	
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/n,
			substitute = scheduleUpdate( event ) || substitute;
		}
		if ( status != Status.DELETED ) {
			// now update the object .. has to be outside the main if block above (because of collections)
			if ( substitute ) {
/n,
				persister.setPropertyValues( entity, values );
			}
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEntities(org.hibernate.event.spi.FlushEvent, org.hibernate.engine.spi.PersistenceContext) line: 206	
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
		
entityEntries	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl[3]  (id=27621)	
	[0]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27622)	
		entity	domain.Language  (id=19767)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27636)	
	[1]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27623)	
		entity	domain.Language  (id=25249)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27361)	
	[2]	org.hibernate.engine.internal.EntityEntryContext$EntityEntryCrossRefImpl  (id=27624)	
		entity	domain.Language  (id=25255)	
		entityEntry	org.hibernate.engine.internal.MutableEntityEntry  (id=27637)	


			// Update the status of the object and if necessary, schedule an update

			EntityEntry entry = me.getValue();
			Status status = entry.getStatus();

			if ( status != Status.LOADING && status != Status.GONE ) {
				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );	/ doet WH NIETS, want de entityEntries of entities zijn niet dirty, 
				}
			}
		}

/ Intermezzo

/ (**)

/ we zijn nog steeds in,

org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	

        while ((lastIndexProcessed < preJcaSyncs.size())) {
            Synchronization preJcaSync = preJcaSyncs.get(lastIndexProcessed);
org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization@40778ee3
            preJcaSync.beforeCompletion();
...
/s,
org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
		flushBeforeTransactionCompletion();										<- hier,
		actionQueue.beforeTransactionCompletion();		 		<- later,
...
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 38	
				flushEverythingToExecutions( event );			<- hier,
				performExecutions( source );			<- later,
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 85	
			int entityCount = flushEntities( event, persistenceContext );
			
/ dat zijn dus uit session.persistenceContext.entityEntryContext.reentrantSafeEntries	, 
/ niet uit session.actionQueue.insertions, die komen later,
/ TODO
	

/ Einde Intermezzo

/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).flushEverythingToExecutions(org.hibernate.event.spi.FlushEvent) line: 86	
		try {
			int entityCount = flushEntities( event, persistenceContext );
/d,
			int collectionCount = flushCollections( session, persistenceContext );

			event.setNumberOfEntitiesProcessed( entityCount );
			event.setNumberOfCollectionsProcessed( collectionCount );
/t,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39	
		if ( persistenceContext.getNumberOfManagedEntities() > 0 ||
				persistenceContext.getCollectionEntries().size() > 0 ) {

			try {
				source.getEventListenerManager().flushStart();

				flushEverythingToExecutions( event );
/d,
				performExecutions( source );
/s,
org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 325
	
		// IMPL NOTE : here we alter the flushing flag of the persistence context to allow
		//		during-flush callbacks more leniency in regards to initializing proxies and
		//		lazy collections during their processing.
		// For more information, see HHH-2763
		try {
			session.getJdbcCoordinator().flushBeginning();
			session.getPersistenceContext().setFlushing( true );
			// we need to lock the collection caches before executing entity inserts/updates in order to
			// account for bi-directional associations
			session.getActionQueue().prepareActions();
			session.getActionQueue().executeActions();
/s,
org.hibernate.engine.spi.ActionQueue.prepareActions() line: 467	
/ TODO
/t,
/s,
org.hibernate.engine.spi.ActionQueue.executeActions() line: 453	

/ Intermezzo

this	org.hibernate.engine.spi.ActionQueue  (id=22412)	
	collectionCreations	null	
	collectionQueuedOps	null	
	collectionRemovals	null	
	collectionUpdates	null	
	deletions	null	
	insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=25291)	
		executables	java.util.ArrayList<E>  (id=25292)	
			elementData	java.lang.Object[5]  (id=28914)	
				[0]	org.hibernate.action.internal.EntityInsertAction  (id=25294)	
				[1]	org.hibernate.action.internal.EntityInsertAction  (id=25295)	
				[2]	org.hibernate.action.internal.EntityInsertAction  (id=25296)	
			size	3	
/ Dit is nog steeds zo, maar daar kijken we nu niet naar,

EXECUTABLE_LISTS_MAP	java.util.LinkedHashMap<K,V>  (id=22092)	
	size	8	
	table	java.util.HashMap$Node<K,V>[16]  (id=22101)	
		[0]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)	
			key	java.lang.Class<T> (org.hibernate.action.internal.CollectionRemoveAction) (id=26977)	
			value	org.hibernate.engine.spi.ActionQueue$5  (id=29195)
		[1]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)				
			key	java.lang.Class<T> (org.hibernate.action.internal.AbstractEntityInsertAction) (id=8054)	
			value	org.hibernate.engine.spi.ActionQueue$2  (id=22133)	
		[8]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)	
			key	java.lang.Class<T> (org.hibernate.action.internal.QueuedOperationCollectionAction) (id=26894)	
			value	org.hibernate.engine.spi.ActionQueue$4  (id=29194)
		[]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)				
			key	java.lang.Class<T> (org.hibernate.action.internal.EntityUpdateAction) (id=26714)	
			value	org.hibernate.engine.spi.ActionQueue$3  (id=29193)
		[]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)				
			key	java.lang.Class<T> (org.hibernate.action.internal.CollectionRecreateAction) (id=26876)	
			value	org.hibernate.engine.spi.ActionQueue$7  (id=29192)
		[]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)				
			key	java.lang.Class<T> (org.hibernate.action.internal.EntityDeleteAction) (id=26468)	
			value	org.hibernate.engine.spi.ActionQueue$8  (id=29191)
		[]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)				
			key	java.lang.Class<T> (org.hibernate.action.internal.CollectionUpdateAction) (id=26871)	
			value	org.hibernate.engine.spi.ActionQueue$6  (id=29190)
		[15]	java.util.LinkedHashMap$Entry<K,V>  (id=22099)				
			key	java.lang.Class<T> (org.hibernate.action.internal.OrphanRemovalAction) (id=22124)	
			value	org.hibernate.engine.spi.ActionQueue$1  (id=29189)	

/ Deze zijn er geprogrammeerd in de list set,

public class ActionQueue {
	private static final LinkedHashMap<Class<? extends Executable>,ListProvider> EXECUTABLE_LISTS_MAP;
	static {
		EXECUTABLE_LISTS_MAP = new LinkedHashMap<Class<? extends Executable>,ListProvider>( 8 );

		EXECUTABLE_LISTS_MAP.put(
				OrphanRemovalAction.class,
				new ListProvider<OrphanRemovalAction>() {
					ExecutableList<OrphanRemovalAction> get(ActionQueue instance) {
						return instance.orphanRemovals;
					}
					ExecutableList<OrphanRemovalAction> init(ActionQueue instance) {
						// OrphanRemovalAction executables never require sorting.
						return instance.orphanRemovals = new ExecutableList<OrphanRemovalAction>( false );
					}
				}
		);
		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;
					}
					ExecutableList<AbstractEntityInsertAction> init(ActionQueue instance) {
						if ( instance.isOrderInsertsEnabled() ) {
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									new InsertActionSorter()
							);
						}
						else {
							return instance.insertions = new ExecutableList<AbstractEntityInsertAction>(
									false
							);
						}
					}
				}
		);
		...


/ Einde Intermezzo

		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
			ExecutableList<?> l = listProvider.get( this );
			if ( l != null && !l.isEmpty() ) {
				executeActions( l );
			}
/1ste	,
		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
listProvider	org.hibernate.engine.spi.ActionQueue$1  (id=29189)	
/=
		EXECUTABLE_LISTS_MAP.put(
				OrphanRemovalAction.class,
				new ListProvider<OrphanRemovalAction>() {
					ExecutableList<OrphanRemovalAction> get(ActionQueue instance) {
						return instance.orphanRemovals;
					}
			ExecutableList<?> l = listProvider.get( this );
/s,
org.hibernate.engine.spi.ActionQueue$1.get(org.hibernate.engine.spi.ActionQueue) line: 105	
						return instance.orphanRemovals;		
/t,
				ExecutableList<?> l = listProvider.get( this );
null
=session.actionQueue.orphanRemovals
			if ( l != null && !l.isEmpty() ) {
/n,
				executeActions( l );
			}

/ volgende,
		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
listProvider	org.hibernate.engine.spi.ActionQueue$2  (id=22133)	
/=
		EXECUTABLE_LISTS_MAP.put(
				AbstractEntityInsertAction.class,
				new ListProvider<AbstractEntityInsertAction>() {
					ExecutableList<AbstractEntityInsertAction> get(ActionQueue instance) {
						return instance.insertions;
					}

			ExecutableList<?> l = listProvider.get( this );
l	org.hibernate.engine.spi.ExecutableList<E>  (id=25291)	/=session.actionQueue.insertions
	executables	java.util.ArrayList<E>  (id=25292)	
		elementData	java.lang.Object[5]  (id=28914)	
			[0]	org.hibernate.action.internal.EntityInsertAction  (id=25294)	
				id	java.lang.Long  (id=27638)	
				instance	domain.Language  (id=19767)	
				state	java.lang.Object[2]  (id=27639)	
				version	java.lang.Integer  (id=27640)	
			[1]	org.hibernate.action.internal.EntityInsertAction  (id=25295)	
			[2]	org.hibernate.action.internal.EntityInsertAction  (id=25296)	

			if ( l != null && !l.isEmpty() ) {
				executeActions( l );
			}
		}
/s,
org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 580	
			for ( E e : list ) {
				try {
					e.execute();
/s,
org.hibernate.action.internal.EntityInsertAction.execute() line: 75	
		nullifyTransientReferencesIfNotAlready();

		final EntityPersister persister = getPersister();
		final SessionImplementor session = getSession();
		final Object instance = getInstance();
		final Serializable id = getId();

		final boolean veto = preInsert();
false
		// Don't need to lock the cache here, since if someone
		// else inserted the same pk first, the insert would fail

		if ( !veto ) {
			persister.insert( id, getState(), instance, session );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3397	

		final int span = getTableSpan();
		if ( entityMetamodel.isDynamicInsert() ) {
/n,
			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
			boolean[] notNull = getPropertiesToInsert( fields );
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
			}
		}
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
			}
/s,
		return entityMetamodel.getPropertyInsertability();/ [true,true]
/t,
/s,
		return sqlInsertStrings;/ [insert into Language (name, version, id) values (?, ?, ?)]
/t,
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2841	
/=
	/**
	 * Perform an SQL INSERT.
	 * <p/>
	 * This for is used for all non-root tables as well as the root table
	 * in cases where the identifier value is known before the insert occurs.
	 */
	protected void insert(
			final Serializable id,
			final Object[] fields,	[Java,0]
			final boolean[] notNull,
			final int j,
			final String sql,
			final Object object,
			final SessionImplementor session) throws HibernateException {

		// TODO : shouldn't inserts be Expectations.NONE?
		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
		// we can't batch joined inserts, *especially* not if it is an identity insert;
		// nor can we batch statements where the expectation is based on an output param
		final boolean useBatch = j == 0 && expectation.canBeBatched();
		if ( useBatch && inserBatchKey == null ) {
/j,
			inserBatchKey = new BasicBatchKey(
					getEntityName() + "#INSERT",
					expectation
			);
		}
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=27388)	
	inserBatchKey	org.hibernate.engine.jdbc.batch.internal.BasicBatchKey  (id=30026)	
		comparison	"domain.Language#INSERT" (id=30025)	
		expectation	org.hibernate.jdbc.Expectations$BasicExpectation  (id=30018)	
			expectedRowCount	1	
		statementCount	1	

		try {
			// Render the SQL query
			final PreparedStatement insert;
			if ( useBatch ) {
/j,
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
			}
			else {
				insert = session
						.getJdbcCoordinator()
						.getStatementPreparer()
						.prepareStatement( sql, callable );
			}
/s,
org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.getBatch(org.hibernate.engine.jdbc.batch.spi.BatchKey) line: 207	
		currentBatch = batchBuilder().buildBatch( key, this );
/s,
org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl.buildBatch(org.hibernate.engine.jdbc.batch.spi.BatchKey, org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 63	
		return size > 1
/n,
				? new BatchingBatch( key, jdbcCoordinator, size )
				: new NonBatchingBatch( key, jdbcCoordinator );
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).<init>(org.hibernate.engine.jdbc.batch.spi.BatchKey, org.hibernate.engine.jdbc.spi.JdbcCoordinator) line: 61	

	private LinkedHashMap<String,PreparedStatement> statements = new LinkedHashMap<String,PreparedStatement>();
/t,
/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 120	
		PreparedStatement statement = statements.get( sql );
		if ( statement == null ) {
/j,
			statement = buildBatchStatement( sql, callable );
			statements.put( sql, statement );
		}
/s,
	private PreparedStatement buildBatchStatement(String sql, boolean callable) {

		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 78	
/ TODO CONSTRUCTIE
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.buildPreparedStatementPreparationTemplate(java.lang.String, boolean) line: 82	
/=
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
		};
/ Deze kennen we,
/t,
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 167	
			try {
				getJdbcService().getSqlStatementLogger().logStatement( sql );

				final PreparedStatement preparedStatement;
				try {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementStart();
					preparedStatement = doPrepare();
					setStatementTimeout( preparedStatement );
				}
				finally {
					jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcPrepareStatementEnd();
				}
				postProcess( preparedStatement );
				return preparedStatement;
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 85	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
		};
/s,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
		return logicalConnection().getPhysicalConnection();
/s,
	protected final LogicalConnectionImplementor logicalConnection() {
		return jdbcCoordinator.getLogicalConnection();
	}
/t,
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	

this	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl  (id=22454)	
	physicalConnection	null	

		return acquireConnectionIfNeeded();
/s,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 87	
		if ( physicalConnection == null ) {
			try {
				physicalConnection = jdbcConnectionAccess.obtainConnection();
/s,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
			try {
				return connectionProvider.getConnection();
/s,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/s,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
        return delegate.getConnection();
/s,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	

      return super.getManagedConnection(trackByTransaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
      try
      {
         return pool.getConnection(transaction, subject, cri);
		 
/ Intermezzo

/ er is blijkbaar een org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl per ds, en dus een pool per ds,
/ de tsr en tm zijn er WH maar 1 van,


this	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=19529)	
	pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19539)	
		mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=22561)	
		mcpPools	java.util.concurrent.ConcurrentHashMap<K,V>  (id=30126)	
		poolName	"PostgreSQLDS" (id=30157)	
	transactionManager	org.jboss.jca.core.tx.jbossts.TransactionManagerDelegator  (id=30093)	
	transactionSynchronizationRegistry	org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper  (id=20414)	
		interposedSyncs	java.util.concurrent.ConcurrentHashMap<K,V>  (id=22272)	
			table	java.util.concurrent.ConcurrentHashMap$Node<K,V>[16]  (id=26027)	
				[3]	java.util.concurrent.ConcurrentHashMap$Node<K,V>  (id=26032)	
					key	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19737)	
					val	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList  (id=22352)	
						preJcaSyncs	java.util.ArrayList<E>  (id=22355)	
							elementData	java.lang.Object[10]  (id=26046)	
								[0]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=22358)	
									synchronizationCallbackCoordinator	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl  (id=22364)	
										target	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl  (id=22445)	
											transactionCoordinatorOwner	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=22428)	
												logicalConnection	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl  (id=22454)	
													physicalConnection	null	
								[1]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22359)
									manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19769)	
										session	org.hibernate.internal.SessionImpl  (id=22407)
											actionQueue	org.hibernate.engine.spi.ActionQueue  (id=22412)	
												insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=25291)	
														[0]	org.hibernate.action.internal.EntityInsertAction  (id=25294)	
														[1]	org.hibernate.action.internal.EntityInsertAction  (id=25295)	
														[2]	org.hibernate.action.internal.EntityInsertAction  (id=25296)										
									scopedPuName	"test.war#arquillian-forge4-persistence-unit" (id=22270)	
									
								[2]	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization  (id=22360)	
								[3]	org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization  (id=22361)
									manager	org.hibernate.jpa.internal.EntityManagerImpl  (id=19807)	
										session	org.hibernate.internal.SessionImpl  (id=19808)
											actionQueue	org.hibernate.engine.spi.ActionQueue  (id=22090)	
												insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=22165)	
													executables	java.util.ArrayList<E>  (id=22166)	
														[0]	org.hibernate.action.internal.EntityInsertAction  (id=22051)	
														[1]	org.hibernate.action.internal.EntityInsertAction  (id=25280)	
														[2]	org.hibernate.action.internal.EntityInsertAction  (id=25281)	
									scopedPuName	"test.war#arquillian-forge4-persistence-unit-1" (id=19772)									
						jcaSyncs	java.util.ArrayList<E>  (id=22354)	
							elementData	java.lang.Object[10]  (id=26045)	
								[0]	org.jboss.jca.core.connectionmanager.transaction.TransactionSynchronizer  (id=22401)	
									enlisted	java.util.ArrayList<E>  (id=22485)	
										elementData	java.lang.Object[2]  (id=26047)	
											[0]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22488)	
												this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22492)	
	->												cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=19529)
														pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19539)														
													managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
														currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	
														mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=22561)	
														xaResource	org.postgresql.xa.PGXAConnection  (id=22575)	
															conn	org.postgresql.jdbc42.Jdbc42Connection  (id=22585)	
															currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	
															isXA	true	
													managedConnectionPool	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=22514)	
													pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19539)	
														mcpPools	java.util.concurrent.ConcurrentHashMap<K,V>  (id=30126)	
														poolName	"PostgreSQLDS" (id=30157)	
													transactionSynchronization	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22488)	
													xaResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22525)	
														xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
															currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	
															xaResource	org.postgresql.xa.PGXAConnection  (id=22575)	
																con	org.postgresql.jdbc42.Jdbc42Connection  (id=22585)	
																	protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	
																		pgStream	org.postgresql.core.PGStream  (id=22623)
																			connection	java.net.Socket  (id=24944)	
																			pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=24949)	
																			pg_output	java.io.BufferedOutputStream  (id=24950)			
														
											[1]	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization  (id=22489)	
												this$0	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22635)
	->												cm	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl  (id=19546)	
														pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19548)													
													managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=20421)	
														mcf	org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService$WildFlyXaMCF  (id=20413)	
														con	org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection  (id=20427)	
														currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22642)	
														xaResource	org.h2.jdbcx.JdbcXAConnection  (id=22651)
															currentTransaction	com.arjuna.ats.jta.xa.XidImple  (id=22642)
															handleConn	org.h2.jdbcx.JdbcXAConnection$PooledJdbcConnection  (id=20427)																
															physicalConn	org.h2.jdbc.JdbcConnection  (id=22658)
																transferList	java.util.ArrayList<E>  (id=20435)	
																	[0]	org.h2.value.Transfer  (id=20436)	
																		in	java.io.DataInputStream  (id=20567)	
																		out	java.io.DataOutputStream  (id=20568)	
																		session	org.h2.engine.SessionRemote  (id=20430)	
																		socket	java.net.Socket  (id=20569)	
														
													managedConnectionPool	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=22639)	
													pool	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool  (id=19548)	
														mcpPools	java.util.concurrent.ConcurrentHashMap<K,V>  (id=30719)	
														poolName	"RemoteExampleDS" (id=30727)	



/ Einde Intermezzo

/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 566	

      // Get specific managed connection pool key
      Object key = getKey(subject, cri, separateNoTx);
false
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);

/ Intermezzo

/ In een session zul je geen connection zien, deze wordt steeds uit pool gehaald,	 
/ in [1] en [3] van preJcaSyncs zien we een connectie 	, maar we zitten nu in process van [0]	, (en straks van [2])	,


/ Einde Intermezzo

/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getManagedConnectionPool(java.lang.Object, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 295	

         ManagedConnectionPool mcp = mcpPools.get(key);
{false=SemaphoreConcurrentLinkedQueueManagedConnectionPool@3ba1a91d[pool=PostgreSQLDS]}		
	return mcp;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 584	
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
/d,
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/s,
   /**
    * Get any transaction synchronization registry associated with the pool.
    * @return The value
    */
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionSynchronizationRegistry() line: 376	
      if (getTransactionIntegration() != null)
         return getTransactionIntegration().getTransactionSynchronizationRegistry();
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionIntegration() line: 352	
      if (cm != null)
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl@13de8dcc
         return cm.getTransactionIntegration();
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getTransactionIntegration() line: 228	
      return txIntegration;
org.jboss.jca.core.tx.jbossts.TransactionIntegrationImpl@75609bf8
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionSynchronizationRegistry() line: 377	
         return getTransactionIntegration().getTransactionSynchronizationRegistry();
/pd,
/s,
	      return tsr;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 593
	
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
/d,
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;
0:ffffbea85a97:-35437ec6:5af567cc:a3

      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 659	
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
/s,
org.jboss.as.txn.service.internal.tsr.TransactionSynchronizationRegistryWrapper.getResource(java.lang.Object) line: 106	

			return delegate.getResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple.getResource(java.lang.Object) line: 126
/= de tsr	,	
        TransactionImple transactionImple = getTransactionImple();
        return transactionImple.getTxLocalResource(key);
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);

this	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple  (id=19737)	
	_txLocalResources	java.util.Collections$SynchronizedMap<K,V>  (id=22382)	
		m	java.util.HashMap<K,V>  (id=31862)	
			table	java.util.HashMap$Node<K,V>[16]  (id=31866)	
				[10]	java.util.HashMap$Node<K,V>  (id=22730)	
					key	org.jboss.jca.core.connectionmanager.transaction.LockKey  (id=31867)
					value	java.util.concurrent.locks.ReentrantLock  (id=31842)
java.util.concurrent.locks.ReentrantLock@221b409[Locked by thread default task-100]			/= current thread,		
				[12]	java.util.HashMap$Node<K,V>  (id=22731)	
					key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=22514)
					value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22492)
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@2694a63f[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 connection handles=0 lastReturned=1526661317561 lastValidated=1526050366421 lastCheckedOut=1526661455130 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@2e8d2faf mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@3ba1a91d[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@2bc0537d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=TransactionSynchronization@1490100182{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:a3 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]					
				[13]	java.util.HashMap$Node<K,V>  (id=22732)				
					key	"__TX_LISTENERS" (id=22280)	
					value	java.util.concurrent.ConcurrentLinkedQueue<E>  (id=25952)
[org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@4e1bf99, org.jboss.as.jpa.transaction.TransactionUtil$SessionSynchronization@2b6c899]					
					next	java.util.HashMap$Node<K,V>  (id=22733)	
						key	"test.war#arquillian-forge4-persistence-unit" (id=22270)	
						value	org.hibernate.jpa.internal.EntityManagerImpl  (id=19769)
org.hibernate.jpa.internal.EntityManagerImpl@27753cc1						
				[14]	java.util.HashMap$Node<K,V>  (id=22734)	
					key	"test.war#arquillian-forge4-persistence-unit-1" (id=19772)
					value	org.hibernate.jpa.internal.EntityManagerImpl  (id=19807)
org.hibernate.jpa.internal.EntityManagerImpl@5b09be5a					
					next	java.util.HashMap$Node<K,V>  (id=22735)	
						key	org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool  (id=22639)	
						value	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22635)	
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@6291f607[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@4e0b4154 connection handles=0 lastReturned=1526671681841 lastValidated=1526671681841 lastCheckedOut=1526671681841 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@12a3b7d5 mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@777095ee[pool=RemoteExampleDS] xaResource=XAResourceWrapperImpl@492d3420[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@4e0b4154 pad=false overrideRmValue=null productName=H2 productVersion=1.3.173 (2013-07-28) jndiName=java:jboss/datasources/RemoteExampleDS] txSync=TransactionSynchronization@166946140{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:a3 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]

/ we zien achter de h2 en pg pools een connection listener, 
/ in de connection listener zit de connection, 
/ dus het is key:value=pool:connection (uit pool)
/ Kun je ook meerdere entries hebben pool: connection (other uit pool)?
/ TODO
		

/ we waren in 	,
/s,
com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.getTxLocalResource(java.lang.Object) line: 1090	
		return _txLocalResources.get(key);
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getTransactionOldConnection(javax.transaction.Transaction, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 660	
         // Already got one
         ConnectionListener cl = (ConnectionListener)tsr.getResource(mcp);
/d,
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 596	
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);
/d,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener@2694a63f[state=NORMAL managed connection=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 connection handles=0 lastReturned=1526661317561 lastValidated=1526050366421 lastCheckedOut=1526661455130 trackByTx=true pool=org.jboss.jca.core.connectionmanager.pool.strategy.OnePool@2e8d2faf mcp=SemaphoreConcurrentLinkedQueueManagedConnectionPool@3ba1a91d[pool=PostgreSQLDS] xaResource=XAResourceWrapperImpl@2bc0537d[xaResource=org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@3f5d8155 pad=false overrideRmValue=null productName=PostgreSQL productVersion=9.6.5 jndiName=java:jboss/datasources/PostgreSQLDS] txSync=TransactionSynchronization@1490100182{tx=TransactionImple < ac, BasicAction: 0:ffffbea85a97:-35437ec6:5af567cc:a3 status: ActionStatus.RUNNING > wasTrackByTx=true enlisted=true cancel=false}]
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
      try
      {
         return pool.getConnection(transaction, subject, cri);
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/d,
cl	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22492)	
	managedConnection	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
		currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	
		xaResource	org.postgresql.xa.PGXAConnection  (id=22575)	
	xaResource	org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl  (id=22525)	
		xaResource	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
			currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	
			xaResource	org.postgresql.xa.PGXAConnection  (id=22575)	
				conn	org.postgresql.jdbc42.Jdbc42Connection  (id=22585)	
					protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	
						pgStream	org.postgresql.core.PGStream  (id=22623)	
							connection	java.net.Socket  (id=24944)	
							encoding	org.postgresql.core.Encoding  (id=24945)	
							pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=24949)	
							pg_output	java.io.BufferedOutputStream  (id=24950)	
				currentXid	com.arjuna.ats.jta.xa.XidImple  (id=22552)	


      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/s,
         if (shouldEnlist(cl.getManagedConnection()))
            cl.enlist();
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 264	
      // This method is a bit convulted, but it has to be such because
      // there is a race condition in the transaction manager where it
      // unlocks during the enlist of the XAResource. It does this
      // to avoid distributed deadlocks and to ensure the transaction
      // timeout can fail a badly behaving resource during the enlist.
      //
      // When two threads in the same transaction are trying to enlist
      // connections they could be from the same resource manager
      // or even the same connection when tracking the connection by transaction.
      //
      // For the same connection, we only want to do the real enlist once.
      // For two connections from the same resource manager we don't
      // want the join before the initial start request.
      //
      // The solution is to build up a list of unenlisted resources
      // in the TransactionSynchronizer and then choose one of the
      // threads that is contending in the transaction to enlist them
      // in order. The actual order doesn't really matter as it is the
      // transaction manager that calculates the enlist flags and determines
      // whether the XAResource was already enlisted.
      //
      // Once there are no unenlisted resources the threads are released
      // to return the result of the enlistments.
      //
      // In practice, a thread just takes a snapshot to try to avoid one
      // thread having to do all the work. If it did not do them all
      // the next waiting thread will do the next snapshot until there
      // there is either no snapshot or no waiting threads.
      //
      // A downside to this design is a thread could have its resource enlisted by
      // an earlier thread while it enlists some later thread's resource.
      // Since they are all a part of the same transaction, this is probably
      // not a real issue.

      // If we are already enlisted there is no reason to check again, as this method
      // could be called multiple times during a transaction lifecycle.
      // We know that we can only be inside this method if we are allowed to
      if (isEnlisted() || getState().equals(ConnectionState.DESTROY) || getState().equals(ConnectionState.DESTROYED))
/ isEnlisted==true
         return;

/ Intermezzo

/ we zitten in before tx completion; die doet flush, en er zijn 3 executions in  session.actionQueue.insertions; daarvoor moet eerst 
/ een connection gevonden/created worden,

/ Einde Intermezzo

/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 756	
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/d,
      // Ask the managed connection for a connection
      Object connection = null;
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 462	

      return getWrappedConnection();
/s,
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).getWrappedConnection() line: 1193	
      WrappedConnection lc = WRAPPED_CONNECTION_FACTORY.createWrappedConnection(this,
                                                                                mcf.getSpy().booleanValue(),
                                                                                mcf.getJndiName(),
                                                                                mcf.isDoLocking());
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionFactoryJDK7.createWrappedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection, boolean, java.lang.String, boolean) line: 60	
      return new WrappedConnectionJDK7(mc, spy, jndiName, doLocking);

mc	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
	xaResource	org.postgresql.xa.PGXAConnection  (id=22575)	

/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 773	
      try
      {
         connection = cl.getManagedConnection().getConnection(subject, cri);
/d,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7@6f93d0a1

      // Associate managed connection with the connection
      registerAssociation(cl, connection);
/s,
      cl.registerConnection(c);
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener(org.jboss.jca.core.connectionmanager.listener.AbstractConnectionListener).registerConnection(java.lang.Object) line: 319	

         connectionHandles.add(handle);
this	org.jboss.jca.core.connectionmanager.listener.TxConnectionListener  (id=22492)	
	connectionHandles	java.util.concurrent.CopyOnWriteArraySet<E>  (id=22500)	
/ TODO CONCURRENT 

org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 777	

      // Associate managed connection with the connection
      registerAssociation(cl, connection);
/d,
      if (cachedConnectionManager != null)
      {
         cachedConnectionManager.registerConnection(this, cl, connection);
/ TODO
/t,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 139	
         WrappedConnection wc = (WrappedConnection) cm.allocateConnection(mcf, defaultCRI);
/d,
         wc.setDataSource(this);
         wc.setSpy(mcf.getSpy().booleanValue());
         wc.setJndiName(mcf.getJndiName());
         return wc;
      }
/t,
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
        return delegate.getConnection();
/t,
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
/t,
org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection() line: 386	
				return connectionProvider.getConnection();
/t,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded() line: 93	
			try {
				physicalConnection = jdbcConnectionAccess.obtainConnection();
/t,
org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection() line: 112	
		return acquireConnectionIfNeeded();
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection() line: 47	
		return logicalConnection().getPhysicalConnection();
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/pd,
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 443	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
										 
/ Intermezzo

org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);

this	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection  (id=22512)	
	con	com.sun.proxy.$Proxy54  (id=22550)	
Pooled connection wrapping physical connection org.postgresql.jdbc42.Jdbc42Connection@4ae50d4e
	xaConnection	org.postgresql.xa.PGXAConnection  (id=22575)	
	xaResource	org.postgresql.xa.PGXAConnection  (id=22575)
	
/ gaat via con, NIET via xaResource, 
/ en XAManagedConnection heeft wel methods die xaResource use, bijv. start(Xid xid, int flags) calls xaResource.start(xid,flags)

/ TODO

/ Einde Intermezzo


/s,
org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 178	
		return method.invoke(con, args);
method=public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int) throws java.sql.SQLException
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 346
                else if (methodName.equals("prepareStatement"))
                {	
                    Statement st = (Statement)method.invoke(con, args);
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).prepareStatement(java.lang.String, int, int) line: 281	
        return prepareStatement(sql, resultSetType, resultSetConcurrency, getHoldability());
...
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 194	
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
sql=insert into Language (name, version, id) values (?, ?, ?)
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).borrowQuery(java.lang.String, boolean) line: 100	
        return statementCache.borrow(key);
key=insert into Language (name, version, id) values (?, ?, ?)
statementCache.cache={select nextval ('hibernate_sequence')=org.postgresql.core.CachedQuery@1ebe1ae0}
/s,
org.postgresql.util.LruCache<Key,Value>.borrow(Key) line: 94	
        Value value = cache.remove(key);
        if (value == null)
/j,
            return createAction.create(key);
/s,
org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 34	
        } else
        {
            isFunction = false;
            outParmBeforeFunc = false;
        }
        Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql);
/s,

        return new CachedQuery(key, query, isFunction, outParmBeforeFunc);
/s,
org.postgresql.core.v3.QueryExecutorImpl.parseQuery(java.lang.String, boolean) line: 113
	
        List<NativeQuery> queries = Parser.parseJdbcSql(query, protoConnection.getStandardConformingStrings(), withParameters, true);
query	"insert into Language (name, version, id) values (?, ?, ?)" (id=33008)	

this	org.postgresql.core.v3.QueryExecutorImpl  (id=22620)	
	pgStream	org.postgresql.core.PGStream  (id=22623)	
	protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	
		pgStream	org.postgresql.core.PGStream  (id=22623)	
			connection	java.net.Socket  (id=24944)	
			pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=24949)	
			pg_output	java.io.BufferedOutputStream  (id=24950)	

/ Intermezzo

/ we zijn in,

Thread [default task-100] (Suspended)	
	owns: java.lang.Object  (id=25973)	
	org.postgresql.core.Parser.parseJdbcSql(java.lang.String, boolean, boolean, boolean) line: 49	
	org.postgresql.core.v3.QueryExecutorImpl.parseQuery(java.lang.String, boolean) line: 113	
	org.postgresql.core.v3.QueryExecutorImpl.createParameterizedQuery(java.lang.String) line: 108	
	org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 49	
	org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 21	
	org.postgresql.util.LruCache<Key,Value>.borrow(Key) line: 94	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).borrowQuery(java.lang.String, boolean) line: 100	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 197
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
/cb,	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc3.AbstractJdbc3Statement).<init>(org.postgresql.jdbc3.AbstractJdbc3Connection, java.lang.String, boolean, int, int, int) line: 49	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc3g.AbstractJdbc3gStatement).<init>(org.postgresql.jdbc3.AbstractJdbc3Connection, java.lang.String, boolean, int, int, int) line: 29	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc4.AbstractJdbc4Statement).<init>(org.postgresql.jdbc4.AbstractJdbc4Connection, java.lang.String, boolean, int, int, int) line: 33	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.AbstractJdbc42Statement).<init>(org.postgresql.jdbc42.AbstractJdbc42Connection, java.lang.String, boolean, int, int, int) line: 27	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc42.Jdbc42Statement).<init>(org.postgresql.jdbc42.AbstractJdbc42Connection, java.lang.String, boolean, int, int, int) line: 31	
	org.postgresql.jdbc42.Jdbc42PreparedStatement.<init>(org.postgresql.jdbc42.Jdbc42Connection, java.lang.String, boolean, int, int, int) line: 21	
	org.postgresql.jdbc42.Jdbc42PreparedStatement.<init>(org.postgresql.jdbc42.Jdbc42Connection, java.lang.String, int, int, int) line: 16	
	org.postgresql.jdbc42.Jdbc42Connection.prepareStatement(java.lang.String, int, int, int) line: 40	
	org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc3.AbstractJdbc3Connection).prepareStatement(java.lang.String, int, int) line: 282
        return prepareStatement(sql, resultSetType, resultSetConcurrency, getHoldability());
/cb,
	sun.reflect.GeneratedMethodAccessor19.invoke(java.lang.Object, java.lang.Object[]) line: not available	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 346
                else if (methodName.equals("prepareStatement"))
                {
                    Statement st = (Statement)method.invoke(con, args);
/cb,	
	com.sun.proxy.$Proxy54.prepareStatement(java.lang.String, int, int) line: not available	
	sun.reflect.GeneratedMethodAccessor19.invoke(java.lang.Object, java.lang.Object[]) line: not available	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 178
                return method.invoke(con, args);
/cb,
	com.sun.proxy.$Proxy54.prepareStatement(java.lang.String, int, int) line: not available	
	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).doPrepareStatement(java.lang.String, int, int) line: 757	
      return con.prepareStatement(sql, resultSetType, resultSetConcurrency);
/cb,
	org.jboss.jca.adapters.jdbc.xa.XAManagedConnection(org.jboss.jca.adapters.jdbc.BaseWrapperManagedConnection).prepareStatement(java.lang.String, int, int) line: 743	
      else
      {
         return doPrepareStatement(sql, resultSetType, resultSetConcurrency);
/cb,
	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/cb,
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );					<-
/cb,
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 172	
					preparedStatement = doPrepare();
/cb,
	org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 78	
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/cb,
	org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).buildBatchStatement(java.lang.String, boolean) line: 136	
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/cb,
	org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 125	
		if ( statement == null ) {
			statement = buildBatchStatement( sql, callable );
/cb,
	org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2878	
			if ( useBatch ) {
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
/cb,
				org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3397
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
			}
		}
/cb,		
	org.hibernate.action.internal.EntityInsertAction.execute() line: 89
		if ( !veto ) {
			
			persister.insert( id, getState(), instance, session );
/cb,
	org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 582
			for ( E e : list ) {
				try {
					e.execute();
				}
/cb,	
	org.hibernate.engine.spi.ActionQueue.executeActions() line: 456	
		for ( ListProvider listProvider : EXECUTABLE_LISTS_MAP.values() ) {
			ExecutableList<?> l = listProvider.get( this );
			if ( l != null && !l.isEmpty() ) {
				executeActions( l );
			}
		}
listProvider	org.hibernate.engine.spi.ActionQueue$2  (id=23000)	
l===session.actionQueue.insertions
this	org.hibernate.engine.spi.ActionQueue  (id=22276)	
	insertions	org.hibernate.engine.spi.ExecutableList<E>  (id=23001)	
		executables	java.util.ArrayList<E>  (id=23003)	
			elementData	java.lang.Object[5]  (id=23005)	
				[0]	org.hibernate.action.internal.EntityInsertAction  (id=23006)	
				[1]	org.hibernate.action.internal.EntityInsertAction  (id=23007)	
				[2]	org.hibernate.action.internal.EntityInsertAction  (id=23008)	


/cb,
		org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 337	
			session.getActionQueue().executeActions();
/cb,
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39
				performExecutions( source );
/cb,
	org.hibernate.internal.SessionImpl.flush() line: 1282	
		FlushEvent flushEvent = new FlushEvent( this );
		for ( FlushEventListener listener : listeners( EventType.FLUSH ) ) {
			listener.onFlush( flushEvent );
/cb,
	org.hibernate.internal.SessionImpl.managedFlush() line: 465	
		flush();
/cb,
	org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963
		try {
			if ( flush ) {
				managedFlush();
/cb,	
	org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
		flushBeforeTransactionCompletion();
/cb,
	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485
		owner.beforeTransactionCompletion();
/cb,
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
		try {
			transactionCoordinatorOwner.beforeTransactionCompletion();
/cb,	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47
		target.beforeCompletion();
/cb,	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37
		synchronizationCallbackCoordinator.beforeCompletion();
/cb,	
	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116
        // This is needed to guard against syncs being registered during the run, otherwise we could have used an iterator
        int lastIndexProcessed = 0;
        while ((lastIndexProcessed < preJcaSyncs.size())) {
            Synchronization preJcaSync = preJcaSyncs.get(lastIndexProcessed);
			...
            preJcaSync.beforeCompletion();
            lastIndexProcessed = lastIndexProcessed + 1;
        }
/cb,	
	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76
	if (_theSynch != null)
	{
		_theSynch.beforeCompletion();
		return true;
/cb,		
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368
	                    try
	                    {
	                        problem = !_currentRecord.beforeCompletion();
/cb,	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
        if(status() != ActionStatus.ABORT_ONLY || TxControl.isBeforeCompletionWhenRollbackOnly())
        {
            canEnd = beforeCompletion();					<-
        }

		if (canEnd)
		{
			outcome = super.End(report_heuristics);
		}
		else
			outcome = super.Abort();

		afterCompletion(outcome, report_heuristics);
/cb,
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162
		int status = super.end(report_heuristics);
/cb,		
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200
				switch (_theTransaction.commit(true))
/cb,				
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
		theTransaction.commitAndDisassociate();
/cb,
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89
        transactionManager.commit() ;
/cb,	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91
            if (txStatus == Status.STATUS_ACTIVE) {
                // Commit tx
                // This will happen if
                // a) everything goes well
                // b) app. exception was thrown
                tm.commit();
/cb,	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279
            tm.begin();
            Transaction tx = tm.getTransaction();
            try {
                return invocation.proceed();
            } catch (Throwable t) {
                handleExceptionInOurTx(invocation, t, tx, component);
            } finally {
                endTransaction(tm, tx);
/cb,	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
        if (tx == null) {
            return invokeInOurTx(invocation, tm, component);
/cb,
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
                case REQUIRED:
                    return required(invocation, component, timeoutInSeconds);
/cb,
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view9.insertInTx() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available [local variables unavailable]	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	



/ Einde Intermezzo
	
/s,
    /**
     * Parses JDBC query into PostgreSQL's native format. Several queries might be given if separated by semicolon.
	 *
org.postgresql.core.Parser.parseJdbcSql(java.lang.String, boolean, boolean, boolean) line: 49	
/ TODO
/t,
org.postgresql.core.v3.QueryExecutorImpl.parseQuery(java.lang.String, boolean) line: 114	
        List<NativeQuery> queries = Parser.parseJdbcSql(query, protoConnection.getStandardConformingStrings(), withParameters, true);
/d,
queries	java.util.Collections$SingletonList<E>  (id=33106)	
	element	org.postgresql.core.NativeQuery  (id=33108)
		bindPositions	(id=33105)	[49, 53, 57]
		nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=33111)	

        if (queries.size() == 1) {
            return new SimpleQuery(queries.get(0), protoConnection);
        }
this	org.postgresql.core.v3.QueryExecutorImpl  (id=22620)	
	protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	
		pgStream	org.postgresql.core.PGStream  (id=22623)	
			connection	java.net.Socket  (id=24944)	
			pg_input	org.postgresql.core.VisibleBufferedInputStream  (id=24949)	
			pg_output	java.io.BufferedOutputStream  (id=24950)	
/t,
org.postgresql.jdbc2.CachedQueryCreateAction.create(java.lang.Object) line: 50	
        Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql);
/d,
        return new CachedQuery(key, query, isFunction, outParmBeforeFunc);
...
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 198	
        CachedQuery cachedQuery = connection.borrowQuery(sql, isCallable);
/d,
        this.preparedQuery = cachedQuery;
        this.preparedParameters = preparedQuery.query.createParameterList();
/s,
org.postgresql.core.v3.SimpleQuery.createParameterList() line: 35	
        return new SimpleParameterList(nativeQuery.bindPositions.length, protoConnection);
/t,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).<init>(org.postgresql.jdbc2.AbstractJdbc2Connection, java.lang.String, boolean, int, int) line: 215	
        this.preparedParameters = preparedQuery.query.createParameterList();
/d,
        forceBinaryTransfers |= connection.getForceBinary();
false
        resultsettype = rsType;
        concurrency = rsConcurrency;
        setFetchSize(connection.getDefaultFetchSize());
        setPrepareThreshold(connection.getPrepareThreshold());
...
/t,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 347	
                else if (methodName.equals("prepareStatement"))
                {
                    Statement st = (Statement)method.invoke(con, args);
/d,
st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=32982)	
	connection	org.postgresql.jdbc42.Jdbc42Connection  (id=22585)	
	preparedQuery	org.postgresql.core.CachedQuery  (id=33160)	
		key	"insert into Language (name, version, id) values (?, ?, ?)" (id=30005)	
		query	org.postgresql.core.v3.SimpleQuery  (id=33127)	
			nativeQuery	org.postgresql.core.NativeQuery  (id=33108)	
				bindPositions	(id=33105)	
				nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=33111)	
			protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	

                    return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{PreparedStatement.class, org.postgresql.PGStatement.class}, new StatementHandler(this, st));
                }
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.<init>(org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection, org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler, java.sql.Statement) line: 399	
/=
    /**
     * Instead of declaring classes implementing Statement, PreparedStatement,
     * and CallableStatement, which would have to be updated for every JDK rev,
     * use a dynamic proxy to handle all calls through the Statement
     * interfaces. This is the part that requires JDK 1.3 or higher, though
     * JDK 1.2 could be supported with a 3rd-party proxy package.
     *
     * The StatementHandler is required in order to return the proper
     * Connection proxy for the getConnection method.
     */
    private class StatementHandler implements InvocationHandler {
        private ConnectionHandler con;
        private Statement st;

        public StatementHandler(ConnectionHandler con, Statement st) {
            this.con = con;
            this.st = st;
        }
        public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable
        {
            // Delegate the call to the proxied Statement.
            try
            {
                return method.invoke(st, args);
/...
/t,
org.postgresql.xa.PGXAConnection$ConnectionHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 178	
/=
    /*
     * A java.sql.Connection proxy class to forbid calls to transaction
     * control methods while the connection is used for an XA transaction.
     */
    private class ConnectionHandler implements InvocationHandler
    {
		private Connection con;

        public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable
        {
                return method.invoke(con, args);	

/ net zo als StatementHandler,
...
/t,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7(org.jboss.jca.adapters.jdbc.WrappedConnection).prepareStatement(java.lang.String) line: 454	
            return wrapPreparedStatement(mc.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                                                             ResultSet.CONCUR_READ_ONLY),
                                         spy, jndiName, doLocking);
/pd,
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7.wrapPreparedStatement(java.sql.PreparedStatement, boolean, java.lang.String, boolean) line: 82
      return new WrappedPreparedStatementJDK7(this, statement, spy, jndiName, doLocking);
	
statement	com.sun.proxy.$Proxy91  (id=33224)	
	h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=33218)	
		con	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$ConnectionHandler  (id=22587)	
		st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=32982)	
			preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=33164)	
			preparedQuery	org.postgresql.core.CachedQuery  (id=33160)	
				query	org.postgresql.core.v3.SimpleQuery  (id=33127)	
					nativeQuery	org.postgresql.core.NativeQuery  (id=33108)	
						bindPositions	(id=33105)	
						nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=33111)	
...
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1.doPrepare() line: 87	
/=
	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
		return new StatementPreparationTemplate( sql ) {
			@Override
			protected PreparedStatement doPrepare() throws SQLException {
				return isCallable
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
			}
		};
/d,
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1(org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 173	
					preparedStatement = doPrepare();
/d,
preparedStatement	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=33672)	
	lc	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=32779)	
		statements	java.util.HashMap<K,V>  (id=33675)	
					key	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=33672)	
					value	null	
		h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=33218)	

				postProcess( preparedStatement );
/s,
		public void postProcess(PreparedStatement preparedStatement) throws SQLException {
			jdbcCoordinator.getResourceRegistry().register( preparedStatement, true );
/ TODO
this	org.hibernate.engine.jdbc.internal.StatementPreparerImpl$1  (id=30075)	
	sql	"insert into Language (name, version, id) values (?, ?, ?)" (id=30005)	
	this$0	org.hibernate.engine.jdbc.internal.StatementPreparerImpl  (id=22456)	
		jdbcCoordinator	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=22428)	
			logicalConnection	org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl  (id=22454)	
				physicalConnection	org.jboss.jca.adapters.jdbc.jdk7.WrappedConnectionJDK7  (id=32779)	
				resourceRegistry	org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl  (id=22464)	
					lastQuery	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=33672)	
					xref	java.util.HashMap<K,V>  (id=30285)	{org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@17ae1a72=null}
/t,
org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareStatement(java.lang.String, boolean) line: 78	
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
/d,
/t,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).buildBatchStatement(java.lang.String, boolean) line: 136	
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/d,
/t,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch(org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl).getBatchStatement(java.lang.String, boolean) line: 125	
			statement = buildBatchStatement( sql, callable );
/d,
			statements.put( sql, statement );
{insert into Language (name, version, id) values (?, ?, ?)=org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@17ae1a72}
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2888	
			if ( useBatch ) {
				insert = session
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
			}
/d,
				// Write the values of fields onto the prepared statement - we MUST use the state at the time the
				// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
id=143
fields=[Java,0]
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=27388)	
	propertyColumnInsertable	(id=33944)	[[true],[true]]
insert org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@17ae1a72
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2602	
/=
	/**
	 * Marshall the fields of a persistent instance to a prepared statement
	 */
	protected int dehydrate(
			final Serializable id,
			final Object[] fields,
			final Object rowId,
			final boolean[] includeProperty,
			final boolean[][] includeColumns,
			final int j,
			final PreparedStatement ps,
			final SessionImplementor session,
			int index,
			boolean isUpdate) throws SQLException, HibernateException {

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i ) ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/s,
org.hibernate.type.StringType(org.hibernate.type.AbstractStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, org.hibernate.type.descriptor.WrapperOptions) line: 257	
value="Java"
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/s,
	protected SqlTypeDescriptor remapSqlTypeDescriptor(WrapperOptions options) {
		return options.remapSqlTypeDescriptor( sqlTypeDescriptor );
		
this	org.hibernate.type.StringType  (id=21844)	
	javaTypeDescriptor	org.hibernate.type.descriptor.java.StringTypeDescriptor  (id=21895)	
		type	java.lang.Class<T> (java.lang.String) (id=19245)	
	sqlTypeDescriptor	org.hibernate.type.descriptor.sql.VarcharTypeDescriptor  (id=21896)	
/s,
org.hibernate.internal.WrapperOptionsImpl.remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 43	
		final SqlTypeDescriptor remapped = sqlTypeDescriptor.canBeRemapped()
true
				? session.getFactory().getDialect().remapSqlTypeDescriptor( sqlTypeDescriptor ) / org.hibernate.dialect.PostgreSQLDialect
				: sqlTypeDescriptor;
/s,
org.hibernate.dialect.PostgreSQLDialect(org.hibernate.dialect.Dialect).remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 461	
		final SqlTypeDescriptor overridden = getSqlTypeDescriptorOverride( sqlTypeDescriptor.getSqlType() );
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor.getSqlType() line: 33	
		return Types.VARCHAR;
/t,
org.hibernate.dialect.PostgreSQLDialect(org.hibernate.dialect.Dialect).remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 462	
		final SqlTypeDescriptor overridden = getSqlTypeDescriptorOverride( sqlTypeDescriptor.getSqlType() );
/d,
null
/ Als h. hem niet overwrite, dan returns null,
		return overridden == null ? sqlTypeDescriptor : overridden;

/t,
org.hibernate.internal.WrapperOptionsImpl.remapSqlTypeDescriptor(org.hibernate.type.descriptor.sql.SqlTypeDescriptor) line: 46	
		final SqlTypeDescriptor remapped = sqlTypeDescriptor.canBeRemapped()
				? session.getFactory().getDialect().remapSqlTypeDescriptor( sqlTypeDescriptor )
				: sqlTypeDescriptor;
/d,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor@31adc701
/ onveranderd	,
		return remapped == null ? sqlTypeDescriptor : remapped;
/t,
org.hibernate.type.StringType(org.hibernate.type.AbstractStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, org.hibernate.type.descriptor.WrapperOptions) line: 257	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/pd,
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor.getBinder(org.hibernate.type.descriptor.java.JavaTypeDescriptor<X>) line: 43
/=
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {														<-
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );
			}
		};
	}	
javaTypeDescriptor	org.hibernate.type.descriptor.java.StringTypeDescriptor  (id=21895)	
/t,
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor$1(org.hibernate.type.descriptor.sql.BasicBinder<J>).bind(java.sql.PreparedStatement, J, int, org.hibernate.type.descriptor.WrapperOptions) line: 74	
			doBind( st, value, index, options );
/s,
org.hibernate.type.descriptor.sql.VarcharTypeDescriptor$1.doBind(java.sql.PreparedStatement, X, int, org.hibernate.type.descriptor.WrapperOptions) line: 46	
/=
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );								<-
			}
		};
	}		
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).setString(int, java.lang.String) line: 679	
            ps.setString(parameterIndex, value);
ps Pooled statement wrapping physical statement insert into Language (name, version, id) values (?, ?, ?)		, is een Proxy,		
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 406	
method=public abstract void java.sql.PreparedStatement.setString(int,java.lang.String) throws java.sql.SQLException	
            // Delegate the call to the proxied Statement.
            try
            {
                return method.invoke(st, args);
...
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).setString(int, java.lang.String) line: 1416	
        setString(parameterIndex, x, getStringType());
/s,
    private int getStringType() {
        return (connection.getStringVarcharFlag() ? Oid.VARCHAR : Oid.UNSPECIFIED);
/ import org.postgresql.core.Oid;

    }
/s,
org.postgresql.jdbc42.Jdbc42Connection(org.postgresql.jdbc2.AbstractJdbc2Connection).getStringVarcharFlag() line: 1296	
        return bindStringAsVarchar;
true
/t,
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).setString(int, java.lang.String, int) line: 1427	
        else
            bindString(parameterIndex, x, oid);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).bindString(int, java.lang.String, int) line: 2512	
        preparedParameters.setStringParameter( paramIndex, s, oid);
/s,
org.postgresql.core.v3.SimpleParameterList.setStringParameter(int, java.lang.String, int) line: 118	
        bind(index, value, oid, TEXT);
/s,
org.postgresql.core.v3.SimpleParameterList.bind(int, java.lang.Object, int, byte) line: 55	
        --index;
/ WAS 1	, NU 0
        encoded[index] = null;
        paramValues[index] = value ;	/ Java
        flags[index] = (byte) (direction(index) | IN | binary);	/ direction=&INOUT==3	, dus WH initial flags=[0,0,0] , dan flags[0]=0 en dan | IN==1 en | binary=0	, dus flags=[1,0,0]
        
        // If we are setting something to an UNSPECIFIED NULL, don't overwrite
        // our existing type for it.  We don't need the correct type info to
        // send this value, and we don't want to overwrite and require a
        // reparse.
        if (oid == Oid.UNSPECIFIED && paramTypes[index] != Oid.UNSPECIFIED && value == NULL_OBJECT)
            return;

        paramTypes[index] = oid; / 1043
...
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2610	
		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i ) ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/d,
				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
			}
		}
ps	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=33672)	
	ps	com.sun.proxy.$Proxy91  (id=33224)	
		h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=33218)	
			st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=32982)	
				preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=33164)	
					paramTypes	(id=33168)	
						[0]	1043				/ Oid.VARCHAR
						[1]	0	
						[2]	0	
					paramValues	java.lang.Object[3]  (id=33165)	
						[0]	"Java" (id=19819)	
						[1]	null	
						[2]	null	
					protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=22605)	
/ volgende,
		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i ) ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/s,
org.hibernate.type.IntegerType(org.hibernate.type.AbstractStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, org.hibernate.type.descriptor.WrapperOptions) line: 257	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/s,
org.hibernate.type.descriptor.sql.IntegerTypeDescriptor$1.doBind(java.sql.PreparedStatement, X, int, org.hibernate.type.descriptor.WrapperOptions) line: 46	
/=
	@Override
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setInt( index, javaTypeDescriptor.unwrap( value, Integer.class, options ) );
			}
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).setInt(int, int) line: 212	
            ps.setInt(parameterIndex, value);         
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 406	
            // Delegate the call to the proxied Statement.
            try
            {
                return method.invoke(st, args);
/ method=public abstract void java.sql.PreparedStatement.setInt(int,int) throws java.sql.SQLException
/s,
    /*
     * Set a parameter to a Java int value.  The driver converts this to
     * a SQL INTEGER value when it sends it to the database.
     *
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).setInt(int, int) line: 1316	
parameterIndex	2	
x	0	
        if (connection.binaryTransferSend(Oid.INT4)) {
/j,
            byte[] val = new byte[4];
            ByteConverter.int4(val, 0, x);
            bindBytes(parameterIndex, val, Oid.INT4);	/ parameterIndex==2
            return;														/ !
        }
        bindLiteral(parameterIndex, Integer.toString(x), Oid.INT4);

/s,
    public boolean binaryTransferSend(int oid) {
        return useBinarySendForOids.contains(oid);
    }			
/t,
/s,
    /**
     * Encodes a int value to the byte array.
     *
     * @param target The byte array to encode to.
     * @param idx The starting index in the byte array.
     * @param value The value to encode.
     */
    public static void int4(byte[] target, int idx, int value) {
        target[idx+0] = (byte) (value >>> 24);
        target[idx+1] = (byte) (value >>> 16);
        target[idx+2] = (byte) (value >>>  8);
        target[idx+3] = (byte) value;
    }
/ big endian zo te zien,
/ TODO
/t,
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).bindBytes(int, byte[], int) line: 2500	
        preparedParameters.setBinaryParameter(paramIndex, b, oid);
/s,
org.postgresql.core.v3.SimpleParameterList.setBinaryParameter(int, byte[], int) line: 122	
        bind(index, value, oid, BINARY);
/s,
org.postgresql.core.v3.SimpleParameterList.bind(int, java.lang.Object, int, byte) line: 55	
        --index;
1
        encoded[index] = null;
        paramValues[index] = value ; / [0, 0, 0, 0]	big endian repr van de int value,
        flags[index] = (byte) (direction(index) | IN | binary);	/ flags=[1,0,0] initial, dan direction=&INOUT=3, dus flags[1]=0 blijft, 	en dan | IN==1 en | binary==4	, dus flags=[1,5,0]	, 
        
        // If we are setting something to an UNSPECIFIED NULL, don't overwrite
        // our existing type for it.  We don't need the correct type info to
        // send this value, and we don't want to overwrite and require a
        // reparse.
        if (oid == Oid.UNSPECIFIED && paramTypes[index] != Oid.UNSPECIFIED && value == NULL_OBJECT)
            return;

        paramTypes[index] = oid; / 23==Oid.INT4
...
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2610	
		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i ) ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
/d,
ps	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=33672)	
		h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=33218)	
			st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=32982)	
				preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=33164)	
					paramTypes	(id=33168)	
						[0]	1043	
						[1]	23	
						[2]	0	
					paramValues	java.lang.Object[3]  (id=33165)	
						[0]	"Java" (id=19819)	
						[1]	(id=34204) [B@5cb90415==[0, 0, 0, 0]
						[2]	null	
/ geen volgende meer,
		if ( !isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );
		}
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrateId(java.io.Serializable, java.lang.Object, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int) line: 2647	
		else if ( id != null ) {
/j,
143
			getIdentifierType().nullSafeSet( ps, id, index, session );
/s,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).getIdentifierType() line: 4824	
		return entityMetamodel.getIdentifierProperty().getType();
/s,
org.hibernate.tuple.entity.EntityMetamodel.getIdentifierProperty() line: 899	
		return identifierAttribute;
this	org.hibernate.tuple.entity.EntityMetamodel  (id=28974)	
	identifierAttribute	org.hibernate.tuple.IdentifierProperty  (id=28975)	
		attributeName	"id" (id=21339)	
		attributeType	org.hibernate.type.LongType  (id=28977)	
/t,
/s,
org.hibernate.type.LongType(org.hibernate.type.AbstractStandardBasicType<T>).nullSafeSet(java.sql.PreparedStatement, java.lang.Object, int, org.hibernate.type.descriptor.WrapperOptions) line: 257	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/s,
	protected SqlTypeDescriptor remapSqlTypeDescriptor(WrapperOptions options) {
		return options.remapSqlTypeDescriptor( sqlTypeDescriptor ); 
/ sqlTypeDescriptor=org.hibernate.type.descriptor.sql.BigIntTypeDescriptor@3ed3a3b5
/t,
/s,
org.hibernate.type.descriptor.sql.BigIntTypeDescriptor$1.doBind(java.sql.PreparedStatement, X, int, org.hibernate.type.descriptor.WrapperOptions) line: 46	
/=
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setLong( index, javaTypeDescriptor.unwrap( value, Long.class, options ) );
			}
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).setLong(int, long) line: 243	
            ps.setLong(parameterIndex, value);         
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 453	
                return method.invoke(st, args);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).setLong(int, long) line: 1336	
        if (connection.binaryTransferSend(Oid.INT8)) {
            byte[] val = new byte[8];
            ByteConverter.int8(val, 0, x);
            bindBytes(parameterIndex, val, Oid.INT8);
            return;
        }
/s,
org.postgresql.util.ByteConverter.int8(byte[], int, long) line: 98	
        target[idx+0] = (byte) (value >>> 56);
        target[idx+1] = (byte) (value >>> 48);
        target[idx+2] = (byte) (value >>> 40);
        target[idx+3] = (byte) (value >>> 32);
        target[idx+4] = (byte) (value >>> 24);
        target[idx+5] = (byte) (value >>> 16);
        target[idx+6] = (byte) (value >>>  8);
        target[idx+7] = (byte) value;
    }
/ big endian,
/t,
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).bindBytes(int, byte[], int) line: 2502	
        preparedParameters.setBinaryParameter(paramIndex, b, oid);
/s,
org.postgresql.core.v3.SimpleParameterList.setBinaryParameter(int, byte[], int) line: 122	
        bind(index, value, oid, BINARY);
/s,
org.postgresql.core.v3.SimpleParameterList.bind(int, java.lang.Object, int, byte) line: 55	
        --index;
/ WAS 3, NU 2	,
        encoded[index] = null;
        paramValues[index] = value ; / [0, 0, 0, 0, 0, 0, 0, -113]
        flags[index] = (byte) (direction(index) | IN | binary);	/ flags=[1,5,0] initial, direction=&INOUT==3, dus flags[2]=0, dan | IN==1 en | binary==4, dus flags=[1,5,5]
        
        // If we are setting something to an UNSPECIFIED NULL, don't overwrite
        // our existing type for it.  We don't need the correct type info to
        // send this value, and we don't want to overwrite and require a
        // reparse.
        if (oid == Oid.UNSPECIFIED && paramTypes[index] != Oid.UNSPECIFIED && value == NULL_OBJECT)
            return;

        paramTypes[index] = oid;	/ Oid.INT8==20
...
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrateId(java.io.Serializable, java.lang.Object, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int) line: 2648	
		else if ( id != null ) {
			getIdentifierType().nullSafeSet( ps, id, index, session );
/d,
			return getIdentifierColumnSpan();	/= 1
		}
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).dehydrate(java.io.Serializable, java.lang.Object[], java.lang.Object, boolean[], boolean[][], int, java.sql.PreparedStatement, org.hibernate.engine.spi.SessionImplementor, int, boolean) line: 2621	
		if ( !isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );
		}
/d,
ps	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7  (id=33672)	
	ps	com.sun.proxy.$Proxy91  (id=33224)	
		h	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler  (id=33218)	
			st	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=32982)	
				preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=33164)	
					paramTypes	(id=33168)	
						[0]	1043	
						[1]	23	
						[2]	20	
					paramValues	java.lang.Object[3]  (id=33165)	
						[0]	"Java" (id=19819)	
						[1]	(id=34204)	
						[2]	(id=34515)	[0, 0, 0, 0, 0, 0, 0, -113]

		return index;
4
/t,
org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2896
	
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/d,
				if ( useBatch ) {
					session.getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
					
this	org.hibernate.persister.entity.SingleTableEntityPersister  (id=27388)	
	inserBatchKey	org.hibernate.engine.jdbc.batch.internal.BasicBatchKey  (id=30026)	
		comparison	"domain.Language#INSERT" (id=30025)	
		expectation	org.hibernate.jdbc.Expectations$BasicExpectation  (id=30018)	
		statementCount	1	
session	org.hibernate.internal.SessionImpl  (id=22407)	
	jdbcCoordinator	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl  (id=22428)	
		currentBatch	org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch  (id=30069)	
			statements	java.util.LinkedHashMap<K,V>  (id=30070)	
{insert into Language (name, version, id) values (?, ?, ?)=org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@17ae1a72}

/s,
org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch() line: 44	
		for ( Map.Entry<String,PreparedStatement> entry : getStatements().entrySet() ) {
			try {
				final PreparedStatement statement = entry.getValue(); / org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7@17ae1a72
				final int rowCount = jdbcCoordinator.getResultSetReturn().executeUpdate( statement );
/s,
org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(java.sql.PreparedStatement) line: 203	
			return statement.executeUpdate();
/s,
org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeUpdate() line: 528	
      try
      {
         checkTransaction();
            return ps.executeUpdate();
/ Pooled statement wrapping physical statement insert into Language (name, version, id) values ('Java', 0, 152) Proxy,			
/s,
org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 406	
            // Delegate the call to the proxied Statement.
            try
            {
                return method.invoke(st, args);
public abstract int java.sql.PreparedStatement.executeUpdate() throws java.sql.SQLException
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeUpdate() line: 405
	
        executeWithFlags(QueryExecutor.QUERY_NO_RESULTS);
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 465	
        execute(preparedQuery.query, preparedParameters, flags);

this	org.postgresql.jdbc42.Jdbc42PreparedStatement  (id=23197)	
	preparedQuery	org.postgresql.core.CachedQuery  (id=23204)	
		query	org.postgresql.core.v3.SimpleQuery  (id=23207)	/ insert into Language (name, version, id) values (?, ?, ?)  TODO
			nativeQuery	org.postgresql.core.NativeQuery  (id=23220)	
				bindPositions	(id=23235)	
				nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=23236)	
			protoConnection	org.postgresql.core.v3.ProtocolConnectionImpl  (id=23222)	
	preparedParameters	org.postgresql.core.v3.SimpleParameterList  (id=23210)	
		paramTypes	(id=23265)	
			[0]	1043	
			[1]	23	
			[2]	20	
		paramValues	java.lang.Object[3]  (id=23267)	
			[0]	"Java" (id=23270)	
			[1]	(id=23271)	[0, 0, 0, 0]	/ version
			[2]	(id=23272)	[0, 0, 0, 0, 0, 0, 0, -104]	/ id,
/s,
org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 562	

        // Only use named statements after we hit the threshold. Note that only
        // named statements can be transferred in binary format.
        if (preparedQuery != null && preparedQuery.query == queryToExecute)
        {
            preparedQuery.increaseExecuteCount();
            if ((m_prepareThreshold == 0 || preparedQuery.getExecuteCount() < m_prepareThreshold) && !forceBinaryTransfers)
                flags |= QueryExecutor.QUERY_ONESHOT;
        }

        if (connection.getAutoCommit())
            flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;
            if ((m_prepareThreshold == 0 || preparedQuery.getExecuteCount() < m_prepareThreshold) && !forceBinaryTransfers)	/ TODO
                flags |= QueryExecutor.QUERY_ONESHOT;
        }

        if (connection.getAutoCommit()) / org.postgresql.jdbc42.Jdbc42Connection  (id=23209)	
/n,
            flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;
/ TODO
        // updateable result sets do not yet support binary updates
        if (concurrency != ResultSet.CONCUR_READ_ONLY)
/n,
            flags |= QueryExecutor.QUERY_NO_BINARY_TRANSFER;

        if (queryToExecute.isEmpty())
/n,
        {
            flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;
        }

        if (!queryToExecute.isStatementDescribed() / !false==true
/ TODO
			&& forceBinaryTransfers) {	/ false
/n,
                int flags2 = flags | QueryExecutor.QUERY_DESCRIBE_ONLY;
                StatementResultHandler handler2 = new StatementResultHandler();
                connection.getQueryExecutor().execute(queryToExecute, queryParameters, handler2, 0, 0, flags2);
                ResultWrapper result2 = handler2.getResults();
                if (result2 != null) {
                    result2.getResultSet().close();
                }
        }
        StatementResultHandler handler = new StatementResultHandler();
        result = null;
        try
        {
            startTimer();	/ NIETS, want timeout==null	,
            connection.getQueryExecutor().execute(queryToExecute,
                                                  queryParameters,
                                                  handler,
                                                  maxrows,
                                                  fetchSize,
                                                  flags);
        }									 
/s,
    public QueryExecutor getQueryExecutor() {
        return protoConnection.getQueryExecutor();
    }										 
/s,
org.postgresql.core.v3.ProtocolConnectionImpl.getQueryExecutor() line: 87	
        return executor;
/t,
/s,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 147	
        try
        {
            try
            {
                handler = sendQueryPreamble(handler, flags);
                ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
                sendSync();
                processResults(handler, flags);
                estimatedReceiveBufferBytes = 0;
            }									 
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendQueryPreamble(org.postgresql.core.ResultHandler, int) line: 359	

        // Send BEGIN on first statement in transaction.
        if ((flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) != 0 ||
/ ?
                protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE)	/ TRANSACTION_OPEN
/j,
            return delegateHandler;
/t,
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendQuery(org.postgresql.core.v3.V3Query, org.postgresql.core.v3.V3ParameterList, int, int, int, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler) line: 1116	
										 
        if (subqueries == null)
        {
            flushIfDeadlockRisk(query, disallowBatching, trackingHandler, flags);
/ DOET NIETS,
/s,
org.postgresql.core.v3.QueryExecutorImpl.flushIfDeadlockRisk(org.postgresql.core.Query, boolean, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler, int) line: 1070	
/=
    /*
     * To prevent client/server protocol deadlocks, we try to manage the
     * estimated recv buffer size and force a sync +flush and process results if
     * we think it might be getting too full.
     *
     * See the comments above MAX_BUFFERED_RECV_BYTES's declaration for details.
     */
    private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
            ErrorTrackingResultHandler trackingHandler, final int flags)
            throws IOException {
        // Assume all statements need at least this much reply buffer space,
        // plus params
        estimatedReceiveBufferBytes += NODATA_QUERY_RESPONSE_SIZE_BYTES;
250
        SimpleQuery sq = (SimpleQuery) query;
        if (sq.isStatementDescribed()) {
/n,
        if (disallowBatching
                || estimatedReceiveBufferBytes >= MAX_BUFFERED_RECV_BYTES) {
/n,
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendQuery(org.postgresql.core.v3.V3Query, org.postgresql.core.v3.V3ParameterList, int, int, int, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler) line: 1130	
            flushIfDeadlockRisk(query, disallowBatching, trackingHandler, flags);
/d,
             // If we saw errors, don't send anything more.
            if (!trackingHandler.hasErrors())
/j,
                sendOneQuery((SimpleQuery)query, (SimpleParameterList)parameters, maxRows, fetchSize, flags);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1519	
/=
    // sendOneQuery sends a single statement via the extended query protocol.
    // Per the FE/BE docs this is essentially the same as how a simple query runs
    // (except that it generates some extra acknowledgement messages, and we
    // can send several queries before doing the Sync)
    //
    //   Parse     S_n from "query string with parameter placeholders"; skipped if already done previously or if oneshot
    //   Bind      C_n from S_n plus parameters (or from unnamed statement for oneshot queries)
    //   Describe  C_n; skipped if caller doesn't want metadata
    //   Execute   C_n with maxRows limit; maxRows = 1 if caller doesn't want results
    // (above repeats once per call to sendOneQuery)
    //   Sync      (sent by caller)
    //
    private void sendOneQuery(SimpleQuery query, SimpleParameterList params, int maxRows, int fetchSize, int flags) throws IOException {
        // nb: if we decide to use a portal (usePortal == true) we must also use a named statement
        // (oneShot == false) as otherwise the portal will be closed under us unexpectedly when
        // the unnamed statement is next reused.


/ Intermezzo

/ lees,
https://www.postgresql.org/docs/9.6/static/protocol.html
Chapter 51. Frontend/Backend Protocol
/ ihb
https://www.postgresql.org/docs/9.6/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
51.2.3. Extended Query

/ lees,
https://www.postgresql.org/docs/9.6/static/plpgsql-cursors.html
FETCH [ direction { FROM | IN } ] cursor INTO target;
cursor must be the name of a refcursor variable that references an open cursor portal.

/ Einde Intermezzo

/ Intermezzo

public abstract class AbstractJdbc2Statement implements BaseStatement

    /** Maximum number of rows to return, 0 = unlimited */
    protected int maxrows = 0;

    /** Number of rows to get in a batch. */
    protected int fetchSize = 0;

    /** Timeout (in seconds) for a query */
    protected int timeout = 0;



/ Einde Intermezzo	


flags=4
        boolean noResults = (flags & QueryExecutor.QUERY_NO_RESULTS) != 0;
true
        boolean noMeta = (flags & QueryExecutor.QUERY_NO_METADATA) != 0;
false
        boolean describeOnly = (flags & QueryExecutor.QUERY_DESCRIBE_ONLY) != 0;
false
        boolean usePortal = (flags & QueryExecutor.QUERY_FORWARD_CURSOR) != 0 && !noResults && !noMeta && fetchSize > 0 && !describeOnly;
false
        boolean oneShot = (flags & QueryExecutor.QUERY_ONESHOT) != 0 && !usePortal;
false
        boolean noBinaryTransfer = (flags & QUERY_NO_BINARY_TRANSFER) != 0;
false
        boolean forceDescribePortal = (flags & QUERY_FORCE_DESCRIBE_PORTAL) != 0;
false

        int rows;
        if (noResults)
        {
            rows = 1;             // We're discarding any results anyway, so limit data transfer to a minimum
        }

        sendParse(query, params, oneShot);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendParse(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, boolean) line: 1175	
        // Already parsed, or we have a Parse pending and the types are right?
        int[] typeOIDs = params.getTypeOIDs();	/= params.paramTypes
[1043, 23, 20]
        if (query.isPreparedFor(typeOIDs))	/= query.preparedTypes==params.paramTypes==[1043,23,20]
/ja,
            return;
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1552	
        sendParse(query, params, oneShot);	/ WH met $i ipv ? TODO
/d,
        sendBind(query, params, portal, noBinaryTransfer);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendBind(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, org.postgresql.core.v3.Portal, boolean) line: 1255	
        String statementName = query.getStatementName();	/ S_7
        byte[] encodedStatementName = query.getEncodedStatementName(); / [83, 95, 55]
        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName()); / null
		
params=[Java, [B@2e723e4a, [B@54b61921]=["Java", [0,0,0,0],[0,0,0,0,0,0,0,-131]]



        // Total size = 4 (size field) + N + 1 (destination portal)
        //            + N + 1 (statement name)
        //            + 2 (param format code count) + N * 2 (format codes)
        //            + 2 (param value count) + N (encoded param value size)
        //            + 2 (result format code count, 0)
        long encodedSize = 0;
        for (int i = 1; i <= params.getParameterCount(); ++i)
        {
            if (params.isNull(i))
                encodedSize += 4;
            else
                encodedSize += (long)4 + params.getV3Length(i);
        }
/s,
org.postgresql.core.v3.SimpleParameterList.getV3Length(int) line: 319	
        // Already encoded?
        if (encoded[index] == null)
        {
            // Encode value and compute actual length using UTF-8.
            encoded[index] = Utils.encodeUTF8(paramValues[index].toString());
        }
/s,
org.postgresql.core.Utils.encodeUTF8(java.lang.String) line: 62	
/=
    private final static Charset utf8Charset = Charset.forName("UTF-8");

    /**
     * Encode a string as UTF-8.
     *
     * @param str the string to encode
     * @return the UTF-8 representation of <code>str</code>
     */
    public static byte[] encodeUTF8(String str) {
        // See org.postgresql.benchmark.encoding.UTF8Encoding#string_getBytes
        // for performance measurements.
        // In OracleJDK 6u65, 7u55, and 8u40 String.getBytes(Charset) is
        // 3 times faster than other JDK approaches.
        return str.getBytes(utf8Charset);
    }
/t,
org.postgresql.core.v3.SimpleParameterList.getV3Length(int) line: 322	
        // Already encoded?
        if (encoded[index] == null)	/ nog niet encoded,
        {
            // Encode value and compute actual length using UTF-8.
            encoded[index] = Utils.encodeUTF8(paramValues[index].toString());
        }
/d,
encoded=[[74, 97, 118, 97], null, null]
        return encoded[index].length;	/ nu is wel of al encoded,
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendBind(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, org.postgresql.core.v3.Portal, boolean) line: 1275	
        for (int i = 1; i <= params.getParameterCount(); ++i)
        {
            if (params.isNull(i))
                encodedSize += 4;
            else
                encodedSize += (long)4 + params.getV3Length(i);
        }
/d,
/ volgende,
/s,
org.postgresql.core.v3.SimpleParameterList.getV3Length(int) line: 309	
       --index;

         // Directly encoded?
        if (paramValues[index] instanceof byte[])
            return ((byte[]) paramValues[index]).length;
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendBind(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, org.postgresql.core.v3.Portal, boolean) line: 1275	
        for (int i = 1; i <= params.getParameterCount(); ++i)
        {
            if (params.isNull(i))
                encodedSize += 4;
            else
                encodedSize += (long)4 + params.getV3Length(i);
        }
/d,
28=4+4 + 4+4 + 4+8
/ TODO
        Field[] fields = query.getFields();
null
/ TODO

/ Intermezzo

class SimpleQuery implements V3Query {

    /**
     * Returns the fields that this query will return. If the result set fields
     * are not known returns null.
     *
     * @return the fields that this query will return.
     */
    Field[] getFields() {
        return fields;
    }

    /**
     * The stored fields from previous execution or describe of a prepared 
     * statement. Always null for non-prepared statements.
     */
    private Field[] fields;
    private boolean needUpdateFieldFormats;
    private boolean hasBinaryFields;
    private boolean portalDescribed;
    private boolean statementDescribed;


/ Einde Intermezzo

        // This is not the number of binary fields, but the total number
        // of fields if any of them are binary or zero if all of them
        // are text.
        int numBinaryFields = !noBinaryTransfer && query.hasBinaryFields() ? fields.length : 0;
0
        encodedSize = 4
                      + (encodedPortalName == null ? 0 : encodedPortalName.length) + 1	
                      + (encodedStatementName == null ? 0 : encodedStatementName.length) + 1 	/ [83, 95, 55] = S_7
                      + 2 + params.getParameterCount() * 2
                      + 2 + encodedSize
                      + 2 + numBinaryFields * 2;
49=4+(0+1)+(3+1)+(2+3*2)+(2+28)+(2+0)


        pgStream.SendChar('B');                  // Bind
        pgStream.SendInteger4((int)encodedSize);      // Message size
        if (encodedPortalName != null)
/n,
            pgStream.Send(encodedPortalName);    // Destination portal name.
        pgStream.SendChar(0);                    // End of portal name.
        if (encodedStatementName != null)
/j,
            pgStream.Send(encodedStatementName); // Source statement name.
        pgStream.SendChar(0);                    // End of statement name.

        pgStream.SendInteger2(params.getParameterCount());      // # of parameter format codes
        for (int i = 1; i <= params.getParameterCount(); ++i)
            pgStream.SendInteger2(params.isBinary(i) ? 1 : 0);  // Parameter format code
/j, 2de en 3de 

        pgStream.SendInteger2(params.getParameterCount());      // # of parameter values
		
		        // If an error occurs when reading a stream we have to
        // continue pumping out data to match the length we
        // said we would.  Once we've done that we throw
        // this exception.  Multiple exceptions can occur and
        // it really doesn't matter which one is reported back
        // to the caller.
        //
        PGBindException bindException = null;

params	org.postgresql.core.v3.SimpleParameterList  (id=23210)	
	encoded	(id=23263)	
		[0]	(id=23334)	/ [74, 97, 118, 97]
		[1]	null								/ binary data is niet encoded,
		[2]	null	
	paramValues	java.lang.Object[3]  (id=23267)	
		[0]	"Java" (id=23270)	
		[1]	(id=23271)	
		[2]	(id=23272)	
		


        for (int i = 1; i <= params.getParameterCount(); ++i)
        {
            if (params.isNull(i))
                pgStream.SendInteger4( -1);                      // Magic size of -1 means NULL
            else
            {
                pgStream.SendInteger4(params.getV3Length(i));   // Parameter size
                try
                {
                    params.writeV3Value(i, pgStream);                 // Parameter value
                }
                catch (PGBindException be)
                {
                    bindException = be;
                }
            }
        }

        pgStream.SendInteger2(numBinaryFields);   // # of result format codes
        for (int i = 0; i < numBinaryFields; ++i) {
            pgStream.SendInteger2(fields[i].getFormat());
        }

        pendingBindQueue.add(portal == null ? UNNAMED_PORTAL : portal);

        if (bindException != null)
        {
            throw bindException;
        }
/s,
org.postgresql.core.PGStream.SendChar(int) line: 193
	        pg_output.write(val);
/t,
/s,
org.postgresql.core.PGStream.SendInteger4(int) line: 193	
        _int4buf[0] = (byte)(val >>> 24);
        _int4buf[1] = (byte)(val >>> 16);
        _int4buf[2] = (byte)(val >>> 8);
        _int4buf[3] = (byte)(val);
        pg_output.write(_int4buf);
/t,
/s,
org.postgresql.core.v3.SimpleParameterList.isBinary(int) line: 293	
        return (flags[index-1] & BINARY) != 0;
/t,
/s,
org.postgresql.core.v3.SimpleParameterList.getV3Length(int) line: 322

        // Directly encoded?
        if (paramValues[index] instanceof byte[])			/ index=1,2	, is al binary data,
            return ((byte[]) paramValues[index]).length;
	
        // Already encoded?
        if (encoded[index] == null) 	/ nog niet encoded,
        {
            // Encode value and compute actual length using UTF-8.
            encoded[index] = Utils.encodeUTF8(paramValues[index].toString());
        }

        return encoded[index].length;	/ nu wel of al encoded,	/ index=0	, 
/t,
/s,
org.postgresql.core.v3.SimpleParameterList.writeV3Value(int, org.postgresql.core.PGStream) line: 349

        // Directly encoded?						/ index=1,2 is al binary data,
        if (paramValues[index] instanceof byte[])
        {
            pgStream.Send((byte[])paramValues[index]);
            return ;
        }	
        // Encoded string.
        if (encoded[index] == null) / index=0, is al eerder encoded, 
            encoded[index] = Utils.encodeUTF8((String) paramValues[index]);
        pgStream.Send(encoded[index]);				/ index=0
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendBind(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, org.postgresql.core.v3.Portal, boolean) line: 1358	
        for (int i = 1; i <= params.getParameterCount(); ++i)
        {
            if (params.isNull(i))
                pgStream.SendInteger4( -1);                      // Magic size of -1 means NULL
            else
            {
                pgStream.SendInteger4(params.getV3Length(i));   // Parameter size
                try
                {
                    params.writeV3Value(i, pgStream);                 // Parameter value
                }
                catch (PGBindException be)
                {
                    bindException = be;
                }
            }
        }
/d,
        pgStream.SendInteger2(numBinaryFields);   // # of result format codes
0
        for (int i = 0; i < numBinaryFields; ++i) {
            pgStream.SendInteger2(fields[i].getFormat());
        }

        pendingBindQueue.add(portal == null ? UNNAMED_PORTAL : portal);	/ null
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1590	

/ Intermezzo

/ bij gen id deed hij .executeQuery	, en dat gaat heel anders als .executeUpdate, met bind, ...

/ gen id,
						? connection().prepareCall( sql )
						: connection().prepareStatement( sql );
/s,
                    transfer.writeInt(SessionRemote.SESSION_PREPARE_READ_PARAMS).writeInt(id).writeString(sql); 
/ sql = call next val-ue for hibernate_sequence

            ResultSet resultSet = ps.executeQuery();
/s,
                    transfer.writeInt(SessionRemote.COMMAND_EXECUTE_QUERY).writeInt(id).writeInt(objectId).writeInt(
                            maxRows);
/ id=5 klopt, net als bij prepare, objectId=6 TODO

            ResultSet resultSet = ps.executeQuery();
/d,
20940:
resultSet	org.h2.jdbc.JdbcResultSet  (id=20578)	
	result	org.h2.result.ResultRemote  (id=20571)	
		columns	org.h2.result.ResultColumn[1]  (id=20574)	
			[0]	org.h2.result.ResultColumn  (id=20572)	
				columnName	"NEXT VALUE FOR PUBLIC.HIBERNATE_SEQUENCE" (id=20617)	
				columnType	5	
		result	java.util.ArrayList<E>  (id=20573)	
			elementData	java.lang.Object[4]  (id=20620)	
				[0]	org.h2.value.Value[1]  (id=20622)	
					[0]	org.h2.value.ValueLong  (id=20577)	
						value	160
/ 13	. 

/ insert (met deze gen id)	,

/ met ps.executeUpdate()	,

/ we zijn nog in .executeUpdate,

Thread [default task-9] (Suspended)	
	owns: org.postgresql.core.v3.QueryExecutorImpl  (id=23306)	
	owns: java.lang.Object  (id=22162)	
	org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1590	
	org.postgresql.core.v3.QueryExecutorImpl.sendQuery(org.postgresql.core.v3.V3Query, org.postgresql.core.v3.V3ParameterList, int, int, int, org.postgresql.core.v3.QueryExecutorImpl$ErrorTrackingResultHandler) line: 1130	
	org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 171	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, int) line: 615	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeWithFlags(int) line: 465	
	org.postgresql.jdbc42.Jdbc42PreparedStatement(org.postgresql.jdbc2.AbstractJdbc2Statement).executeUpdate() line: 411	
	sun.reflect.GeneratedMethodAccessor51.invoke(java.lang.Object, java.lang.Object[]) line: not available	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.postgresql.ds.jdbc23.AbstractJdbc23PooledConnection$StatementHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 453	
	com.sun.proxy.$Proxy91.executeUpdate() line: not available	
	org.jboss.jca.adapters.jdbc.jdk7.WrappedPreparedStatementJDK7(org.jboss.jca.adapters.jdbc.WrappedPreparedStatement).executeUpdate() line: 537	
	org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(java.sql.PreparedStatement) line: 204	
	org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch() line: 45	
	org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], boolean[], int, java.lang.String, java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 2897	
	org.hibernate.persister.entity.SingleTableEntityPersister(org.hibernate.persister.entity.AbstractEntityPersister).insert(java.io.Serializable, java.lang.Object[], java.lang.Object, org.hibernate.engine.spi.SessionImplementor) line: 3397	
	org.hibernate.action.internal.EntityInsertAction.execute() line: 89	
	org.hibernate.engine.spi.ActionQueue.executeActions(org.hibernate.engine.spi.ExecutableList<E>) line: 582	
	org.hibernate.engine.spi.ActionQueue.executeActions() line: 456	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.AbstractFlushingEventListener).performExecutions(org.hibernate.event.spi.EventSource) line: 337	
	org.hibernate.jpa.event.internal.core.JpaFlushEventListener(org.hibernate.event.internal.DefaultFlushEventListener).onFlush(org.hibernate.event.spi.FlushEvent) line: 39	
	org.hibernate.internal.SessionImpl.flush() line: 1282	
	org.hibernate.internal.SessionImpl.managedFlush() line: 465	
	org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion() line: 2963	
	org.hibernate.internal.SessionImpl.beforeTransactionCompletion() line: 2339	
	org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.beforeTransactionCompletion() line: 485	
	org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl.beforeCompletion() line: 316	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl(org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl).beforeCompletion() line: 47	
	org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization.beforeCompletion() line: 37	
	org.jboss.as.txn.service.internal.tsr.JCAOrderedLastSynchronizationList.beforeCompletion() line: 116	
	com.arjuna.ats.internal.jta.resources.arjunacore.SynchronizationImple.beforeCompletion() line: 76	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).beforeCompletion() line: 368	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator).end(boolean) line: 91	
	com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction(com.arjuna.ats.arjuna.AtomicAction).commit(boolean) line: 162	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.commitAndDisassociate() line: 1200	
	com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple(com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction).commit() line: 126	
	com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate(com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate).commit() line: 89	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.endTransaction(javax.transaction.TransactionManager, javax.transaction.Transaction) line: 91	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.invokeInOurTx(org.jboss.invocation.InterceptorContext, javax.transaction.TransactionManager, org.jboss.as.ejb3.component.EJBComponent) line: 279	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.required(org.jboss.invocation.InterceptorContext, org.jboss.as.ejb3.component.EJBComponent, int) line: 327	
	org.jboss.as.ejb3.tx.CMTTxInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 239	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.CurrentInvocationContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 41	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.invocationmetrics.WaitTimeInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 47	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.security.SecurityContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 100	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.deployment.processors.StartupAwaitInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 22	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 67	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 50	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 54	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 64	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedExceptionAction<T>) line: 636	
	org.jboss.invocation.AccessCheckingInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.InterceptorContext.run() line: 356	
	org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 80	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ViewService$View.invoke(org.jboss.invocation.InterceptorContext) line: 198	
	org.jboss.as.ee.component.ViewDescription$1.processInvocation(org.jboss.invocation.InterceptorContext) line: 185	
	org.jboss.invocation.InterceptorContext.proceed() line: 340	
	org.jboss.invocation.ChainedInterceptor.processInvocation(org.jboss.invocation.InterceptorContext) line: 61	
	org.jboss.as.ee.component.ProxyInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: 73	
	repository.LanguageDao$$$view12.insertInTx() line: not available	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.weld.util.reflection.Reflections.invokeAndUnwrap(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 433	
	org.jboss.weld.bean.proxy.EnterpriseBeanProxyMethodHandler<T>.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 128	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance(org.jboss.weld.bean.proxy.EnterpriseTargetBeanInstance).invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 56	
	org.jboss.weld.bean.proxy.InjectionPointPropagatingEnterpriseTargetBeanInstance.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object...) line: 67	
	org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object[]) line: 100	
	repository.LanguageDao$Proxy$_$$_Weld$EnterpriseProxy$.insertInTx() line: not available	
	repository.LanguageDaoTest.testInsertInTx() line: 78	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall() line: 50	
	org.junit.runners.model.FrameworkMethod$1(org.junit.internal.runners.model.ReflectiveCallable).run() line: 12	
	org.junit.runners.model.FrameworkMethod.invokeExplosively(java.lang.Object, java.lang.Object...) line: 47	
	org.jboss.arquillian.junit.Arquillian$8$1.invoke(java.lang.Object...) line: 379	
	org.jboss.arquillian.container.test.impl.execution.LocalTestExecuter.execute(org.jboss.arquillian.container.test.impl.execution.event.LocalExecutionEvent) line: 60	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.core.impl.EventImpl<T>.fire(T) line: 67	
	org.jboss.arquillian.container.test.impl.execution.ContainerTestExecuter.execute(org.jboss.arquillian.test.spi.event.suite.Test) line: 38	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(org.jboss.arquillian.test.spi.TestMethodExecutor) line: 136	
	org.jboss.arquillian.junit.Arquillian$8.evaluate() line: 372	
	org.jboss.arquillian.junit.Arquillian$4.evaluate() line: 246	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$5.evaluate() line: 260	
	org.jboss.arquillian.junit.Arquillian$7$1.invoke() line: 324	
	org.jboss.arquillian.container.test.impl.execution.BeforeLifecycleEventExecuter.on(org.jboss.arquillian.test.spi.event.suite.BeforeTestLifecycleEvent) line: 35	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.invokeObservers() line: 103	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 85	
	org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.TestEvent>) line: 130	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.ClassEvent>) line: 92	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(org.jboss.arquillian.core.spi.EventContext<org.jboss.arquillian.test.spi.event.suite.SuiteEvent>) line: 73	
	sun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [native method]	
	sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 62	
	sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: 43	
	java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: 498	
	org.jboss.arquillian.core.impl.ObserverImpl.invoke(org.jboss.arquillian.core.spi.Manager, java.lang.Object) line: 96	
	org.jboss.arquillian.core.impl.EventContextImpl<T>.proceed() line: 92	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(T, org.jboss.arquillian.core.spi.NonManagedObserver<T>) line: 143	
	org.jboss.arquillian.core.impl.ManagerImpl.fire(java.lang.Object) line: 114	
	org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.fireCustomLifecycle(T) line: 159	
	org.jboss.arquillian.junit.Arquillian$7.evaluate() line: 317	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runLeaf(org.junit.runners.model.Statement, org.junit.runner.Description, org.junit.runner.notification.RunNotifier) line: 325	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(org.junit.runners.model.FrameworkMethod, org.junit.runner.notification.RunNotifier) line: 78	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.BlockJUnit4ClassRunner).runChild(java.lang.Object, org.junit.runner.notification.RunNotifier) line: 57	
	org.junit.runners.ParentRunner$3.run() line: 290	
	org.junit.runners.ParentRunner$1.schedule(java.lang.Runnable) line: 71	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).runChildren(org.junit.runner.notification.RunNotifier) line: 288	
	org.junit.runners.ParentRunner<T>.access$000(org.junit.runners.ParentRunner, org.junit.runner.notification.RunNotifier) line: 58	
	org.junit.runners.ParentRunner$2.evaluate() line: 268	
	org.jboss.arquillian.junit.Arquillian$2.evaluate() line: 205	
	org.jboss.arquillian.junit.Arquillian.multiExecute(org.junit.runners.model.Statement...) line: 431	
	org.jboss.arquillian.junit.Arquillian.access$200(org.jboss.arquillian.junit.Arquillian, org.junit.runners.model.Statement[]) line: 55	
	org.jboss.arquillian.junit.Arquillian$3.evaluate() line: 219	
	org.jboss.arquillian.junit.Arquillian(org.junit.runners.ParentRunner<T>).run(org.junit.runner.notification.RunNotifier) line: 363	
	org.jboss.arquillian.junit.Arquillian.run(org.junit.runner.notification.RunNotifier) line: 167	
	org.junit.runner.JUnitCore.run(org.junit.runner.Runner) line: 137	
	org.junit.runner.JUnitCore.run(org.junit.runner.Request) line: 115	
	org.jboss.arquillian.junit.container.JUnitTestRunner.execute(java.lang.Class<?>, java.lang.String) line: 66	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.executeTest(javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String, java.lang.String) line: 170	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.execute(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 135	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 98	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: 687	
	org.jboss.arquillian.protocol.servlet.runner.ServletTestRunner(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: 790	
	io.undertow.servlet.handlers.ServletHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 85	
	io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 62	
	io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 36	
	org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 78	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 131	
	io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 57	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler(io.undertow.security.handlers.AbstractConfidentialityHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 46	
	io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 64	
	io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 60	
	io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 77	
	io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 50	
	io.undertow.security.handlers.SecurityInitialHandler(io.undertow.security.handlers.AbstractSecurityContextAssociationHandler).handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 61	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.server.handlers.PredicateHandler.handleRequest(io.undertow.server.HttpServerExchange) line: 43	
	io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 292	
	io.undertow.servlet.handlers.ServletInitialHandler.access$100(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext) line: 138	
	io.undertow.servlet.handlers.ServletInitialHandler$2.call(io.undertow.server.HttpServerExchange, java.lang.Object) line: 135	
	io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 48	
	io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(io.undertow.server.HttpServerExchange, C) line: 43	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.api.LegacyThreadSetupActionWrapper$1.call(io.undertow.server.HttpServerExchange, C) line: 44	
	io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 272	
	io.undertow.servlet.handlers.ServletInitialHandler.access$000(io.undertow.servlet.handlers.ServletInitialHandler, io.undertow.server.HttpServerExchange, io.undertow.servlet.handlers.ServletRequestContext, io.undertow.servlet.handlers.ServletChain, javax.servlet.DispatcherType) line: 81	
	io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(io.undertow.server.HttpServerExchange) line: 104	
	io.undertow.server.Connectors.executeRootHandler(io.undertow.server.HttpHandler, io.undertow.server.HttpServerExchange) line: 202	
	io.undertow.server.HttpServerExchange$1.run() line: 805	
	org.xnio.XnioWorker$TaskPool(java.util.concurrent.ThreadPoolExecutor).runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	java.lang.Thread.run() line: 748	


/ Einde Intermezzo

/s,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1590	
        sendBind(query, params, portal, noBinaryTransfer);
/d,
		if (!noMeta && !describeStatement) {
			/*
			 * don't send describe if we already have cached the row description
			 * from previous executions
			 * 
			 * XXX Clearing the fields / unpreparing the query (in sendParse) is
			 * incorrect, see bug #267. We might clear the cached fields in a
			 * later execution of this query if the bind parameter types change,
			 * but we're assuming here that they'll still be valid when we come
			 * to process the results of this query, so we don't send a new
			 * describe here. We re-describe after the fields are cleared, but
			 * the result of that gets processed after processing the results
			 * from earlier executions that we didn't describe because we didn't
			 * think we had to.
			 * 
			 * To work around this, force a Describe at each execution in
			 * batches where this can be a problem. It won't cause more round
			 * trips so the performance impact is low, and it'll ensure that the
			 * field information available when we decoded the results. This
			 * is undeniably a hack, but there aren't many good alternatives.
			 */
			if (query.getFields() == null || forceDescribePortal) {
				sendDescribePortal(query, portal);
			}
query	org.postgresql.core.v3.SimpleQuery  (id=23207)	/ insert into Language (name, version, id) values (?, ?, ?)
	fields	null	
	nativeQuery	org.postgresql.core.NativeQuery  (id=23220)	
		bindPositions	(id=23235)	
		nativeSql	"insert into Language (name, version, id) values ($1, $2, $3)" (id=23236)	
portal	null	
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendDescribePortal(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.Portal) line: 1389	

        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName());

        // Total size = 4 (size field) + 1 (describe type, 'P') + N + 1 (portal name)			/ van wat na 'D' komt,
        int encodedSize = 4 + 1 + (encodedPortalName == null ? 0 : encodedPortalName.length) + 1;
6
        pgStream.SendChar('D');               // Describe
        pgStream.SendInteger4(encodedSize); // message size
        pgStream.SendChar('P');               // Describe (Portal)
        if (encodedPortalName != null)
            pgStream.Send(encodedPortalName); // portal name to close
        pgStream.SendChar(0);                 // end of portal name

        pendingDescribePortalQueue.add(query);
        query.setPortalDescribed(true);
/t,
org.postgresql.core.v3.QueryExecutorImpl.sendOneQuery(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.SimpleParameterList, int, int, int) line: 1616	
        sendExecute(query, portal, rows);
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendExecute(org.postgresql.core.v3.SimpleQuery, org.postgresql.core.v3.Portal, int) line: 1441	
        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName());
        int encodedSize = (encodedPortalName == null ? 0 : encodedPortalName.length);
0
        // Total size = 4 (size field) + 1 + N (source portal) + 4 (max rows)	/ wat na 'E' komt,
        pgStream.SendChar('E');              // Execute
        pgStream.SendInteger4(4 + 1 + encodedSize + 4);  // message size
        if (encodedPortalName != null)
            pgStream.Send(encodedPortalName); // portal name
        pgStream.SendChar(0);                 // portal name terminator
        pgStream.SendInteger4(limit);       // row limit
1

        pendingExecuteQueue.add(new ExecuteRequest(query, portal));


/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 172	
            {
                handler = sendQueryPreamble(handler, flags);
                ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/d,
                sendSync();
                processResults(handler, flags);
                estimatedReceiveBufferBytes = 0;
            }								 
/s,
org.postgresql.core.v3.QueryExecutorImpl.sendSync() line: 1164	
        pgStream.SendChar('S');     // Sync
        pgStream.SendInteger4(4); // Length
        pgStream.flush();										 
/t,
/s,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 1700	
        boolean noResults = (flags & QueryExecutor.QUERY_NO_RESULTS) != 0;
true	, 4 & 4 == 0
        boolean bothRowsAndStatus = (flags & QueryExecutor.QUERY_BOTH_ROWS_AND_STATUS) != 0;
false, 4 & 64 ==0

        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            case '2':    // Bind Complete  (response to Bind)
                pgStream.ReceiveInteger4(); // len, discarded

                Portal boundPortal = pendingBindQueue.removeFirst();
boundPortal	org.postgresql.core.v3.Portal  (id=23446)	
	cleanupRef	null	
	encodedName	(id=23506)	
	portalName	"unnamed" (id=23505)	
	query	null	

                if (logger.logDebug())
                    logger.debug(" <=BE BindComplete [" + boundPortal + "]");

                registerOpenPortal(boundPortal);	/ NIETS, want is unnamed,
                break;
/ volgende,
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            case 'n':    // No Data        (response to Describe)
                pgStream.ReceiveInteger4(); // len, discarded
                if (logger.logDebug())
                    logger.debug(" <=BE NoData");

                pendingDescribePortalQueue.removeFirst(); 	/ SimpleQuery,

                if (doneAfterRowDescNoData) {
/n,
                    DescribeRequest describeData = pendingDescribeStatementQueue.removeFirst();
                    SimpleQuery currentQuery = describeData.query;

                    Field[] fields = currentQuery.getFields();

                    if (fields != null)
                    { // There was a resultset.
                        tuples = new ArrayList();
                        handler.handleResultRows(currentQuery, fields, tuples, null);
                        tuples = null;
                    }
                }
                break;
/ volgende,
            case 'E':  // Error Response (response to pretty much everything; backend then skips until Sync)
                SQLException error = receiveErrorResponse();
org.postgresql.util.PSQLException: ERROR: duplicate key value violates unique constraint "language_pkey"
  Detail: Key (id)=(152) already exists. 
				handler.handleError(error);
/s,
        public void handleError(SQLException newError) {
            if (error == null)
                error = newError;
            else
                error.setNextException(newError);
        }
/t,
                // keep processing
                break;
/ volgende,	
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case 'Z':    // Ready For Query (eventual response to Sync)
                receiveRFQ();
/s,
        if (pgStream.ReceiveInteger4() != 5)
            throw new IOException("unexpected length of ReadyForQuery message");

        char tStatus = (char)pgStream.ReceiveChar();
        
        // Update connection state.
        switch (tStatus)
        {
        case 'I':
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);
            break;
        case 'T':
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_OPEN);
            break;
        case 'E':
/j,
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_FAILED);
            break;
/t,
org.postgresql.core.v3.QueryExecutorImpl.processResults(org.postgresql.core.ResultHandler, int) line: 2005	
                receiveRFQ();
/d,
                endQuery = true;

                // Reset the statement name of Parses that failed.
                while (!pendingParseQueue.isEmpty())
/n,
                {
                    SimpleQuery failedQuery = pendingParseQueue.removeFirst();
                    failedQuery.unprepare();
                }

                pendingParseQueue.clear();              // No more ParseComplete messages expected.
                pendingDescribeStatementQueue.clear();  // No more ParameterDescription messages expected.
/ HIER HIER HIER
                pendingDescribePortalQueue.clear();     // No more RowDescription messages expected.
                pendingBindQueue.clear();               // No more BindComplete messages expected.
                pendingExecuteQueue.clear();            // No more query executions expected.
                break;
/ GEEN volgende meer,
/t,
org.postgresql.core.v3.QueryExecutorImpl.execute(org.postgresql.core.Query, org.postgresql.core.ParameterList, org.postgresql.core.ResultHandler, int, int, int) line: 174	
            {
                handler = sendQueryPreamble(handler, flags);
                ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
                sendSync();
                processResults(handler, flags);
/d,
                estimatedReceiveBufferBytes = 0;
            }
        handler.handleCompletion();
/s,
org.postgresql.jdbc2.AbstractJdbc2Statement$StatementResultHandler.handleCompletion() line: 293	
			

/ STRAKS

omgekeerd	, 

com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionImple.enlistResource(javax.transaction.xa.XAResource) line: 423	
		return enlistResource(xaRes, null);
/cb,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener$TransactionSynchronization.enlist() line: 986	
            XAResource resource = getXAResource();
            if (!currentTx.enlistResource(resource))
/cb,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 379	
            for (int i = 0; i < size; ++i)
            {
               TransactionSynchronization sync = (TransactionSynchronization) unenlisted.get(i);
               if (sync.enlist())																		<-
               {
                  synchronizer.addEnlisted(sync);
               }
/cb,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.managedConnectionReconnected(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 553
      try
      {
         if (shouldEnlist(cl.getManagedConnection()))
            cl.enlist();
/cb,			
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).reconnectManagedConnection(org.jboss.jca.core.connectionmanager.listener.ConnectionListener) line: 928
      try
      {
         managedConnectionReconnected(cl);
/cb,		 
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);

      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
/cb,
org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	



/ Einde STRAKS

/ 7	. 

/ op een gegeven moment	,

/ 2 threads tegelijk	,

/ precies de method die ik moet hebben,  maar dit is buiten een trans-action, 

Thread [ServerService Thread Pool -- 126] (Suspended (breakpoint at line 733 in org.jboss.jca.core.connectionmanager.AbstractConnectionManager))
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 733	
/=
   public Object allocateConnection(ManagedConnectionFactory mcf, ConnectionRequestInfo cri) throws ResourceException
mcf=XAManagedConnectionFactory@34e052f9[xaDataSourceClass=org.postgresql.xa.PGXADataSource xaProps=7282f53f userName=null password=**** transactionIsolation=-1]
	org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
	org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection() line: 180	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 68	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 35	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(org.hibernate.service.spi.ServiceInitiator<R>) line: 88	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).createService(org.hibernate.service.spi.ServiceBinding<R>) line: 254	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 228	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(java.util.Map) line: 51	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(org.hibernate.service.spi.ServiceBinding<R>) line: 94	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 237	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.handleTypes(org.hibernate.boot.spi.MetadataBuildingOptions) line: 352	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(org.hibernate.boot.model.process.spi.ManagedResources, org.hibernate.boot.spi.MetadataBuildingOptions) line: 111	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata() line: 847	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build() line: 874	
	org.jboss.as.jpa.hibernate5.TwoPhaseBootstrapImpl.build() line: 44	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 161	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 121	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedAction<T>, java.security.AccessControlContext) line: 667	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1.run() line: 193	
	java.util.concurrent.ThreadPoolExecutor.runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	org.jboss.threads.JBossThread(java.lang.Thread).run() line: 748	
	org.jboss.threads.JBossThread.run() line: 320	


Thread [ServerService Thread Pool -- 127] (Suspended (breakpoint at line 733 in org.jboss.jca.core.connectionmanager.AbstractConnectionManager))
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 733	
/=
   public Object allocateConnection(ManagedConnectionFactory mcf, ConnectionRequestInfo cri) throws ResourceException
mcf=XAManagedConnectionFactory@74d5728d[xaDataSourceClass=org.h2.jdbcx.JdbcDataSource xaProps=58965d0a userName=sa password=**** transactionIsolation=-1]
	org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
	org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection() line: 180	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 68	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 35	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(org.hibernate.service.spi.ServiceInitiator<R>) line: 88	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).createService(org.hibernate.service.spi.ServiceBinding<R>) line: 254	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 228	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(java.util.Map) line: 51	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(org.hibernate.service.spi.ServiceBinding<R>) line: 94	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 237	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.handleTypes(org.hibernate.boot.spi.MetadataBuildingOptions) line: 352	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(org.hibernate.boot.model.process.spi.ManagedResources, org.hibernate.boot.spi.MetadataBuildingOptions) line: 111	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata() line: 847	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build() line: 874	
	org.jboss.as.jpa.hibernate5.TwoPhaseBootstrapImpl.build() line: 44	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 161	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 121	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedAction<T>, java.security.AccessControlContext) line: 667	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1.run() line: 193	
	java.util.concurrent.ThreadPoolExecutor.runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	org.jboss.threads.JBossThread(java.lang.Thread).run() line: 748	
	org.jboss.threads.JBossThread.run() line: 320

/ we debug de pg, 
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 733	

      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);

      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
	  
/ we debug eerst 	,

/ 13	. 

      ConnectionListener cl = getManagedConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
      try
      {
         return pool.getConnection(transaction, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 581	
      // Get specific managed connection pool key
      Object key = getKey(subject, cri, separateNoTx);

      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getManagedConnectionPool(java.lang.Object, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 295	
      try
      {
         ManagedConnectionPool mcp = mcpPools.get(key);
mcpPools={false=SemaphoreConcurrentLinkedQueueManagedConnectionPool@46712022[pool=RemoteExampleDS]}
		return mcp;
/t,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 587	
      // Get managed connection pool
      ManagedConnectionPool mcp = getManagedConnectionPool(key, subject, cri);
/d,
      // Are we doing track by transaction ?
      TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry();
      Object transactionKey = tsr != null ? tsr.getTransactionKey() : null;
null
/ TODO
      if (trackByTransaction == null || transactionKey == null)
/j,
      {
         return getSimpleConnection(subject, cri, mcp);
		 
/ NIET	,
      // Transaction old connections
      cl = getTransactionOldConnection(trackByTransaction, mcp);

      // Creates a new connection with given transaction
      if (cl == null)
      {
         cl = getTransactionNewConnection(trackByTransaction, mcp, subject, cri);
/ Einde NIET,
  
/s,
org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getSimpleConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo, org.jboss.jca.core.connectionmanager.pool.mcp.ManagedConnectionPool) line: 617	
      // Get connection from the managed connection pool
      ConnectionListener cl = mcp.getConnection(subject, cri);
/s,
org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool.getConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 268	
            // We have a permit to get a connection. Is there one in the pool already?
            ConnectionListenerWrapper clw = null;
            do 
            {
               if (!isRunning()) 
/n,
               {
                  pool.getLock().release();

                  throw new ResourceException(
                     bundle.thePoolHasBeenShutdown(pool.getName(),
                                                   Integer.toHexString(System.identityHashCode(this))));
               }

               if (fifo)
/n,
               {
                  clw = clq.pollFirst();
               }
               else
               {
                  clw = clq.pollLast();
               }
clw=org.jboss.jca.core.connectionmanager.pool.mcp.SemaphoreConcurrentLinkedDequeManagedConnectionPool$ConnectionListenerWrapper@683fdf40
               if (clw != null) 
               {
                  clw.setCheckedOut(true);
                  checkedOutSize.incrementAndGet();

                  // Yes, we retrieved a ManagedConnection from the pool.
                  // Does it match?
                  try 
                  {
                     Object matchedMC = mcf.matchManagedConnections(Collections.singleton(
                        clw.getConnectionListener().getManagedConnection()), subject, cri);
org.jboss.jca.adapters.jdbc.xa.XAManagedConnection@1713b0e4

                           return clw.getConnectionListener();	/= clw.cl	, clw=connection listener wrapper	,
...
/t,
org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 750	
      // Pick a managed connection from the pool
      Subject subject = getSubject();
      ConnectionListener cl = getManagedConnection(subject, cri);
/d,
      // Tell each connection manager the managed connection is active
      reconnectManagedConnection(cl);
...
/s,
org.jboss.jca.core.connectionmanager.listener.TxConnectionListener.enlist() line: 280	
      if (isEnlisted() || getState().equals(ConnectionState.DESTROY) || getState().equals(ConnectionState.DESTROYED))
/n,
         return;

      // No transaction associated with the thread
      TransactionManager tm = getConnectionManager().getTransactionIntegration().getTransactionManager();
      int status = tm.getStatus();

      if (status == Status.STATUS_NO_TRANSACTION)
/j,
      {
         if (transactionSynchronization != null && transactionSynchronization.currentTx != null)
/n,         {
            String error = "Attempt to use connection outside a transaction when already a tx!";
            log.tracef("%s %s", error, this);
            

            throw new IllegalStateException(error);
         }
         log.tracef("No transaction, no need to enlist: %s", this);

         return;
		 
/ 7	.

/ weer 'n connection die niet in de tx, 

Thread [ServerService Thread Pool -- 126] (Suspended (breakpoint at line 566 in org.jboss.jca.core.connectionmanager.pool.AbstractPool))	
	owns: org.hibernate.boot.registry.internal.StandardServiceRegistryImpl  (id=18272)	
	org.jboss.jca.core.connectionmanager.pool.strategy.OnePool(org.jboss.jca.core.connectionmanager.pool.AbstractPool).getConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 566
/=
   public ConnectionListener getConnection(Transaction trackByTransaction, Subject subject, ConnectionRequestInfo cri)
trackByTransaction=null	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).getManagedConnection(javax.transaction.Transaction, javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 590	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl.getManagedConnection(javax.security.auth.Subject, javax.resource.spi.ConnectionRequestInfo) line: 429	
	org.jboss.jca.core.connectionmanager.tx.TxConnectionManagerImpl(org.jboss.jca.core.connectionmanager.AbstractConnectionManager).allocateConnection(javax.resource.spi.ManagedConnectionFactory, javax.resource.spi.ConnectionRequestInfo) line: 747	
	org.jboss.jca.adapters.jdbc.WrapperDataSource.getConnection() line: 138	
	org.jboss.as.connector.subsystems.datasources.WildFlyDataSource.getConnection() line: 66	
	org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection() line: 122	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection() line: 180	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 68	
	org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(java.util.Map, org.hibernate.service.spi.ServiceRegistryImplementor) line: 35	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(org.hibernate.service.spi.ServiceInitiator<R>) line: 88	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).createService(org.hibernate.service.spi.ServiceBinding<R>) line: 254	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 228	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(java.util.Map) line: 51	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(org.hibernate.service.spi.ServiceBinding<R>) line: 94	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).initializeService(org.hibernate.service.spi.ServiceBinding<R>) line: 237	
	org.hibernate.boot.registry.internal.StandardServiceRegistryImpl(org.hibernate.service.internal.AbstractServiceRegistryImpl).getService(java.lang.Class<R>) line: 207	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.handleTypes(org.hibernate.boot.spi.MetadataBuildingOptions) line: 352	
	org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(org.hibernate.boot.model.process.spi.ManagedResources, org.hibernate.boot.spi.MetadataBuildingOptions) line: 111	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata() line: 847	
	org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build() line: 874	
	org.jboss.as.jpa.hibernate5.TwoPhaseBootstrapImpl.build() line: 44	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 161	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1$1.run() line: 121	
	org.wildfly.security.manager.WildFlySecurityManager.doChecked(java.security.PrivilegedAction<T>, java.security.AccessControlContext) line: 667	
	org.jboss.as.jpa.service.PersistenceUnitServiceImpl$1.run() line: 193	
	java.util.concurrent.ThreadPoolExecutor.runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) line: 1149	
	java.util.concurrent.ThreadPoolExecutor$Worker.run() line: 624	
	org.jboss.threads.JBossThread(java.lang.Thread).run() line: 748	
	org.jboss.threads.JBossThread.run() line: 320	

		
/ Einde DEBUG TX

/ SCRIPTS

/ 7	. 

/ In Linux doen we 	,
$ PGPASSWORD=vi_lang17 psql -Ueric test

/ lees,
https://www.postgresql.org/docs/9.1/static/libpq-pgpass.html

C:\Program Files\PostgreSQL\9.6\bin>echo %appdata%
C:\Users\ervelden\AppData\Roaming

C:\Users\ervelden\AppData\Roaming> mkdir postgresql

$ vi pgpass.conf
*:*:*:eric:vi_lang17

/ Nu kunnen we,
C:\Program Files\PostgreSQL\9.6\bin>psql -Ueric test
psql (9.6.5)
WARNING: Console code page (850) differs from Windows code page (1252)
         8-bit characters might not work correctly. See psql reference
         page "Notes for Windows users" for details.
Type "help" for help.

test=> \q

/ 7	. 

C:\Users\ervelden\bin\for_wildfly>dir
18-04-2018  15:42                80 call_psql.bat
17-04-2018  17:45               245 h2_client.bat
17-04-2018  17:41               174 h2_server.bat

$ vi h2_server.bat

@echo off
set DIR=C:\Users\ervelden\bin\wildfly-10.1.0.Final
java -classpath %DIR%\modules\system\layers\base\com\h2database\h2\main\h2-1.3.173.jar org.h2.tools.Server -tcp

$ vi h2_client.bat

@echo off
set DIR=C:\Users\ervelden\bin\wildfly-10.1.0.Final
java -classpath java -classpath %DIR%\modules\system\layers\base\com\h2database\h2\main\h2-1.3.173.jar org.h2.tools.Shell -url jdbc:h2:tcp://localhost/~/h2/test -user sa -password sa

$ vi call_psql.bat

@echo off
set DIR=C:\"Program Files"\PostgreSQL\9.6\bin
%DIR%\psql -Ueric test








/ Einde SCRIPTS























































/ 7	. 

/ youtube: arquillian dbunit
https://www.youtube.com/watch?v=5P6Ql01vrUg  / rubinger
/ next:
https://www.youtube.com/watch?v=IJ_HQ3zQB_s

https://www.youtube.com/watch?v=YKZU9XNRRNY / knutsen !
https://www.youtube.com/watch?v=WOFUH_R0sAg/ rubinger

https://www.youtube.com/watch?v=pfoJAshalx4&t=5s / jsf testing with selenium & arquillian,

https://www.youtube.com/watch?v=gFLpTjH9dlY







